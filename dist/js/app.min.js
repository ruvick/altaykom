/*! For license information please see app.min.js.LICENSE.txt */
(() => { var e = { 545: function (e) { e.exports = function () { "use strict"; var e = { d: function (t, i) { for (var s in i) e.o(i, s) && !e.o(t, s) && Object.defineProperty(t, s, { enumerable: !0, get: i[s] }) }, o: function (e, t) { return Object.prototype.hasOwnProperty.call(e, t) } }, t = {}; e.d(t, { default: function () { return q } }); var i = { days: "days", months: "months", years: "years", day: "day", month: "month", year: "year", eventChangeViewDate: "changeViewDate", eventChangeCurrentView: "changeCurrentView", eventChangeFocusDate: "changeFocusDate", eventChangeSelectedDate: "changeSelectedDate", eventChangeTime: "changeTime", eventChangeLastSelectedDate: "changeLastSelectedDate", actionSelectDate: "selectDate", actionUnselectDate: "unselectDate", cssClassWeekend: "-weekend-" }, s = { classes: "", inline: !1, locale: { days: ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"], daysShort: ["Вос", "Пон", "Вто", "Сре", "Чет", "Пят", "Суб"], daysMin: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"], months: ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"], monthsShort: ["Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек"], today: "Сегодня", clear: "Очистить", dateFormat: "dd.MM.yyyy", timeFormat: "HH:mm", firstDay: 1 }, startDate: new Date, firstDay: "", weekends: [6, 0], dateFormat: "", altField: "", altFieldDateFormat: "T", toggleSelected: !0, keyboardNav: !0, selectedDates: !1, container: "", isMobile: !1, visible: !1, position: "bottom left", offset: 12, view: i.days, minView: i.days, showOtherMonths: !0, selectOtherMonths: !0, moveToOtherMonthsOnSelect: !0, showOtherYears: !0, selectOtherYears: !0, moveToOtherYearsOnSelect: !0, minDate: "", maxDate: "", disableNavWhenOutOfRange: !0, multipleDates: !1, multipleDatesSeparator: ", ", range: !1, dynamicRange: !0, buttons: !1, monthsField: "monthsShort", showEvent: "focus", autoClose: !1, prevHtml: '<svg><path d="M 17,12 l -5,5 l 5,5"></path></svg>', nextHtml: '<svg><path d="M 14,12 l 5,5 l -5,5"></path></svg>', navTitles: { days: "MMMM, <i>yyyy</i>", months: "yyyy", years: "yyyy1 - yyyy2" }, timepicker: !1, onlyTimepicker: !1, dateTimeSeparator: " ", timeFormat: "", minHours: 0, maxHours: 24, minMinutes: 0, maxMinutes: 59, hoursStep: 1, minutesStep: 1, onSelect: !1, onChangeViewDate: !1, onChangeView: !1, onRenderCell: !1, onShow: !1, onHide: !1, onClickDayName: !1 }; function n(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : document; return "string" == typeof e ? t.querySelector(e) : e } function r() { let { tagName: e = "div", className: t = "", innerHtml: i = "", id: s = "", attrs: n = {} } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, r = document.createElement(e); return t && r.classList.add(...t.split(" ")), s && (r.id = s), i && (r.innerHTML = i), n && o(r, n), r } function o(e, t) { for (let [i, s] of Object.entries(t)) void 0 !== s && e.setAttribute(i, s); return e } function a(e) { return new Date(e.getFullYear(), e.getMonth() + 1, 0).getDate() } function l(e) { let t = e.getHours(), { hours: i, dayPeriod: s } = d(t); return { year: e.getFullYear(), month: e.getMonth(), fullMonth: e.getMonth() + 1 < 10 ? "0" + (e.getMonth() + 1) : e.getMonth() + 1, date: e.getDate(), fullDate: e.getDate() < 10 ? "0" + e.getDate() : e.getDate(), day: e.getDay(), hours: t, fullHours: c(t), hours12: i, dayPeriod: s, fullHours12: c(i), minutes: e.getMinutes(), fullMinutes: e.getMinutes() < 10 ? "0" + e.getMinutes() : e.getMinutes() } } function d(e) { return { dayPeriod: e > 11 ? "pm" : "am", hours: e % 12 == 0 ? 12 : e % 12 } } function c(e) { return e < 10 ? "0" + e : e } function u(e) { let t = 10 * Math.floor(e.getFullYear() / 10); return [t, t + 9] } function h() { let e = []; for (var t = arguments.length, i = new Array(t), s = 0; s < t; s++)i[s] = arguments[s]; return i.forEach((t => { if ("object" == typeof t) for (let i in t) t[i] && e.push(i); else t && e.push(t) })), e.join(" ") } function p(e, t) { let s = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i.days; if (!e || !t) return !1; let n = l(e), r = l(t); return { [i.days]: n.date === r.date && n.month === r.month && n.year === r.year, [i.months]: n.month === r.month && n.year === r.year, [i.years]: n.year === r.year }[s] } function f(e, t, i) { let s = g(e, !1).getTime(), n = g(t, !1).getTime(); return i ? s >= n : s > n } function m(e, t) { return !f(e, t, !0) } function g(e) { let t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = new Date(e.getTime()); return "boolean" != typeof t || t || v(i), i } function v(e) { return e.setHours(0, 0, 0, 0), e } function y(e, t, i) { e.length ? e.forEach((e => { e.addEventListener(t, i) })) : e.addEventListener(t, i) } function b(e, t) { return !(!e || e === document || e instanceof DocumentFragment) && (e.matches(t) ? e : b(e.parentNode, t)) } function w(e, t, i) { return e > i ? i : e < t ? t : e } function S(e) { for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)i[s - 1] = arguments[s]; return i.filter((e => e)).forEach((t => { for (let [i, s] of Object.entries(t)) if (void 0 !== s && "[object Object]" === s.toString()) { let t = void 0 !== e[i] ? e[i].toString() : void 0, n = s.toString(), r = Array.isArray(s) ? [] : {}; e[i] = e[i] ? t !== n ? r : e[i] : r, S(e[i], s) } else e[i] = s })), e } function x(e) { let t = e; return e instanceof Date || (t = new Date(e)), isNaN(t.getTime()) && (console.log(`Unable to convert value "${e}" to Date object`), t = !1), t } function C(e) { let t = "\\s|\\.|-|/|\\\\|,|\\$|\\!|\\?|:|;"; return new RegExp("(^|>|" + t + ")(" + e + ")($|<|" + t + ")", "g") } function E(e, t, i) { return (t = function (e) { var t = function (e, t) { if ("object" != typeof e || null === e) return e; var i = e[Symbol.toPrimitive]; if (void 0 !== i) { var s = i.call(e, t); if ("object" != typeof s) return s; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(e) }(e, "string"); return "symbol" == typeof t ? t : String(t) }(t)) in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } class T { constructor() { let { type: e, date: t, dp: i, opts: s, body: n } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; E(this, "focus", (() => { this.$cell.classList.add("-focus-"), this.focused = !0 })), E(this, "removeFocus", (() => { this.$cell.classList.remove("-focus-"), this.focused = !1 })), E(this, "select", (() => { this.$cell.classList.add("-selected-"), this.selected = !0 })), E(this, "removeSelect", (() => { this.$cell.classList.remove("-selected-", "-range-from-", "-range-to-"), this.selected = !1 })), E(this, "onChangeSelectedDate", (() => { this.isDisabled || (this._handleSelectedStatus(), this.opts.range && this._handleRangeStatus()) })), E(this, "onChangeFocusDate", (e => { if (!e) return void (this.focused && this.removeFocus()); let t = p(e, this.date, this.type); t ? this.focus() : !t && this.focused && this.removeFocus(), this.opts.range && this._handleRangeStatus() })), E(this, "render", (() => (this.$cell.innerHTML = this._getHtml(), this.$cell.adpCell = this, this.$cell))), this.type = e, this.singleType = this.type.slice(0, -1), this.date = t, this.dp = i, this.opts = s, this.body = n, this.customData = !1, this.init() } init() { let { range: e, onRenderCell: t } = this.opts; t && (this.customData = t({ date: this.date, cellType: this.singleType, datepicker: this.dp })), this._createElement(), this._bindDatepickerEvents(), this._handleInitialFocusStatus(), this.dp.hasSelectedDates && (this._handleSelectedStatus(), e && this._handleRangeStatus()) } _bindDatepickerEvents() { this.dp.on(i.eventChangeSelectedDate, this.onChangeSelectedDate), this.dp.on(i.eventChangeFocusDate, this.onChangeFocusDate) } unbindDatepickerEvents() { this.dp.off(i.eventChangeSelectedDate, this.onChangeSelectedDate), this.dp.off(i.eventChangeFocusDate, this.onChangeFocusDate) } _createElement() { var e; let { year: t, month: i, date: s } = l(this.date), n = (null === (e = this.customData) || void 0 === e ? void 0 : e.attrs) || {}; this.$cell = r({ className: this._getClassName(), attrs: { "data-year": t, "data-month": i, "data-date": s, ...n } }) } _getClassName() { var e, t; let s = new Date, { selectOtherMonths: n, selectOtherYears: r } = this.opts, { minDate: o, maxDate: a } = this.dp, { day: d } = l(this.date), c = this._isOutOfMinMaxRange(), u = null === (e = this.customData) || void 0 === e ? void 0 : e.disabled, f = h("air-datepicker-cell", `-${this.singleType}-`, { "-current-": p(s, this.date, this.type), "-min-date-": o && p(o, this.date, this.type), "-max-date-": a && p(a, this.date, this.type) }), m = ""; switch (this.type) { case i.days: m = h({ "-weekend-": this.dp.isWeekend(d), "-other-month-": this.isOtherMonth, "-disabled-": this.isOtherMonth && !n || c || u }); break; case i.months: m = h({ "-disabled-": c || u }); break; case i.years: m = h({ "-other-decade-": this.isOtherDecade, "-disabled-": c || this.isOtherDecade && !r || u }) }return h(f, m, null === (t = this.customData) || void 0 === t ? void 0 : t.classes) } _getHtml() { var e; let { year: t, month: s, date: n } = l(this.date), { showOtherMonths: r, showOtherYears: o } = this.opts; if (null !== (e = this.customData) && void 0 !== e && e.html) return this.customData.html; switch (this.type) { case i.days: return !r && this.isOtherMonth ? "" : n; case i.months: return this.dp.locale[this.opts.monthsField][s]; case i.years: return !o && this.isOtherDecade ? "" : t } } _isOutOfMinMaxRange() { let { minDate: e, maxDate: t } = this.dp, { type: s, date: n } = this, { month: r, year: o, date: a } = l(n), d = s === i.days, c = s === i.years, u = !!e && new Date(o, c ? e.getMonth() : r, d ? a : e.getDate()), h = !!t && new Date(o, c ? t.getMonth() : r, d ? a : t.getDate()); return e && t ? m(u, e) || f(h, t) : e ? m(u, e) : t ? f(h, t) : void 0 } destroy() { this.unbindDatepickerEvents() } _handleRangeStatus() { let { rangeDateFrom: e, rangeDateTo: t } = this.dp, i = h({ "-in-range-": e && t && (s = this.date, n = e, r = t, f(s, n) && m(s, r)), "-range-from-": e && p(this.date, e, this.type), "-range-to-": t && p(this.date, t, this.type) }); var s, n, r; this.$cell.classList.remove("-range-from-", "-range-to-", "-in-range-"), i && this.$cell.classList.add(...i.split(" ")) } _handleSelectedStatus() { let e = this.dp._checkIfDateIsSelected(this.date, this.type); e ? this.select() : !e && this.selected && this.removeSelect() } _handleInitialFocusStatus() { p(this.dp.focusDate, this.date, this.type) && this.focus() } get isDisabled() { return this.$cell.matches(".-disabled-") } get isOtherMonth() { return this.dp.isOtherMonth(this.date) } get isOtherDecade() { return this.dp.isOtherDecade(this.date) } } function D(e, t, i) { return (t = function (e) { var t = function (e, t) { if ("object" != typeof e || null === e) return e; var i = e[Symbol.toPrimitive]; if (void 0 !== i) { var s = i.call(e, t); if ("object" != typeof s) return s; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(e) }(e, "string"); return "symbol" == typeof t ? t : String(t) }(t)) in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } let k = { [i.days]: `<div class="air-datepicker-body--day-names"></div><div class="air-datepicker-body--cells -${i.days}-"></div>`, [i.months]: `<div class="air-datepicker-body--cells -${i.months}-"></div>`, [i.years]: `<div class="air-datepicker-body--cells -${i.years}-"></div>` }; const L = ".air-datepicker-cell"; class _ { constructor(e) { let { dp: t, type: s, opts: n } = e; D(this, "handleClick", (e => { let t = e.target.closest(L).adpCell; if (t.isDisabled) return; if (!this.dp.isMinViewReached) return void this.dp.down(); let i = this.dp._checkIfDateIsSelected(t.date, t.type); i ? this.dp._handleAlreadySelectedDates(i, t.date) : this.dp.selectDate(t.date) })), D(this, "handleDayNameClick", (e => { let t = e.target.getAttribute("data-day-index"); this.opts.onClickDayName({ dayIndex: Number(t), datepicker: this.dp }) })), D(this, "onChangeCurrentView", (e => { e !== this.type ? this.hide() : (this.show(), this.render()) })), D(this, "onMouseOverCell", (e => { let t = b(e.target, L); this.dp.setFocusDate(!!t && t.adpCell.date) })), D(this, "onMouseOutCell", (() => { this.dp.setFocusDate(!1) })), D(this, "onClickBody", (e => { let { onClickDayName: t } = this.opts, i = e.target; i.closest(L) && this.handleClick(e), t && i.closest(".air-datepicker-body--day-name") && this.handleDayNameClick(e) })), D(this, "onMouseDown", (e => { this.pressed = !0; let t = b(e.target, L), i = t && t.adpCell; p(i.date, this.dp.rangeDateFrom) && (this.rangeFromFocused = !0), p(i.date, this.dp.rangeDateTo) && (this.rangeToFocused = !0) })), D(this, "onMouseMove", (e => { if (!this.pressed || !this.dp.isMinViewReached) return; e.preventDefault(); let t = b(e.target, L), i = t && t.adpCell, { selectedDates: s, rangeDateTo: n, rangeDateFrom: r } = this.dp; if (!i || i.isDisabled) return; let { date: o } = i; if (2 === s.length) { if (this.rangeFromFocused && !f(o, n)) { let { hours: e, minutes: t } = l(r); o.setHours(e), o.setMinutes(t), this.dp.rangeDateFrom = o, this.dp.replaceDate(r, o) } if (this.rangeToFocused && !m(o, r)) { let { hours: e, minutes: t } = l(n); o.setHours(e), o.setMinutes(t), this.dp.rangeDateTo = o, this.dp.replaceDate(n, o) } } })), D(this, "onMouseUp", (() => { this.pressed = !1, this.rangeFromFocused = !1, this.rangeToFocused = !1 })), D(this, "onChangeViewDate", ((e, t) => { if (!this.isVisible) return; let s = u(e), n = u(t); switch (this.dp.currentView) { case i.days: if (p(e, t, i.months)) return; break; case i.months: if (p(e, t, i.years)) return; break; case i.years: if (s[0] === n[0] && s[1] === n[1]) return }this.render() })), D(this, "render", (() => { this.destroyCells(), this._generateCells(), this.cells.forEach((e => { this.$cells.appendChild(e.render()) })) })), this.dp = t, this.type = s, this.opts = n, this.cells = [], this.$el = "", this.pressed = !1, this.isVisible = !0, this.init() } init() { this._buildBaseHtml(), this.type === i.days && this.renderDayNames(), this.render(), this._bindEvents(), this._bindDatepickerEvents() } _bindEvents() { let { range: e, dynamicRange: t } = this.opts; y(this.$el, "mouseover", this.onMouseOverCell), y(this.$el, "mouseout", this.onMouseOutCell), y(this.$el, "click", this.onClickBody), e && t && (y(this.$el, "mousedown", this.onMouseDown), y(this.$el, "mousemove", this.onMouseMove), y(window.document, "mouseup", this.onMouseUp)) } _bindDatepickerEvents() { this.dp.on(i.eventChangeViewDate, this.onChangeViewDate), this.dp.on(i.eventChangeCurrentView, this.onChangeCurrentView) } _buildBaseHtml() { this.$el = r({ className: `air-datepicker-body -${this.type}-`, innerHtml: k[this.type] }), this.$names = n(".air-datepicker-body--day-names", this.$el), this.$cells = n(".air-datepicker-body--cells", this.$el) } _getDayNamesHtml() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.dp.locale.firstDay, t = "", s = this.dp.isWeekend, { onClickDayName: n } = this.opts, r = e, o = 0; for (; o < 7;) { let e = r % 7; t += `<div class="${h("air-datepicker-body--day-name", { [i.cssClassWeekend]: s(e), "-clickable-": !!n })}" data-day-index='${e}'>${this.dp.locale.daysMin[e]}</div>`, o++, r++ } return t } _getDaysCells() { let { viewDate: e, locale: { firstDay: t } } = this.dp, i = a(e), { year: s, month: n } = l(e), r = new Date(s, n, 1), o = new Date(s, n, i), d = r.getDay() - t, c = 6 - o.getDay() + t; d = d < 0 ? d + 7 : d, c = c > 6 ? c - 7 : c; let u = function (e, t) { let { year: i, month: s, date: n } = l(e); return new Date(i, s, n - t) }(r, d), h = i + d + c, p = u.getDate(), { year: f, month: m } = l(u), g = 0; for (; g < h;) { let e = new Date(f, m, p + g); this._generateCell(e), g++ } } _generateCell(e) { let { type: t, dp: i, opts: s } = this, n = new T({ type: t, dp: i, opts: s, date: e, body: this }); return this.cells.push(n), n } _generateDayCells() { this._getDaysCells() } _generateMonthCells() { let { year: e } = this.dp.parsedViewDate, t = 0; for (; t < 12;)this.cells.push(this._generateCell(new Date(e, t))), t++ } _generateYearCells() { let e = u(this.dp.viewDate), t = e[0] - 1, i = e[1] + 1, s = t; for (; s <= i;)this.cells.push(this._generateCell(new Date(s, 0))), s++ } renderDayNames() { this.$names.innerHTML = this._getDayNamesHtml() } _generateCells() { switch (this.type) { case i.days: this._generateDayCells(); break; case i.months: this._generateMonthCells(); break; case i.years: this._generateYearCells() } } show() { this.isVisible = !0, this.$el.classList.remove("-hidden-") } hide() { this.isVisible = !1, this.$el.classList.add("-hidden-") } destroyCells() { this.cells.forEach((e => e.destroy())), this.cells = [], this.$cells.innerHTML = "" } destroy() { this.destroyCells(), this.dp.off(i.eventChangeViewDate, this.onChangeViewDate), this.dp.off(i.eventChangeCurrentView, this.onChangeCurrentView) } } function O(e, t, i) { return (t = function (e) { var t = function (e, t) { if ("object" != typeof e || null === e) return e; var i = e[Symbol.toPrimitive]; if (void 0 !== i) { var s = i.call(e, t); if ("object" != typeof s) return s; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(e) }(e, "string"); return "symbol" == typeof t ? t : String(t) }(t)) in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } class M { constructor(e) { let { dp: t, opts: i } = e; O(this, "onClickNav", (e => { let t = b(e.target, ".air-datepicker-nav--action"); if (!t) return; let i = t.dataset.action; this.dp[i]() })), O(this, "onChangeViewDate", (() => { this.render(), this._resetNavStatus(), this.handleNavStatus() })), O(this, "onChangeCurrentView", (() => { this.render(), this._resetNavStatus(), this.handleNavStatus() })), O(this, "onClickNavTitle", (() => { this.dp.isFinalView || this.dp.up() })), O(this, "update", (() => { let { prevHtml: e, nextHtml: t } = this.opts; this.$prev.innerHTML = e, this.$next.innerHTML = t, this._resetNavStatus(), this.render(), this.handleNavStatus() })), O(this, "renderDelay", (() => { setTimeout(this.render) })), O(this, "render", (() => { this.$title.innerHTML = this._getTitle(), function (e, t) { for (let i in t) t[i] ? e.classList.add(i) : e.classList.remove(i) }(this.$title, { "-disabled-": this.dp.isFinalView }) })), this.dp = t, this.opts = i, this.init() } init() { this._createElement(), this._buildBaseHtml(), this._defineDOM(), this.render(), this.handleNavStatus(), this._bindEvents(), this._bindDatepickerEvents() } _defineDOM() { this.$title = n(".air-datepicker-nav--title", this.$el), this.$prev = n('[data-action="prev"]', this.$el), this.$next = n('[data-action="next"]', this.$el) } _bindEvents() { this.$el.addEventListener("click", this.onClickNav), this.$title.addEventListener("click", this.onClickNavTitle) } _bindDatepickerEvents() { this.dp.on(i.eventChangeViewDate, this.onChangeViewDate), this.dp.on(i.eventChangeCurrentView, this.onChangeCurrentView), this.isNavIsFunction && (this.dp.on(i.eventChangeSelectedDate, this.renderDelay), this.dp.opts.timepicker && this.dp.on(i.eventChangeTime, this.render)) } destroy() { this.dp.off(i.eventChangeViewDate, this.onChangeViewDate), this.dp.off(i.eventChangeCurrentView, this.onChangeCurrentView), this.isNavIsFunction && (this.dp.off(i.eventChangeSelectedDate, this.renderDelay), this.dp.opts.timepicker && this.dp.off(i.eventChangeTime, this.render)) } _createElement() { this.$el = r({ tagName: "nav", className: "air-datepicker-nav" }) } _getTitle() { let { dp: e, opts: t } = this, i = t.navTitles[e.currentView]; return "function" == typeof i ? i(e) : e.formatDate(e.viewDate, i) } handleNavStatus() { let { disableNavWhenOutOfRange: e } = this.opts, { minDate: t, maxDate: s } = this.dp; if (!t && !s || !e) return; let { year: n, month: r } = this.dp.parsedViewDate, o = !!t && l(t), a = !!s && l(s); switch (this.dp.currentView) { case i.days: t && o.month >= r && o.year >= n && this._disableNav("prev"), s && a.month <= r && a.year <= n && this._disableNav("next"); break; case i.months: t && o.year >= n && this._disableNav("prev"), s && a.year <= n && this._disableNav("next"); break; case i.years: { let e = u(this.dp.viewDate); t && o.year >= e[0] && this._disableNav("prev"), s && a.year <= e[1] && this._disableNav("next"); break } } } _disableNav(e) { n('[data-action="' + e + '"]', this.$el).classList.add("-disabled-") } _resetNavStatus() { !function (e) { for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)i[s - 1] = arguments[s]; e.length ? e.forEach((e => { e.classList.remove(...i) })) : e.classList.remove(...i) }(this.$el.querySelectorAll(".air-datepicker-nav--action"), "-disabled-") } _buildBaseHtml() { let { prevHtml: e, nextHtml: t } = this.opts; this.$el.innerHTML = `<div class="air-datepicker-nav--action" data-action="prev">${e}</div><div class="air-datepicker-nav--title"></div><div class="air-datepicker-nav--action" data-action="next">${t}</div>` } get isNavIsFunction() { let { navTitles: e } = this.opts; return Object.keys(e).find((t => "function" == typeof e[t])) } } var A = { today: { content: e => e.locale.today, onClick: e => e.setViewDate(new Date) }, clear: { content: e => e.locale.clear, onClick: e => e.clear() } }; class P { constructor(e) { let { dp: t, opts: i } = e; this.dp = t, this.opts = i, this.init() } init() { this.createElement(), this.render() } createElement() { this.$el = r({ className: "air-datepicker-buttons" }) } destroy() { this.$el.parentNode.removeChild(this.$el) } clearHtml() { return this.$el.innerHTML = "", this } generateButtons() { let { buttons: e } = this.opts; Array.isArray(e) || (e = [e]), e.forEach((e => { let t = e; "string" == typeof e && A[e] && (t = A[e]); let i = this.createButton(t); t.onClick && this.attachEventToButton(i, t.onClick), this.$el.appendChild(i) })) } attachEventToButton(e, t) { e.addEventListener("click", (() => { t(this.dp) })) } createButton(e) { let { content: t, className: i, tagName: s = "button", attrs: n = {} } = e; return r({ tagName: s, innerHtml: `<span tabindex='-1'>${"function" == typeof t ? t(this.dp) : t}</span>`, className: h("air-datepicker-button", i), attrs: n }) } render() { this.generateButtons() } } function I(e, t, i) { return (t = function (e) { var t = function (e, t) { if ("object" != typeof e || null === e) return e; var i = e[Symbol.toPrimitive]; if (void 0 !== i) { var s = i.call(e, t); if ("object" != typeof s) return s; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(e) }(e, "string"); return "symbol" == typeof t ? t : String(t) }(t)) in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } class $ { constructor() { let { opts: e, dp: t } = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; I(this, "toggleTimepickerIsActive", (e => { this.dp.timepickerIsActive = e })), I(this, "onChangeSelectedDate", (e => { let { date: t, updateTime: i = !1 } = e; t && (this.setMinMaxTime(t), this.setCurrentTime(!!i && t), this.addTimeToDate(t)) })), I(this, "onChangeLastSelectedDate", (e => { e && (this.setTime(e), this.render()) })), I(this, "onChangeInputRange", (e => { let t = e.target; this[t.getAttribute("name")] = t.value, this.updateText(), this.dp.trigger(i.eventChangeTime, { hours: this.hours, minutes: this.minutes }) })), I(this, "onMouseEnterLeave", (e => { let t = e.target.getAttribute("name"), i = this.$minutesText; "hours" === t && (i = this.$hoursText), i.classList.toggle("-focus-") })), I(this, "onFocus", (() => { this.toggleTimepickerIsActive(!0) })), I(this, "onBlur", (() => { this.toggleTimepickerIsActive(!1) })), this.opts = e, this.dp = t; let { timeFormat: s } = this.dp.locale; s && (s.match(C("h")) || s.match(C("hh"))) && (this.ampm = !0), this.init() } init() { this.setTime(this.dp.lastSelectedDate || this.dp.viewDate), this.createElement(), this.buildHtml(), this.defineDOM(), this.render(), this.bindDatepickerEvents(), this.bindDOMEvents() } bindDatepickerEvents() { this.dp.on(i.eventChangeSelectedDate, this.onChangeSelectedDate), this.dp.on(i.eventChangeLastSelectedDate, this.onChangeLastSelectedDate) } bindDOMEvents() { let e = "input"; navigator.userAgent.match(/trident/gi) && (e = "change"), y(this.$ranges, e, this.onChangeInputRange), y(this.$ranges, "mouseenter", this.onMouseEnterLeave), y(this.$ranges, "mouseleave", this.onMouseEnterLeave), y(this.$ranges, "focus", this.onFocus), y(this.$ranges, "mousedown", this.onFocus), y(this.$ranges, "blur", this.onBlur) } createElement() { this.$el = r({ className: h("air-datepicker-time", { "-am-pm-": this.dp.ampm }) }) } destroy() { this.dp.off(i.eventChangeSelectedDate, this.onChangeSelectedDate), this.dp.off(i.eventChangeLastSelectedDate, this.onChangeLastSelectedDate), this.$el.parentNode.removeChild(this.$el) } buildHtml() { let { ampm: e, hours: t, displayHours: i, minutes: s, minHours: n, minMinutes: r, maxHours: o, maxMinutes: a, dayPeriod: l, opts: { hoursStep: d, minutesStep: u } } = this; this.$el.innerHTML = `<div class="air-datepicker-time--current">   <span class="air-datepicker-time--current-hours">${c(i)}</span>   <span class="air-datepicker-time--current-colon">:</span>   <span class="air-datepicker-time--current-minutes">${c(s)}</span>   ` + (e ? `<span class='air-datepicker-time--current-ampm'>${l}</span>` : "") + '</div><div class="air-datepicker-time--sliders">   <div class="air-datepicker-time--row">' + `      <input type="range" name="hours" value="${t}" min="${n}" max="${o}" step="${d}"/>   </div>   <div class="air-datepicker-time--row">` + `      <input type="range" name="minutes" value="${s}" min="${r}" max="${a}" step="${u}"/>   </div></div>` } defineDOM() { let e = e => n(e, this.$el); this.$ranges = this.$el.querySelectorAll('[type="range"]'), this.$hours = e('[name="hours"]'), this.$minutes = e('[name="minutes"]'), this.$hoursText = e(".air-datepicker-time--current-hours"), this.$minutesText = e(".air-datepicker-time--current-minutes"), this.$ampm = e(".air-datepicker-time--current-ampm") } setTime(e) { this.setMinMaxTime(e), this.setCurrentTime(e) } addTimeToDate(e) { e && (e.setHours(this.hours), e.setMinutes(this.minutes)) } setMinMaxTime(e) { if (this.setMinMaxTimeFromOptions(), e) { let { minDate: t, maxDate: i } = this.dp; t && p(e, t) && this.setMinTimeFromMinDate(t), i && p(e, i) && this.setMaxTimeFromMaxDate(i) } } setCurrentTime(e) { let { hours: t, minutes: i } = e ? l(e) : this; this.hours = w(t, this.minHours, this.maxHours), this.minutes = w(i, this.minMinutes, this.maxMinutes) } setMinMaxTimeFromOptions() { let { minHours: e, minMinutes: t, maxHours: i, maxMinutes: s } = this.opts; this.minHours = w(e, 0, 23), this.minMinutes = w(t, 0, 59), this.maxHours = w(i, 0, 23), this.maxMinutes = w(s, 0, 59) } setMinTimeFromMinDate(e) { let { lastSelectedDate: t } = this.dp; this.minHours = e.getHours(), t && t.getHours() > e.getHours() ? this.minMinutes = this.opts.minMinutes : this.minMinutes = e.getMinutes() } setMaxTimeFromMaxDate(e) { let { lastSelectedDate: t } = this.dp; this.maxHours = e.getHours(), t && t.getHours() < e.getHours() ? this.maxMinutes = this.opts.maxMinutes : this.maxMinutes = e.getMinutes() } updateSliders() { o(this.$hours, { min: this.minHours, max: this.maxHours }).value = this.hours, o(this.$minutes, { min: this.minMinutes, max: this.maxMinutes }).value = this.minutes } updateText() { this.$hoursText.innerHTML = c(this.displayHours), this.$minutesText.innerHTML = c(this.minutes), this.ampm && (this.$ampm.innerHTML = this.dayPeriod) } set hours(e) { this._hours = e; let { hours: t, dayPeriod: i } = d(e); this.displayHours = this.ampm ? t : e, this.dayPeriod = i } get hours() { return this._hours } render() { this.updateSliders(), this.updateText() } } function V(e, t, i) { return (t = function (e) { var t = function (e, t) { if ("object" != typeof e || null === e) return e; var i = e[Symbol.toPrimitive]; if (void 0 !== i) { var s = i.call(e, t); if ("object" != typeof s) return s; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(e) }(e, "string"); return "symbol" == typeof t ? t : String(t) }(t)) in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } class N { constructor(e) { let { dp: t, opts: i } = e; V(this, "pressedKeys", new Set), V(this, "hotKeys", new Map([[[["Control", "ArrowRight"], ["Control", "ArrowUp"]], e => e.month++], [[["Control", "ArrowLeft"], ["Control", "ArrowDown"]], e => e.month--], [[["Shift", "ArrowRight"], ["Shift", "ArrowUp"]], e => e.year++], [[["Shift", "ArrowLeft"], ["Shift", "ArrowDown"]], e => e.year--], [[["Alt", "ArrowRight"], ["Alt", "ArrowUp"]], e => e.year += 10], [[["Alt", "ArrowLeft"], ["Alt", "ArrowDown"]], e => e.year -= 10], [["Control", "Shift", "ArrowUp"], (e, t) => t.up()]])), V(this, "handleHotKey", (e => { let t = this.hotKeys.get(e), i = l(this.getInitialFocusDate()); t(i, this.dp); let { year: s, month: n, date: r } = i, o = a(new Date(s, n)); o < r && (r = o); let d = this.dp.getClampedDate(new Date(s, n, r)); this.dp.setFocusDate(d, { viewDateTransition: !0 }) })), V(this, "isHotKeyPressed", (() => { let e = !1, t = this.pressedKeys.size, i = e => this.pressedKeys.has(e); for (let [s] of this.hotKeys) { if (e) break; if (Array.isArray(s[0])) s.forEach((n => { e || t !== n.length || (e = n.every(i) && s) })); else { if (t !== s.length) continue; e = s.every(i) && s } } return e })), V(this, "isArrow", (e => e >= 37 && e <= 40)), V(this, "onKeyDown", (e => { let { key: t, which: i } = e, { dp: s, dp: { focusDate: n }, opts: r } = this; this.registerKey(t); let o = this.isHotKeyPressed(); if (o) return e.preventDefault(), void this.handleHotKey(o); if (this.isArrow(i)) return e.preventDefault(), void this.focusNextCell(t); if ("Enter" === t) { if (s.currentView !== r.minView) return void s.down(); if (n) { let e = s._checkIfDateIsSelected(n); return void (e ? s._handleAlreadySelectedDates(e, n) : s.selectDate(n)) } } "Escape" === t && this.dp.hide() })), V(this, "onKeyUp", (e => { this.removeKey(e.key) })), this.dp = t, this.opts = i, this.init() } init() { this.bindKeyboardEvents() } bindKeyboardEvents() { let { $el: e } = this.dp; e.addEventListener("keydown", this.onKeyDown), e.addEventListener("keyup", this.onKeyUp) } destroy() { let { $el: e } = this.dp; e.removeEventListener("keydown", this.onKeyDown), e.removeEventListener("keyup", this.onKeyUp), this.hotKeys = null, this.pressedKeys = null } getInitialFocusDate() { let { focusDate: e, currentView: t, selectedDates: s, parsedViewDate: { year: n, month: r } } = this.dp, o = e || s[s.length - 1]; if (!o) switch (t) { case i.days: o = new Date(n, r, (new Date).getDate()); break; case i.months: o = new Date(n, r, 1); break; case i.years: o = new Date(n, 0, 1) }return o } focusNextCell(e) { let t = this.getInitialFocusDate(), { currentView: s } = this.dp, { days: n, months: r, years: o } = i, a = l(t), d = a.year, c = a.month, u = a.date; switch (e) { case "ArrowLeft": s === n && (u -= 1), s === r && (c -= 1), s === o && (d -= 1); break; case "ArrowUp": s === n && (u -= 7), s === r && (c -= 3), s === o && (d -= 4); break; case "ArrowRight": s === n && (u += 1), s === r && (c += 1), s === o && (d += 1); break; case "ArrowDown": s === n && (u += 7), s === r && (c += 3), s === o && (d += 4) }let h = this.dp.getClampedDate(new Date(d, c, u)); this.dp.setFocusDate(h, { viewDateTransition: !0 }) } registerKey(e) { this.pressedKeys.add(e) } removeKey(e) { this.pressedKeys.delete(e) } } let H = { on(e, t) { this.__events || (this.__events = {}), this.__events[e] ? this.__events[e].push(t) : this.__events[e] = [t] }, off(e, t) { this.__events && this.__events[e] && (this.__events[e] = this.__events[e].filter((e => e !== t))) }, removeAllEvents() { this.__events = {} }, trigger(e) { for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++)i[s - 1] = arguments[s]; this.__events && this.__events[e] && this.__events[e].forEach((e => { e(...i) })) } }; function B(e, t, i) { return (t = function (e) { var t = function (e, t) { if ("object" != typeof e || null === e) return e; var i = e[Symbol.toPrimitive]; if (void 0 !== i) { var s = i.call(e, t); if ("object" != typeof s) return s; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(e) }(e, "string"); return "symbol" == typeof t ? t : String(t) }(t)) in e ? Object.defineProperty(e, t, { value: i, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = i, e } let F = "", z = "", j = !1; class q { static buildGlobalContainer(e) { j = !0, F = r({ className: e, id: e }), n("body").appendChild(F) } constructor(e, t) { var o = this; if (B(this, "viewIndexes", [i.days, i.months, i.years]), B(this, "next", (() => { let { year: e, month: t } = this.parsedViewDate; switch (this.currentView) { case i.days: this.setViewDate(new Date(e, t + 1, 1)); break; case i.months: this.setViewDate(new Date(e + 1, t, 1)); break; case i.years: this.setViewDate(new Date(e + 10, 0, 1)) } })), B(this, "prev", (() => { let { year: e, month: t } = this.parsedViewDate; switch (this.currentView) { case i.days: this.setViewDate(new Date(e, t - 1, 1)); break; case i.months: this.setViewDate(new Date(e - 1, t, 1)); break; case i.years: this.setViewDate(new Date(e - 10, 0, 1)) } })), B(this, "_finishHide", (() => { this.hideAnimation = !1, this._destroyComponents(), this.$container.removeChild(this.$datepicker) })), B(this, "setPosition", (function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1]; if ("function" == typeof (e = e || o.opts.position)) return void (o.customHide = e({ $datepicker: o.$datepicker, $target: o.$el, $pointer: o.$pointer, isViewChange: t, done: o._finishHide })); let i, s, { isMobile: n } = o.opts, r = o.$el.getBoundingClientRect(), a = o.$el.getBoundingClientRect(), l = o.$datepicker.offsetParent, d = o.$el.offsetParent, c = o.$datepicker.getBoundingClientRect(), u = e.split(" "), h = window.scrollY, p = window.scrollX, f = o.opts.offset, m = u[0], g = u[1]; if (n) o.$datepicker.style.cssText = "left: 50%; top: 50%"; else { if (l === d && l !== document.body && (a = { top: o.$el.offsetTop, left: o.$el.offsetLeft, width: r.width, height: o.$el.offsetHeight }, h = 0, p = 0), l !== d && l !== document.body) { let e = l.getBoundingClientRect(); a = { top: r.top - e.top, left: r.left - e.left, width: r.width, height: r.height }, h = 0, p = 0 } switch (m) { case "top": i = a.top - c.height - f; break; case "right": s = a.left + a.width + f; break; case "bottom": i = a.top + a.height + f; break; case "left": s = a.left - c.width - f }switch (g) { case "top": i = a.top; break; case "right": s = a.left + a.width - c.width; break; case "bottom": i = a.top + a.height - c.height; break; case "left": s = a.left; break; case "center": /left|right/.test(m) ? i = a.top + a.height / 2 - c.height / 2 : s = a.left + a.width / 2 - c.width / 2 }o.$datepicker.style.cssText = `left: ${s + p}px; top: ${i + h}px` } })), B(this, "_setInputValue", (() => { let { opts: e, $altField: t, locale: { dateFormat: i } } = this, { altFieldDateFormat: s, altField: n } = e; n && t && (t.value = this._getInputValue(s)), this.$el.value = this._getInputValue(i) })), B(this, "_getInputValue", (e => { let { selectedDates: t, opts: i } = this, { multipleDates: s, multipleDatesSeparator: n } = i; if (!t.length) return ""; let r = "function" == typeof e, o = r ? e(s ? t : t[0]) : t.map((t => this.formatDate(t, e))); return o = r ? o : o.join(n), o })), B(this, "_checkIfDateIsSelected", (function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : i.days, s = !1; return o.selectedDates.some((i => { let n = p(e, i, t); return s = n && i, n })), s })), B(this, "_scheduleCallAfterTransition", (e => { this._cancelScheduledCall(), e && e(!1), this._onTransitionEnd = () => { e && e(!0) }, this.$datepicker.addEventListener("transitionend", this._onTransitionEnd, { once: !0 }) })), B(this, "_cancelScheduledCall", (() => { this.$datepicker.removeEventListener("transitionend", this._onTransitionEnd) })), B(this, "setViewDate", (e => { if (!((e = x(e)) instanceof Date)) return; if (p(e, this.viewDate)) return; let t = this.viewDate; this.viewDate = e; let { onChangeViewDate: s } = this.opts; if (s) { let { month: e, year: t } = this.parsedViewDate; s({ month: e, year: t, decade: this.curDecade }) } this.trigger(i.eventChangeViewDate, e, t) })), B(this, "setFocusDate", (function (e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; (!e || (e = x(e)) instanceof Date) && (o.focusDate = e, o.opts.range && e && o._handleRangeOnFocus(), o.trigger(i.eventChangeFocusDate, e, t)) })), B(this, "setCurrentView", (e => { if (this.viewIndexes.includes(e)) { if (this.currentView = e, this.elIsInput && this.visible && this.setPosition(void 0, !0), this.trigger(i.eventChangeCurrentView, e), !this.views[e]) { let t = this.views[e] = new _({ dp: this, opts: this.opts, type: e }); this.shouldUpdateDOM && this.$content.appendChild(t.$el) } this.opts.onChangeView && this.opts.onChangeView(e) } })), B(this, "_updateLastSelectedDate", (e => { this.lastSelectedDate = e, this.trigger(i.eventChangeLastSelectedDate, e) })), B(this, "destroy", (() => { let { showEvent: e, isMobile: t } = this.opts, i = this.$datepicker.parentNode; i && i.removeChild(this.$datepicker), this.$el.removeEventListener(e, this._onFocus), this.$el.removeEventListener("blur", this._onBlur), window.removeEventListener("resize", this._onResize), t && this._removeMobileAttributes(), this.keyboardNav && this.keyboardNav.destroy(), this.views = null, this.nav = null, this.$datepicker = null, this.opts = null, this.$customContainer = null, this.viewDate = null, this.focusDate = null, this.selectedDates = null, this.rangeDateFrom = null, this.rangeDateTo = null })), B(this, "update", (e => { let t = S({}, this.opts); S(this.opts, e); let { timepicker: s, buttons: n, range: r, selectedDates: o, isMobile: a } = this.opts, l = this.visible || this.treatAsInline; this._createMinMaxDates(), this._limitViewDateByMaxMinDates(), this._handleLocale(), !t.selectedDates && o && this.selectDate(o), e.view && this.setCurrentView(e.view), this._setInputValue(), t.range && !r ? (this.rangeDateTo = !1, this.rangeDateFrom = !1) : !t.range && r && this.selectedDates.length && (this.rangeDateFrom = this.selectedDates[0], this.rangeDateTo = this.selectedDates[1]), t.timepicker && !s ? (l && this.timepicker.destroy(), this.timepicker = !1, this.$timepicker.parentNode.removeChild(this.$timepicker)) : !t.timepicker && s && this._addTimepicker(), !t.buttons && n ? this._addButtons() : t.buttons && !n ? (this.buttons.destroy(), this.$buttons.parentNode.removeChild(this.$buttons)) : l && t.buttons && n && this.buttons.clearHtml().render(), !t.isMobile && a ? (this.treatAsInline || z || this._createMobileOverlay(), this._addMobileAttributes(), this.visible && this._showMobileOverlay()) : t.isMobile && !a && (this._removeMobileAttributes(), this.visible && (z.classList.remove("-active-"), "function" != typeof this.opts.position && this.setPosition())), l && (this.nav.update(), this.views[this.currentView].render(), this.currentView === i.days && this.views[this.currentView].renderDayNames()) })), B(this, "isOtherMonth", (e => { let { month: t } = l(e); return t !== this.parsedViewDate.month })), B(this, "isOtherYear", (e => { let { year: t } = l(e); return t !== this.parsedViewDate.year })), B(this, "isOtherDecade", (e => { let { year: t } = l(e), [i, s] = u(this.viewDate); return t < i || t > s })), B(this, "_onChangeSelectedDate", (e => { let { silent: t } = e; setTimeout((() => { this._setInputValue(), this.opts.onSelect && !t && this._triggerOnSelect() })) })), B(this, "_onChangeFocusedDate", (function (e) { let { viewDateTransition: t } = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (!e) return; let i = !1; t && (i = o.isOtherMonth(e) || o.isOtherYear(e) || o.isOtherDecade(e)), i && o.setViewDate(e) })), B(this, "_onChangeTime", (e => { let { hours: t, minutes: i } = e, s = new Date, { lastSelectedDate: n, opts: { onSelect: r } } = this, o = n; n || (o = s); let a = this.getCell(o, this.currentViewSingular), l = a && a.adpCell; l && l.isDisabled || (o.setHours(t), o.setMinutes(i), n ? (this._setInputValue(), r && this._triggerOnSelect()) : this.selectDate(o)) })), B(this, "_onFocus", (e => { this.visible || this.show() })), B(this, "_onBlur", (e => { this.inFocus || !this.visible || this.opts.isMobile || this.hide() })), B(this, "_onMouseDown", (e => { this.inFocus = !0 })), B(this, "_onMouseUp", (e => { this.inFocus = !1, this.$el.focus() })), B(this, "_onResize", (() => { this.visible && "function" != typeof this.opts.position && this.setPosition() })), B(this, "_onClickOverlay", (() => { this.visible && this.hide() })), B(this, "isWeekend", (e => this.opts.weekends.includes(e))), B(this, "getClampedDate", (e => { let { minDate: t, maxDate: i } = this, s = e; return i && f(e, i) ? s = i : t && m(e, t) && (s = t), s })), this.$el = n(e), !this.$el) return; this.$datepicker = r({ className: "air-datepicker" }), this.opts = S({}, s, t), this.$customContainer = !!this.opts.container && n(this.opts.container), this.$altField = n(this.opts.altField || !1); let { view: a, startDate: d } = this.opts; d || (this.opts.startDate = new Date), "INPUT" === this.$el.nodeName && (this.elIsInput = !0), this.inited = !1, this.visible = !1, this.viewDate = x(this.opts.startDate), this.focusDate = !1, this.initialReadonly = this.$el.getAttribute("readonly"), this.customHide = !1, this.currentView = a, this.selectedDates = [], this.views = {}, this.keys = [], this.rangeDateFrom = "", this.rangeDateTo = "", this.timepickerIsActive = !1, this.treatAsInline = this.opts.inline || !this.elIsInput, this.init() } init() { let { opts: e, treatAsInline: t, opts: { inline: i, isMobile: s, selectedDates: r, keyboardNav: o, onlyTimepicker: a } } = this, l = n("body"); (!j || j && F && !l.contains(F)) && !i && this.elIsInput && !this.$customContainer && q.buildGlobalContainer(q.defaultGlobalContainerId), !s || z || t || this._createMobileOverlay(), this._handleLocale(), this._bindSubEvents(), this._createMinMaxDates(), this._limitViewDateByMaxMinDates(), this.elIsInput && (i || this._bindEvents(), o && !a && (this.keyboardNav = new N({ dp: this, opts: e }))), r && this.selectDate(r, { silent: !0 }), this.opts.visible && !t && this.show(), s && !t && this.$el.setAttribute("readonly", !0), t && this._createComponents() } _createMobileOverlay() { z = r({ className: "air-datepicker-overlay" }), F.appendChild(z) } _createComponents() { let { opts: e, treatAsInline: t, opts: { inline: i, buttons: s, timepicker: n, position: r, classes: o, onlyTimepicker: a, isMobile: l } } = this; this._buildBaseHtml(), this.elIsInput && (i || this._setPositionClasses(r)), !i && this.elIsInput || this.$datepicker.classList.add("-inline-"), o && this.$datepicker.classList.add(...o.split(" ")), a && this.$datepicker.classList.add("-only-timepicker-"), l && !t && this._addMobileAttributes(), this.views[this.currentView] = new _({ dp: this, type: this.currentView, opts: e }), this.nav = new M({ dp: this, opts: e }), n && this._addTimepicker(), s && this._addButtons(), this.$content.appendChild(this.views[this.currentView].$el), this.$nav.appendChild(this.nav.$el) } _destroyComponents() { for (let e in this.views) this.views[e].destroy(); this.views = {}, this.nav.destroy(), this.timepicker && this.timepicker.destroy() } _addMobileAttributes() { z.addEventListener("click", this._onClickOverlay), this.$datepicker.classList.add("-is-mobile-"), this.$el.setAttribute("readonly", !0) } _removeMobileAttributes() { z.removeEventListener("click", this._onClickOverlay), this.$datepicker.classList.remove("-is-mobile-"), this.initialReadonly || "" === this.initialReadonly || this.$el.removeAttribute("readonly") } _createMinMaxDates() { let { minDate: e, maxDate: t } = this.opts; this.minDate = !!e && x(e), this.maxDate = !!t && x(t) } _addTimepicker() { this.$timepicker = r({ className: "air-datepicker--time" }), this.$datepicker.appendChild(this.$timepicker), this.timepicker = new $({ dp: this, opts: this.opts }), this.$timepicker.appendChild(this.timepicker.$el) } _addButtons() { this.$buttons = r({ className: "air-datepicker--buttons" }), this.$datepicker.appendChild(this.$buttons), this.buttons = new P({ dp: this, opts: this.opts }), this.$buttons.appendChild(this.buttons.$el) } _bindSubEvents() { this.on(i.eventChangeSelectedDate, this._onChangeSelectedDate), this.on(i.eventChangeFocusDate, this._onChangeFocusedDate), this.on(i.eventChangeTime, this._onChangeTime) } _buildBaseHtml() { let { inline: e } = this.opts; var t, i; this.elIsInput ? e ? (t = this.$datepicker, (i = this.$el).parentNode.insertBefore(t, i.nextSibling)) : this.$container.appendChild(this.$datepicker) : this.$el.appendChild(this.$datepicker), this.$datepicker.innerHTML = '<i class="air-datepicker--pointer"></i><div class="air-datepicker--navigation"></div><div class="air-datepicker--content"></div>', this.$content = n(".air-datepicker--content", this.$datepicker), this.$pointer = n(".air-datepicker--pointer", this.$datepicker), this.$nav = n(".air-datepicker--navigation", this.$datepicker) } _handleLocale() { let { locale: e, dateFormat: t, firstDay: i, timepicker: s, onlyTimepicker: n, timeFormat: r, dateTimeSeparator: o } = this.opts; var a; this.locale = (a = e, JSON.parse(JSON.stringify(a))), t && (this.locale.dateFormat = t), void 0 !== r && "" !== r && (this.locale.timeFormat = r); let { timeFormat: l } = this.locale; if ("" !== i && (this.locale.firstDay = i), s && "function" != typeof t) { let e = l ? o : ""; this.locale.dateFormat = [this.locale.dateFormat, l || ""].join(e) } n && "function" != typeof t && (this.locale.dateFormat = this.locale.timeFormat) } _setPositionClasses(e) { if ("function" == typeof e) return void this.$datepicker.classList.add("-custom-position-"); let t = (e = e.split(" "))[0], i = `air-datepicker -${t}-${e[1]}- -from-${t}-`; this.$datepicker.classList.add(...i.split(" ")) } _bindEvents() { this.$el.addEventListener(this.opts.showEvent, this._onFocus), this.$el.addEventListener("blur", this._onBlur), this.$datepicker.addEventListener("mousedown", this._onMouseDown), this.$datepicker.addEventListener("mouseup", this._onMouseUp), window.addEventListener("resize", this._onResize) } _limitViewDateByMaxMinDates() { let { viewDate: e, minDate: t, maxDate: i } = this; i && f(e, i) && this.setViewDate(i), t && m(e, t) && this.setViewDate(t) } formatDate() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.viewDate, t = arguments.length > 1 ? arguments[1] : void 0; if (e = x(e), !(e instanceof Date)) return; let i = t, s = this.locale, n = l(e), r = n.dayPeriod, o = u(e), a = q.replacer, d = { T: e.getTime(), m: n.minutes, mm: n.fullMinutes, h: n.hours12, hh: n.fullHours12, H: n.hours, HH: n.fullHours, aa: r, AA: r.toUpperCase(), E: s.daysShort[n.day], EEEE: s.days[n.day], d: n.date, dd: n.fullDate, M: n.month + 1, MM: n.fullMonth, MMM: s.monthsShort[n.month], MMMM: s.months[n.month], yy: n.year.toString().slice(-2), yyyy: n.year, yyyy1: o[0], yyyy2: o[1] }; for (let [e, t] of Object.entries(d)) i = a(i, C(e), t); return i } down(e) { this._handleUpDownActions(e, "down") } up(e) { this._handleUpDownActions(e, "up") } selectDate(e) { let t, s = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, { currentView: n, parsedViewDate: r, selectedDates: o } = this, { updateTime: a } = s, { moveToOtherMonthsOnSelect: l, moveToOtherYearsOnSelect: d, multipleDates: c, range: u, autoClose: h } = this.opts, p = o.length; if (Array.isArray(e)) return e.forEach((e => { this.selectDate(e, s) })), new Promise((e => { setTimeout(e) })); if ((e = x(e)) instanceof Date) { if (n === i.days && e.getMonth() !== r.month && l && (t = new Date(e.getFullYear(), e.getMonth(), 1)), n === i.years && e.getFullYear() !== r.year && d && (t = new Date(e.getFullYear(), 0, 1)), t && this.setViewDate(t), c && !u) { if (p === c) return; this._checkIfDateIsSelected(e) || o.push(e) } else if (u) switch (p) { case 1: o.push(e), this.rangeDateTo || (this.rangeDateTo = e), f(this.rangeDateFrom, this.rangeDateTo) && (this.rangeDateTo = this.rangeDateFrom, this.rangeDateFrom = e), this.selectedDates = [this.rangeDateFrom, this.rangeDateTo]; break; case 2: this.selectedDates = [e], this.rangeDateFrom = e, this.rangeDateTo = ""; break; default: this.selectedDates = [e], this.rangeDateFrom = e } else this.selectedDates = [e]; return this.trigger(i.eventChangeSelectedDate, { action: i.actionSelectDate, silent: null == s ? void 0 : s.silent, date: e, updateTime: a }), this._updateLastSelectedDate(e), h && !this.timepickerIsActive && this.visible && (c || u ? u && 1 === p && this.hide() : this.hide()), new Promise((e => { setTimeout(e) })) } } unselectDate(e) { let t = this.selectedDates, s = this; if ((e = x(e)) instanceof Date) return t.some(((n, r) => { if (p(n, e)) return t.splice(r, 1), s.selectedDates.length ? s._updateLastSelectedDate(s.selectedDates[s.selectedDates.length - 1]) : (s.rangeDateFrom = "", s.rangeDateTo = "", s._updateLastSelectedDate(!1)), this.trigger(i.eventChangeSelectedDate, { action: i.actionUnselectDate, date: e }), !0 })) } replaceDate(e, t) { let s = this.selectedDates.find((t => p(t, e, this.currentView))), n = this.selectedDates.indexOf(s); n < 0 || p(this.selectedDates[n], t, this.currentView) || (this.selectedDates[n] = t, this.trigger(i.eventChangeSelectedDate, { action: i.actionSelectDate, date: t, updateTime: !0 }), this._updateLastSelectedDate(t)) } clear() { let e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return this.selectedDates = [], this.rangeDateFrom = !1, this.rangeDateTo = !1, this.trigger(i.eventChangeSelectedDate, { action: i.actionUnselectDate, silent: e.silent }), new Promise((e => { setTimeout(e) })) } show() { let { onShow: e, isMobile: t } = this.opts; this._cancelScheduledCall(), this.visible || this.hideAnimation || this._createComponents(), this.setPosition(this.opts.position), this.$datepicker.classList.add("-active-"), this.visible = !0, e && this._scheduleCallAfterTransition(e), t && this._showMobileOverlay() } hide() { let { onHide: e, isMobile: t } = this.opts, i = this._hasTransition(); this.visible = !1, this.hideAnimation = !0, this.$datepicker.classList.remove("-active-"), this.customHide && this.customHide(), this.elIsInput && this.$el.blur(), this._scheduleCallAfterTransition((t => { !this.customHide && (t && i || !t && !i) && this._finishHide(), e && e(t) })), t && z.classList.remove("-active-") } _triggerOnSelect() { let e = [], t = [], { selectedDates: i, locale: s, opts: { onSelect: n, multipleDates: r, range: o } } = this, a = r || o, l = "function" == typeof s.dateFormat; i.length && (e = i.map(g), t = l ? r ? s.dateFormat(e) : e.map((e => s.dateFormat(e))) : e.map((e => this.formatDate(e, s.dateFormat)))), n({ date: a ? e : e[0], formattedDate: a ? t : t[0], datepicker: this }) } _handleAlreadySelectedDates(e, t) { let { range: i, toggleSelected: s } = this.opts; i ? s ? this.unselectDate(t) : 2 !== this.selectedDates.length && this.selectDate(t) : s && this.unselectDate(t), s || this._updateLastSelectedDate(e) } _handleUpDownActions(e, t) { if (!((e = x(e || this.focusDate || this.viewDate)) instanceof Date)) return; let i = "up" === t ? this.viewIndex + 1 : this.viewIndex - 1; i > 2 && (i = 2), i < 0 && (i = 0), this.setViewDate(new Date(e.getFullYear(), e.getMonth(), 1)), this.setCurrentView(this.viewIndexes[i]) } _handleRangeOnFocus() { 1 === this.selectedDates.length && (f(this.selectedDates[0], this.focusDate) ? (this.rangeDateTo = this.selectedDates[0], this.rangeDateFrom = this.focusDate) : (this.rangeDateTo = this.focusDate, this.rangeDateFrom = this.selectedDates[0])) } getCell(e) { let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : i.day; if (!((e = x(e)) instanceof Date)) return; let { year: s, month: n, date: r } = l(e), o = `[data-year="${s}"]`, a = `[data-month="${n}"]`, d = { [i.day]: `${o}${a}[data-date="${r}"]`, [i.month]: `${o}${a}`, [i.year]: `${o}` }; return this.views[this.currentView].$el.querySelector(d[t]) } _showMobileOverlay() { z.classList.add("-active-") } _hasTransition() { return window.getComputedStyle(this.$datepicker).getPropertyValue("transition-duration").split(", ").reduce(((e, t) => parseFloat(t) + e), 0) > 0 } get shouldUpdateDOM() { return this.visible || this.treatAsInline } get parsedViewDate() { return l(this.viewDate) } get currentViewSingular() { return this.currentView.slice(0, -1) } get curDecade() { return u(this.viewDate) } get viewIndex() { return this.viewIndexes.indexOf(this.currentView) } get isFinalView() { return this.currentView === i.years } get hasSelectedDates() { return this.selectedDates.length > 0 } get isMinViewReached() { return this.currentView === this.opts.minView || this.currentView === i.days } get $container() { return this.$customContainer || F } static replacer(e, t, i) { return e.replace(t, (function (e, t, s, n) { return t + i + n })) } } var G; return B(q, "defaults", s), B(q, "version", "3.3.5"), B(q, "defaultGlobalContainerId", "air-datepicker-global-container"), G = q.prototype, Object.assign(G, H), t.default }() }, 211: function (e, t) { !function (e) { "use strict"; function t(e) { return i(e) && "function" == typeof e.from } function i(e) { return "object" == typeof e && "function" == typeof e.to } function s(e) { e.parentElement.removeChild(e) } function n(e) { return null != e } function r(e) { e.preventDefault() } function o(e) { return e.filter((function (e) { return !this[e] && (this[e] = !0) }), {}) } function a(e, t) { return Math.round(e / t) * t } function l(e, t) { var i = e.getBoundingClientRect(), s = e.ownerDocument, n = s.documentElement, r = v(s); return /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) && (r.x = 0), t ? i.top + r.y - n.clientTop : i.left + r.x - n.clientLeft } function d(e) { return "number" == typeof e && !isNaN(e) && isFinite(e) } function c(e, t, i) { i > 0 && (f(e, t), setTimeout((function () { m(e, t) }), i)) } function u(e) { return Math.max(Math.min(e, 100), 0) } function h(e) { return Array.isArray(e) ? e : [e] } function p(e) { var t = (e = String(e)).split("."); return t.length > 1 ? t[1].length : 0 } function f(e, t) { e.classList && !/\s/.test(t) ? e.classList.add(t) : e.className += " " + t } function m(e, t) { e.classList && !/\s/.test(t) ? e.classList.remove(t) : e.className = e.className.replace(new RegExp("(^|\\b)" + t.split(" ").join("|") + "(\\b|$)", "gi"), " ") } function g(e, t) { return e.classList ? e.classList.contains(t) : new RegExp("\\b" + t + "\\b").test(e.className) } function v(e) { var t = void 0 !== window.pageXOffset, i = "CSS1Compat" === (e.compatMode || ""); return { x: t ? window.pageXOffset : i ? e.documentElement.scrollLeft : e.body.scrollLeft, y: t ? window.pageYOffset : i ? e.documentElement.scrollTop : e.body.scrollTop } } function y() { return window.navigator.pointerEnabled ? { start: "pointerdown", move: "pointermove", end: "pointerup" } : window.navigator.msPointerEnabled ? { start: "MSPointerDown", move: "MSPointerMove", end: "MSPointerUp" } : { start: "mousedown touchstart", move: "mousemove touchmove", end: "mouseup touchend" } } function b() { var e = !1; try { var t = Object.defineProperty({}, "passive", { get: function () { e = !0 } }); window.addEventListener("test", null, t) } catch (e) { } return e } function w() { return window.CSS && CSS.supports && CSS.supports("touch-action", "none") } function S(e, t) { return 100 / (t - e) } function x(e, t, i) { return 100 * t / (e[i + 1] - e[i]) } function C(e, t) { return x(e, e[0] < 0 ? t + Math.abs(e[0]) : t - e[0], 0) } function E(e, t) { return t * (e[1] - e[0]) / 100 + e[0] } function T(e, t) { for (var i = 1; e >= t[i];)i += 1; return i } function D(e, t, i) { if (i >= e.slice(-1)[0]) return 100; var s = T(i, e), n = e[s - 1], r = e[s], o = t[s - 1], a = t[s]; return o + C([n, r], i) / S(o, a) } function k(e, t, i) { if (i >= 100) return e.slice(-1)[0]; var s = T(i, t), n = e[s - 1], r = e[s], o = t[s - 1]; return E([n, r], (i - o) * S(o, t[s])) } function L(e, t, i, s) { if (100 === s) return s; var n = T(s, e), r = e[n - 1], o = e[n]; return i ? s - r > (o - r) / 2 ? o : r : t[n - 1] ? e[n - 1] + a(s - e[n - 1], t[n - 1]) : s } var _, O; e.PipsMode = void 0, (O = e.PipsMode || (e.PipsMode = {})).Range = "range", O.Steps = "steps", O.Positions = "positions", O.Count = "count", O.Values = "values", e.PipsType = void 0, (_ = e.PipsType || (e.PipsType = {}))[_.None = -1] = "None", _[_.NoValue = 0] = "NoValue", _[_.LargeValue = 1] = "LargeValue", _[_.SmallValue = 2] = "SmallValue"; var M = function () { function e(e, t, i) { var s; this.xPct = [], this.xVal = [], this.xSteps = [], this.xNumSteps = [], this.xHighestCompleteStep = [], this.xSteps = [i || !1], this.xNumSteps = [!1], this.snap = t; var n = []; for (Object.keys(e).forEach((function (t) { n.push([h(e[t]), t]) })), n.sort((function (e, t) { return e[0][0] - t[0][0] })), s = 0; s < n.length; s++)this.handleEntryPoint(n[s][1], n[s][0]); for (this.xNumSteps = this.xSteps.slice(0), s = 0; s < this.xNumSteps.length; s++)this.handleStepPoint(s, this.xNumSteps[s]) } return e.prototype.getDistance = function (e) { for (var t = [], i = 0; i < this.xNumSteps.length - 1; i++)t[i] = x(this.xVal, e, i); return t }, e.prototype.getAbsoluteDistance = function (e, t, i) { var s, n = 0; if (e < this.xPct[this.xPct.length - 1]) for (; e > this.xPct[n + 1];)n++; else e === this.xPct[this.xPct.length - 1] && (n = this.xPct.length - 2); i || e !== this.xPct[n + 1] || n++, null === t && (t = []); var r = 1, o = t[n], a = 0, l = 0, d = 0, c = 0; for (s = i ? (e - this.xPct[n]) / (this.xPct[n + 1] - this.xPct[n]) : (this.xPct[n + 1] - e) / (this.xPct[n + 1] - this.xPct[n]); o > 0;)a = this.xPct[n + 1 + c] - this.xPct[n + c], t[n + c] * r + 100 - 100 * s > 100 ? (l = a * s, r = (o - 100 * s) / t[n + c], s = 1) : (l = t[n + c] * a / 100 * r, r = 0), i ? (d -= l, this.xPct.length + c >= 1 && c--) : (d += l, this.xPct.length - c >= 1 && c++), o = t[n + c] * r; return e + d }, e.prototype.toStepping = function (e) { return e = D(this.xVal, this.xPct, e) }, e.prototype.fromStepping = function (e) { return k(this.xVal, this.xPct, e) }, e.prototype.getStep = function (e) { return e = L(this.xPct, this.xSteps, this.snap, e) }, e.prototype.getDefaultStep = function (e, t, i) { var s = T(e, this.xPct); return (100 === e || t && e === this.xPct[s - 1]) && (s = Math.max(s - 1, 1)), (this.xVal[s] - this.xVal[s - 1]) / i }, e.prototype.getNearbySteps = function (e) { var t = T(e, this.xPct); return { stepBefore: { startValue: this.xVal[t - 2], step: this.xNumSteps[t - 2], highestStep: this.xHighestCompleteStep[t - 2] }, thisStep: { startValue: this.xVal[t - 1], step: this.xNumSteps[t - 1], highestStep: this.xHighestCompleteStep[t - 1] }, stepAfter: { startValue: this.xVal[t], step: this.xNumSteps[t], highestStep: this.xHighestCompleteStep[t] } } }, e.prototype.countStepDecimals = function () { var e = this.xNumSteps.map(p); return Math.max.apply(null, e) }, e.prototype.hasNoSize = function () { return this.xVal[0] === this.xVal[this.xVal.length - 1] }, e.prototype.convert = function (e) { return this.getStep(this.toStepping(e)) }, e.prototype.handleEntryPoint = function (e, t) { var i; if (!d(i = "min" === e ? 0 : "max" === e ? 100 : parseFloat(e)) || !d(t[0])) throw new Error("noUiSlider: 'range' value isn't numeric."); this.xPct.push(i), this.xVal.push(t[0]); var s = Number(t[1]); i ? this.xSteps.push(!isNaN(s) && s) : isNaN(s) || (this.xSteps[0] = s), this.xHighestCompleteStep.push(0) }, e.prototype.handleStepPoint = function (e, t) { if (t) if (this.xVal[e] !== this.xVal[e + 1]) { this.xSteps[e] = x([this.xVal[e], this.xVal[e + 1]], t, 0) / S(this.xPct[e], this.xPct[e + 1]); var i = (this.xVal[e + 1] - this.xVal[e]) / this.xNumSteps[e], s = Math.ceil(Number(i.toFixed(3)) - 1), n = this.xVal[e] + this.xNumSteps[e] * s; this.xHighestCompleteStep[e] = n } else this.xSteps[e] = this.xHighestCompleteStep[e] = this.xVal[e] }, e }(), A = { to: function (e) { return void 0 === e ? "" : e.toFixed(2) }, from: Number }, P = { target: "target", base: "base", origin: "origin", handle: "handle", handleLower: "handle-lower", handleUpper: "handle-upper", touchArea: "touch-area", horizontal: "horizontal", vertical: "vertical", background: "background", connect: "connect", connects: "connects", ltr: "ltr", rtl: "rtl", textDirectionLtr: "txt-dir-ltr", textDirectionRtl: "txt-dir-rtl", draggable: "draggable", drag: "state-drag", tap: "state-tap", active: "active", tooltip: "tooltip", pips: "pips", pipsHorizontal: "pips-horizontal", pipsVertical: "pips-vertical", marker: "marker", markerHorizontal: "marker-horizontal", markerVertical: "marker-vertical", markerNormal: "marker-normal", markerLarge: "marker-large", markerSub: "marker-sub", value: "value", valueHorizontal: "value-horizontal", valueVertical: "value-vertical", valueNormal: "value-normal", valueLarge: "value-large", valueSub: "value-sub" }, I = { tooltips: ".__tooltips", aria: ".__aria" }; function $(e, t) { if (!d(t)) throw new Error("noUiSlider: 'step' is not numeric."); e.singleStep = t } function V(e, t) { if (!d(t)) throw new Error("noUiSlider: 'keyboardPageMultiplier' is not numeric."); e.keyboardPageMultiplier = t } function N(e, t) { if (!d(t)) throw new Error("noUiSlider: 'keyboardMultiplier' is not numeric."); e.keyboardMultiplier = t } function H(e, t) { if (!d(t)) throw new Error("noUiSlider: 'keyboardDefaultStep' is not numeric."); e.keyboardDefaultStep = t } function B(e, t) { if ("object" != typeof t || Array.isArray(t)) throw new Error("noUiSlider: 'range' is not an object."); if (void 0 === t.min || void 0 === t.max) throw new Error("noUiSlider: Missing 'min' or 'max' in 'range'."); e.spectrum = new M(t, e.snap || !1, e.singleStep) } function F(e, t) { if (t = h(t), !Array.isArray(t) || !t.length) throw new Error("noUiSlider: 'start' option is incorrect."); e.handles = t.length, e.start = t } function z(e, t) { if ("boolean" != typeof t) throw new Error("noUiSlider: 'snap' option must be a boolean."); e.snap = t } function j(e, t) { if ("boolean" != typeof t) throw new Error("noUiSlider: 'animate' option must be a boolean."); e.animate = t } function q(e, t) { if ("number" != typeof t) throw new Error("noUiSlider: 'animationDuration' option must be a number."); e.animationDuration = t } function G(e, t) { var i, s = [!1]; if ("lower" === t ? t = [!0, !1] : "upper" === t && (t = [!1, !0]), !0 === t || !1 === t) { for (i = 1; i < e.handles; i++)s.push(t); s.push(!1) } else { if (!Array.isArray(t) || !t.length || t.length !== e.handles + 1) throw new Error("noUiSlider: 'connect' option doesn't match handle count."); s = t } e.connect = s } function R(e, t) { switch (t) { case "horizontal": e.ort = 0; break; case "vertical": e.ort = 1; break; default: throw new Error("noUiSlider: 'orientation' option is invalid.") } } function U(e, t) { if (!d(t)) throw new Error("noUiSlider: 'margin' option must be numeric."); 0 !== t && (e.margin = e.spectrum.getDistance(t)) } function W(e, t) { if (!d(t)) throw new Error("noUiSlider: 'limit' option must be numeric."); if (e.limit = e.spectrum.getDistance(t), !e.limit || e.handles < 2) throw new Error("noUiSlider: 'limit' option is only supported on linear sliders with 2 or more handles.") } function Y(e, t) { var i; if (!d(t) && !Array.isArray(t)) throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers."); if (Array.isArray(t) && 2 !== t.length && !d(t[0]) && !d(t[1])) throw new Error("noUiSlider: 'padding' option must be numeric or array of exactly 2 numbers."); if (0 !== t) { for (Array.isArray(t) || (t = [t, t]), e.padding = [e.spectrum.getDistance(t[0]), e.spectrum.getDistance(t[1])], i = 0; i < e.spectrum.xNumSteps.length - 1; i++)if (e.padding[0][i] < 0 || e.padding[1][i] < 0) throw new Error("noUiSlider: 'padding' option must be a positive number(s)."); var s = t[0] + t[1], n = e.spectrum.xVal[0]; if (s / (e.spectrum.xVal[e.spectrum.xVal.length - 1] - n) > 1) throw new Error("noUiSlider: 'padding' option must not exceed 100% of the range.") } } function X(e, t) { switch (t) { case "ltr": e.dir = 0; break; case "rtl": e.dir = 1; break; default: throw new Error("noUiSlider: 'direction' option was not recognized.") } } function K(e, t) { if ("string" != typeof t) throw new Error("noUiSlider: 'behaviour' must be a string containing options."); var i = t.indexOf("tap") >= 0, s = t.indexOf("drag") >= 0, n = t.indexOf("fixed") >= 0, r = t.indexOf("snap") >= 0, o = t.indexOf("hover") >= 0, a = t.indexOf("unconstrained") >= 0, l = t.indexOf("drag-all") >= 0; if (n) { if (2 !== e.handles) throw new Error("noUiSlider: 'fixed' behaviour must be used with 2 handles"); U(e, e.start[1] - e.start[0]) } if (a && (e.margin || e.limit)) throw new Error("noUiSlider: 'unconstrained' behaviour cannot be used with margin or limit"); e.events = { tap: i || r, drag: s, dragAll: l, fixed: n, snap: r, hover: o, unconstrained: a } } function Z(e, t) { if (!1 !== t) if (!0 === t || i(t)) { e.tooltips = []; for (var s = 0; s < e.handles; s++)e.tooltips.push(t) } else { if ((t = h(t)).length !== e.handles) throw new Error("noUiSlider: must pass a formatter for all handles."); t.forEach((function (e) { if ("boolean" != typeof e && !i(e)) throw new Error("noUiSlider: 'tooltips' must be passed a formatter or 'false'.") })), e.tooltips = t } } function J(e, t) { if (t.length !== e.handles) throw new Error("noUiSlider: must pass a attributes for all handles."); e.handleAttributes = t } function Q(e, t) { if (!i(t)) throw new Error("noUiSlider: 'ariaFormat' requires 'to' method."); e.ariaFormat = t } function ee(e, i) { if (!t(i)) throw new Error("noUiSlider: 'format' requires 'to' and 'from' methods."); e.format = i } function te(e, t) { if ("boolean" != typeof t) throw new Error("noUiSlider: 'keyboardSupport' option must be a boolean."); e.keyboardSupport = t } function ie(e, t) { e.documentElement = t } function se(e, t) { if ("string" != typeof t && !1 !== t) throw new Error("noUiSlider: 'cssPrefix' must be a string or `false`."); e.cssPrefix = t } function ne(e, t) { if ("object" != typeof t) throw new Error("noUiSlider: 'cssClasses' must be an object."); "string" == typeof e.cssPrefix ? (e.cssClasses = {}, Object.keys(t).forEach((function (i) { e.cssClasses[i] = e.cssPrefix + t[i] }))) : e.cssClasses = t } function re(e) { var t = { margin: null, limit: null, padding: null, animate: !0, animationDuration: 300, ariaFormat: A, format: A }, i = { step: { r: !1, t: $ }, keyboardPageMultiplier: { r: !1, t: V }, keyboardMultiplier: { r: !1, t: N }, keyboardDefaultStep: { r: !1, t: H }, start: { r: !0, t: F }, connect: { r: !0, t: G }, direction: { r: !0, t: X }, snap: { r: !1, t: z }, animate: { r: !1, t: j }, animationDuration: { r: !1, t: q }, range: { r: !0, t: B }, orientation: { r: !1, t: R }, margin: { r: !1, t: U }, limit: { r: !1, t: W }, padding: { r: !1, t: Y }, behaviour: { r: !0, t: K }, ariaFormat: { r: !1, t: Q }, format: { r: !1, t: ee }, tooltips: { r: !1, t: Z }, keyboardSupport: { r: !0, t: te }, documentElement: { r: !1, t: ie }, cssPrefix: { r: !0, t: se }, cssClasses: { r: !0, t: ne }, handleAttributes: { r: !1, t: J } }, s = { connect: !1, direction: "ltr", behaviour: "tap", orientation: "horizontal", keyboardSupport: !0, cssPrefix: "noUi-", cssClasses: P, keyboardPageMultiplier: 5, keyboardMultiplier: 1, keyboardDefaultStep: 10 }; e.format && !e.ariaFormat && (e.ariaFormat = e.format), Object.keys(i).forEach((function (r) { if (n(e[r]) || void 0 !== s[r]) i[r].t(t, n(e[r]) ? e[r] : s[r]); else if (i[r].r) throw new Error("noUiSlider: '" + r + "' is required.") })), t.pips = e.pips; var r = document.createElement("div"), o = void 0 !== r.style.msTransform, a = void 0 !== r.style.transform; t.transformRule = a ? "transform" : o ? "msTransform" : "webkitTransform"; var l = [["left", "top"], ["right", "bottom"]]; return t.style = l[t.dir][t.ort], t } function oe(t, i, a) { var d, p, S, x, C, E = y(), T = w() && b(), D = t, k = i.spectrum, L = [], _ = [], O = [], M = 0, A = {}, P = t.ownerDocument, $ = i.documentElement || P.documentElement, V = P.body, N = "rtl" === P.dir || 1 === i.ort ? 0 : 100; function H(e, t) { var i = P.createElement("div"); return t && f(i, t), e.appendChild(i), i } function B(e, t) { var s = H(e, i.cssClasses.origin), n = H(s, i.cssClasses.handle); if (H(n, i.cssClasses.touchArea), n.setAttribute("data-handle", String(t)), i.keyboardSupport && (n.setAttribute("tabindex", "0"), n.addEventListener("keydown", (function (e) { return pe(e, t) }))), void 0 !== i.handleAttributes) { var r = i.handleAttributes[t]; Object.keys(r).forEach((function (e) { n.setAttribute(e, r[e]) })) } return n.setAttribute("role", "slider"), n.setAttribute("aria-orientation", i.ort ? "vertical" : "horizontal"), 0 === t ? f(n, i.cssClasses.handleLower) : t === i.handles - 1 && f(n, i.cssClasses.handleUpper), s } function F(e, t) { return !!t && H(e, i.cssClasses.connect) } function z(e, t) { var s = H(t, i.cssClasses.connects); p = [], (S = []).push(F(s, e[0])); for (var n = 0; n < i.handles; n++)p.push(B(t, n)), O[n] = n, S.push(F(s, e[n + 1])) } function j(e) { return f(e, i.cssClasses.target), 0 === i.dir ? f(e, i.cssClasses.ltr) : f(e, i.cssClasses.rtl), 0 === i.ort ? f(e, i.cssClasses.horizontal) : f(e, i.cssClasses.vertical), f(e, "rtl" === getComputedStyle(e).direction ? i.cssClasses.textDirectionRtl : i.cssClasses.textDirectionLtr), H(e, i.cssClasses.base) } function q(e, t) { return !(!i.tooltips || !i.tooltips[t]) && H(e.firstChild, i.cssClasses.tooltip) } function G() { return D.hasAttribute("disabled") } function R(e) { return p[e].hasAttribute("disabled") } function U() { C && (ve("update" + I.tooltips), C.forEach((function (e) { e && s(e) })), C = null) } function W() { U(), C = p.map(q), me("update" + I.tooltips, (function (e, t, s) { if (C && i.tooltips && !1 !== C[t]) { var n = e[t]; !0 !== i.tooltips[t] && (n = i.tooltips[t].to(s[t])), C[t].innerHTML = n } })) } function Y() { ve("update" + I.aria), me("update" + I.aria, (function (e, t, s, n, r) { O.forEach((function (e) { var t = p[e], n = be(_, e, 0, !0, !0, !0), o = be(_, e, 100, !0, !0, !0), a = r[e], l = String(i.ariaFormat.to(s[e])); n = k.fromStepping(n).toFixed(1), o = k.fromStepping(o).toFixed(1), a = k.fromStepping(a).toFixed(1), t.children[0].setAttribute("aria-valuemin", n), t.children[0].setAttribute("aria-valuemax", o), t.children[0].setAttribute("aria-valuenow", a), t.children[0].setAttribute("aria-valuetext", l) })) })) } function X(t) { if (t.mode === e.PipsMode.Range || t.mode === e.PipsMode.Steps) return k.xVal; if (t.mode === e.PipsMode.Count) { if (t.values < 2) throw new Error("noUiSlider: 'values' (>= 2) required for mode 'count'."); for (var i = t.values - 1, s = 100 / i, n = []; i--;)n[i] = i * s; return n.push(100), K(n, t.stepped) } return t.mode === e.PipsMode.Positions ? K(t.values, t.stepped) : t.mode === e.PipsMode.Values ? t.stepped ? t.values.map((function (e) { return k.fromStepping(k.getStep(k.toStepping(e))) })) : t.values : [] } function K(e, t) { return e.map((function (e) { return k.fromStepping(t ? k.getStep(e) : e) })) } function Z(t) { function i(e, t) { return Number((e + t).toFixed(7)) } var s = X(t), n = {}, r = k.xVal[0], a = k.xVal[k.xVal.length - 1], l = !1, d = !1, c = 0; return (s = o(s.slice().sort((function (e, t) { return e - t }))))[0] !== r && (s.unshift(r), l = !0), s[s.length - 1] !== a && (s.push(a), d = !0), s.forEach((function (r, o) { var a, u, h, p, f, m, g, v, y, b, w = r, S = s[o + 1], x = t.mode === e.PipsMode.Steps; for (x && (a = k.xNumSteps[o]), a || (a = S - w), void 0 === S && (S = w), a = Math.max(a, 1e-7), u = w; u <= S; u = i(u, a)) { for (v = (f = (p = k.toStepping(u)) - c) / (t.density || 1), b = f / (y = Math.round(v)), h = 1; h <= y; h += 1)n[(m = c + h * b).toFixed(5)] = [k.fromStepping(m), 0]; g = s.indexOf(u) > -1 ? e.PipsType.LargeValue : x ? e.PipsType.SmallValue : e.PipsType.NoValue, !o && l && u !== S && (g = 0), u === S && d || (n[p.toFixed(5)] = [u, g]), c = p } })), n } function J(t, s, n) { var r, o, a = P.createElement("div"), l = ((r = {})[e.PipsType.None] = "", r[e.PipsType.NoValue] = i.cssClasses.valueNormal, r[e.PipsType.LargeValue] = i.cssClasses.valueLarge, r[e.PipsType.SmallValue] = i.cssClasses.valueSub, r), d = ((o = {})[e.PipsType.None] = "", o[e.PipsType.NoValue] = i.cssClasses.markerNormal, o[e.PipsType.LargeValue] = i.cssClasses.markerLarge, o[e.PipsType.SmallValue] = i.cssClasses.markerSub, o), c = [i.cssClasses.valueHorizontal, i.cssClasses.valueVertical], u = [i.cssClasses.markerHorizontal, i.cssClasses.markerVertical]; function h(e, t) { var s = t === i.cssClasses.value, n = s ? l : d; return t + " " + (s ? c : u)[i.ort] + " " + n[e] } function p(t, r, o) { if ((o = s ? s(r, o) : o) !== e.PipsType.None) { var l = H(a, !1); l.className = h(o, i.cssClasses.marker), l.style[i.style] = t + "%", o > e.PipsType.NoValue && ((l = H(a, !1)).className = h(o, i.cssClasses.value), l.setAttribute("data-value", String(r)), l.style[i.style] = t + "%", l.innerHTML = String(n.to(r))) } } return f(a, i.cssClasses.pips), f(a, 0 === i.ort ? i.cssClasses.pipsHorizontal : i.cssClasses.pipsVertical), Object.keys(t).forEach((function (e) { p(e, t[e][0], t[e][1]) })), a } function Q() { x && (s(x), x = null) } function ee(e) { Q(); var t = Z(e), i = e.filter, s = e.format || { to: function (e) { return String(Math.round(e)) } }; return x = D.appendChild(J(t, i, s)) } function te() { var e = d.getBoundingClientRect(), t = "offset" + ["Width", "Height"][i.ort]; return 0 === i.ort ? e.width || d[t] : e.height || d[t] } function ie(e, t, s, n) { var r = function (r) { var o = se(r, n.pageOffset, n.target || t); return !!o && !(G() && !n.doNotReject) && !(g(D, i.cssClasses.tap) && !n.doNotReject) && !(e === E.start && void 0 !== o.buttons && o.buttons > 1) && (!n.hover || !o.buttons) && (T || o.preventDefault(), o.calcPoint = o.points[i.ort], void s(o, n)) }, o = []; return e.split(" ").forEach((function (e) { t.addEventListener(e, r, !!T && { passive: !0 }), o.push([e, r]) })), o } function se(e, t, i) { var s = 0 === e.type.indexOf("touch"), n = 0 === e.type.indexOf("mouse"), r = 0 === e.type.indexOf("pointer"), o = 0, a = 0; if (0 === e.type.indexOf("MSPointer") && (r = !0), "mousedown" === e.type && !e.buttons && !e.touches) return !1; if (s) { var l = function (t) { var s = t.target; return s === i || i.contains(s) || e.composed && e.composedPath().shift() === i }; if ("touchstart" === e.type) { var d = Array.prototype.filter.call(e.touches, l); if (d.length > 1) return !1; o = d[0].pageX, a = d[0].pageY } else { var c = Array.prototype.find.call(e.changedTouches, l); if (!c) return !1; o = c.pageX, a = c.pageY } } return t = t || v(P), (n || r) && (o = e.clientX + t.x, a = e.clientY + t.y), e.pageOffset = t, e.points = [o, a], e.cursor = n || r, e } function ne(e) { var t = 100 * (e - l(d, i.ort)) / te(); return t = u(t), i.dir ? 100 - t : t } function oe(e) { var t = 100, i = !1; return p.forEach((function (s, n) { if (!R(n)) { var r = _[n], o = Math.abs(r - e); (o < t || o <= t && e > r || 100 === o && 100 === t) && (i = n, t = o) } })), i } function ae(e, t) { "mouseout" === e.type && "HTML" === e.target.nodeName && null === e.relatedTarget && de(e, t) } function le(e, t) { if (-1 === navigator.appVersion.indexOf("MSIE 9") && 0 === e.buttons && 0 !== t.buttonsProperty) return de(e, t); var s = (i.dir ? -1 : 1) * (e.calcPoint - t.startCalcPoint); Se(s > 0, 100 * s / t.baseSize, t.locations, t.handleNumbers, t.connect) } function de(e, t) { t.handle && (m(t.handle, i.cssClasses.active), M -= 1), t.listeners.forEach((function (e) { $.removeEventListener(e[0], e[1]) })), 0 === M && (m(D, i.cssClasses.drag), Ee(), e.cursor && (V.style.cursor = "", V.removeEventListener("selectstart", r))), t.handleNumbers.forEach((function (e) { ye("change", e), ye("set", e), ye("end", e) })) } function ce(e, t) { if (!t.handleNumbers.some(R)) { var s; 1 === t.handleNumbers.length && (s = p[t.handleNumbers[0]].children[0], M += 1, f(s, i.cssClasses.active)), e.stopPropagation(); var n = [], o = ie(E.move, $, le, { target: e.target, handle: s, connect: t.connect, listeners: n, startCalcPoint: e.calcPoint, baseSize: te(), pageOffset: e.pageOffset, handleNumbers: t.handleNumbers, buttonsProperty: e.buttons, locations: _.slice() }), a = ie(E.end, $, de, { target: e.target, handle: s, listeners: n, doNotReject: !0, handleNumbers: t.handleNumbers }), l = ie("mouseout", $, ae, { target: e.target, handle: s, listeners: n, doNotReject: !0, handleNumbers: t.handleNumbers }); n.push.apply(n, o.concat(a, l)), e.cursor && (V.style.cursor = getComputedStyle(e.target).cursor, p.length > 1 && f(D, i.cssClasses.drag), V.addEventListener("selectstart", r, !1)), t.handleNumbers.forEach((function (e) { ye("start", e) })) } } function ue(e) { e.stopPropagation(); var t = ne(e.calcPoint), s = oe(t); !1 !== s && (i.events.snap || c(D, i.cssClasses.tap, i.animationDuration), Te(s, t, !0, !0), Ee(), ye("slide", s, !0), ye("update", s, !0), i.events.snap ? ce(e, { handleNumbers: [s] }) : (ye("change", s, !0), ye("set", s, !0))) } function he(e) { var t = ne(e.calcPoint), i = k.getStep(t), s = k.fromStepping(i); Object.keys(A).forEach((function (e) { "hover" === e.split(".")[0] && A[e].forEach((function (e) { e.call(Ne, s) })) })) } function pe(e, t) { if (G() || R(t)) return !1; var s = ["Left", "Right"], n = ["Down", "Up"], r = ["PageDown", "PageUp"], o = ["Home", "End"]; i.dir && !i.ort ? s.reverse() : i.ort && !i.dir && (n.reverse(), r.reverse()); var a, l = e.key.replace("Arrow", ""), d = l === r[0], c = l === r[1], u = l === n[0] || l === s[0] || d, h = l === n[1] || l === s[1] || c, p = l === o[0], f = l === o[1]; if (!(u || h || p || f)) return !0; if (e.preventDefault(), h || u) { var m = u ? 0 : 1, g = Pe(t)[m]; if (null === g) return !1; !1 === g && (g = k.getDefaultStep(_[t], u, i.keyboardDefaultStep)), g *= c || d ? i.keyboardPageMultiplier : i.keyboardMultiplier, g = Math.max(g, 1e-7), g *= u ? -1 : 1, a = L[t] + g } else a = f ? i.spectrum.xVal[i.spectrum.xVal.length - 1] : i.spectrum.xVal[0]; return Te(t, k.toStepping(a), !0, !0), ye("slide", t), ye("update", t), ye("change", t), ye("set", t), !1 } function fe(e) { e.fixed || p.forEach((function (e, t) { ie(E.start, e.children[0], ce, { handleNumbers: [t] }) })), e.tap && ie(E.start, d, ue, {}), e.hover && ie(E.move, d, he, { hover: !0 }), e.drag && S.forEach((function (t, s) { if (!1 !== t && 0 !== s && s !== S.length - 1) { var n = p[s - 1], r = p[s], o = [t], a = [n, r], l = [s - 1, s]; f(t, i.cssClasses.draggable), e.fixed && (o.push(n.children[0]), o.push(r.children[0])), e.dragAll && (a = p, l = O), o.forEach((function (e) { ie(E.start, e, ce, { handles: a, handleNumbers: l, connect: t }) })) } })) } function me(e, t) { A[e] = A[e] || [], A[e].push(t), "update" === e.split(".")[0] && p.forEach((function (e, t) { ye("update", t) })) } function ge(e) { return e === I.aria || e === I.tooltips } function ve(e) { var t = e && e.split(".")[0], i = t ? e.substring(t.length) : e; Object.keys(A).forEach((function (e) { var s = e.split(".")[0], n = e.substring(s.length); t && t !== s || i && i !== n || ge(n) && i !== n || delete A[e] })) } function ye(e, t, s) { Object.keys(A).forEach((function (n) { var r = n.split(".")[0]; e === r && A[n].forEach((function (e) { e.call(Ne, L.map(i.format.to), t, L.slice(), s || !1, _.slice(), Ne) })) })) } function be(e, t, s, n, r, o) { var a; return p.length > 1 && !i.events.unconstrained && (n && t > 0 && (a = k.getAbsoluteDistance(e[t - 1], i.margin, !1), s = Math.max(s, a)), r && t < p.length - 1 && (a = k.getAbsoluteDistance(e[t + 1], i.margin, !0), s = Math.min(s, a))), p.length > 1 && i.limit && (n && t > 0 && (a = k.getAbsoluteDistance(e[t - 1], i.limit, !1), s = Math.min(s, a)), r && t < p.length - 1 && (a = k.getAbsoluteDistance(e[t + 1], i.limit, !0), s = Math.max(s, a))), i.padding && (0 === t && (a = k.getAbsoluteDistance(0, i.padding[0], !1), s = Math.max(s, a)), t === p.length - 1 && (a = k.getAbsoluteDistance(100, i.padding[1], !0), s = Math.min(s, a))), !((s = u(s = k.getStep(s))) === e[t] && !o) && s } function we(e, t) { var s = i.ort; return (s ? t : e) + ", " + (s ? e : t) } function Se(e, t, i, s, n) { var r = i.slice(), o = s[0], a = [!e, e], l = [e, !e]; s = s.slice(), e && s.reverse(), s.length > 1 ? s.forEach((function (e, i) { var s = be(r, e, r[e] + t, a[i], l[i], !1); !1 === s ? t = 0 : (t = s - r[e], r[e] = s) })) : a = l = [!0]; var d = !1; s.forEach((function (e, s) { d = Te(e, i[e] + t, a[s], l[s]) || d })), d && (s.forEach((function (e) { ye("update", e), ye("slide", e) })), null != n && ye("drag", o)) } function xe(e, t) { return i.dir ? 100 - e - t : e } function Ce(e, t) { _[e] = t, L[e] = k.fromStepping(t); var s = "translate(" + we(xe(t, 0) - N + "%", "0") + ")"; p[e].style[i.transformRule] = s, De(e), De(e + 1) } function Ee() { O.forEach((function (e) { var t = _[e] > 50 ? -1 : 1, i = 3 + (p.length + t * e); p[e].style.zIndex = String(i) })) } function Te(e, t, i, s, n) { return n || (t = be(_, e, t, i, s, !1)), !1 !== t && (Ce(e, t), !0) } function De(e) { if (S[e]) { var t = 0, s = 100; 0 !== e && (t = _[e - 1]), e !== S.length - 1 && (s = _[e]); var n = s - t, r = "translate(" + we(xe(t, n) + "%", "0") + ")", o = "scale(" + we(n / 100, "1") + ")"; S[e].style[i.transformRule] = r + " " + o } } function ke(e, t) { return null === e || !1 === e || void 0 === e ? _[t] : ("number" == typeof e && (e = String(e)), !1 !== (e = i.format.from(e)) && (e = k.toStepping(e)), !1 === e || isNaN(e) ? _[t] : e) } function Le(e, t, s) { var n = h(e), r = void 0 === _[0]; t = void 0 === t || t, i.animate && !r && c(D, i.cssClasses.tap, i.animationDuration), O.forEach((function (e) { Te(e, ke(n[e], e), !0, !1, s) })); var o = 1 === O.length ? 0 : 1; if (r && k.hasNoSize() && (s = !0, _[0] = 0, O.length > 1)) { var a = 100 / (O.length - 1); O.forEach((function (e) { _[e] = e * a })) } for (; o < O.length; ++o)O.forEach((function (e) { Te(e, _[e], !0, !0, s) })); Ee(), O.forEach((function (e) { ye("update", e), null !== n[e] && t && ye("set", e) })) } function _e(e) { Le(i.start, e) } function Oe(e, t, i, s) { if (!((e = Number(e)) >= 0 && e < O.length)) throw new Error("noUiSlider: invalid handle number, got: " + e); Te(e, ke(t, e), !0, !0, s), ye("update", e), i && ye("set", e) } function Me(e) { if (void 0 === e && (e = !1), e) return 1 === L.length ? L[0] : L.slice(0); var t = L.map(i.format.to); return 1 === t.length ? t[0] : t } function Ae() { for (ve(I.aria), ve(I.tooltips), Object.keys(i.cssClasses).forEach((function (e) { m(D, i.cssClasses[e]) })); D.firstChild;)D.removeChild(D.firstChild); delete D.noUiSlider } function Pe(e) { var t = _[e], s = k.getNearbySteps(t), n = L[e], r = s.thisStep.step, o = null; if (i.snap) return [n - s.stepBefore.startValue || null, s.stepAfter.startValue - n || null]; !1 !== r && n + r > s.stepAfter.startValue && (r = s.stepAfter.startValue - n), o = n > s.thisStep.startValue ? s.thisStep.step : !1 !== s.stepBefore.step && n - s.stepBefore.highestStep, 100 === t ? r = null : 0 === t && (o = null); var a = k.countStepDecimals(); return null !== r && !1 !== r && (r = Number(r.toFixed(a))), null !== o && !1 !== o && (o = Number(o.toFixed(a))), [o, r] } function Ie() { return O.map(Pe) } function $e(e, t) { var s = Me(), r = ["margin", "limit", "padding", "range", "animate", "snap", "step", "format", "pips", "tooltips"]; r.forEach((function (t) { void 0 !== e[t] && (a[t] = e[t]) })); var o = re(a); r.forEach((function (t) { void 0 !== e[t] && (i[t] = o[t]) })), k = o.spectrum, i.margin = o.margin, i.limit = o.limit, i.padding = o.padding, i.pips ? ee(i.pips) : Q(), i.tooltips ? W() : U(), _ = [], Le(n(e.start) ? e.start : s, t) } function Ve() { d = j(D), z(i.connect, d), fe(i.events), Le(i.start), i.pips && ee(i.pips), i.tooltips && W(), Y() } Ve(); var Ne = { destroy: Ae, steps: Ie, on: me, off: ve, get: Me, set: Le, setHandle: Oe, reset: _e, __moveHandles: function (e, t, i) { Se(e, t, _, i) }, options: a, updateOptions: $e, target: D, removePips: Q, removeTooltips: U, getPositions: function () { return _.slice() }, getTooltips: function () { return C }, getOrigins: function () { return p }, pips: ee }; return Ne } function ae(e, t) { if (!e || !e.nodeName) throw new Error("noUiSlider: create requires a single element, got: " + e); if (e.noUiSlider) throw new Error("noUiSlider: Slider was already initialized."); var i = oe(e, re(t), t); return e.noUiSlider = i, i } var le = { __spectrum: M, cssClasses: P, create: ae }; e.create = ae, e.cssClasses = P, e.default = le, Object.defineProperty(e, "__esModule", { value: !0 }) }(t) } }, t = {}; function i(s) { var n = t[s]; if (void 0 !== n) return n.exports; var r = t[s] = { exports: {} }; return e[s].call(r.exports, r, r.exports, i), r.exports } i.n = e => { var t = e && e.__esModule ? () => e.default : () => e; return i.d(t, { a: t }), t }, i.d = (e, t) => { for (var s in t) i.o(t, s) && !i.o(e, s) && Object.defineProperty(e, s, { enumerable: !0, get: t[s] }) }, i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), (() => { "use strict"; class e { constructor(e) { this.isOpen = !1, this.targetOpen = { selector: !1, element: !1 }, this.previousOpen = { selector: !1, element: !1 }, this.lastClosed = { selector: !1, element: !1 }, this._dataValue = !1, this.hash = !1, this._reopen = !1, this._selectorOpen = !1, this.lastFocusEl = !1, this._focusEl = ["a[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "button:not([disabled]):not([aria-hidden])", "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "area[href]", "iframe", "object", "embed", "[contenteditable]", '[tabindex]:not([tabindex^="-"])'], this.options = Object.assign({ logging: !1, init: !0, attributeOpenButton: "data-popup", attributeCloseButton: "data-close", fixElementSelector: "[data-lp]", youtubeAttribute: "data-youtube", setAutoplayYoutube: !0, classes: { popup: "popup", popupContent: "popup__content", popupActive: "popup_show", bodyActive: "popup-show", popupVideo: "popup__video" }, focusCatch: !0, closeEsc: !0, bodyLock: !0, bodyLockDelay: 500, hashSettings: { location: !0, goHash: !0 }, on: { beforeOpen: function () { }, afterOpen: function () { }, beforeClose: function () { }, afterClose: function () { } } }, e), e.init && this.initPopups() } initPopups() { this.popupLogging("Проснулся"), this.eventsPopup() } eventsPopup() { document.addEventListener("click", function (e) { const t = e.target.closest(`[${this.options.attributeOpenButton}]`); if (t) return e.preventDefault(), this._dataValue = t.getAttribute(this.options.attributeOpenButton) ? t.getAttribute(this.options.attributeOpenButton) : "error", "error" !== this._dataValue ? (this.isOpen || (this.lastFocusEl = t), this.targetOpen.selector = `${this._dataValue}`, this._selectorOpen = !0, void this.open()) : void this.popupLogging(`Ой ой, не заполнен атрибут у ${t.classList}`); return e.target.closest(`[${this.options.attributeCloseButton}]`) || !e.target.closest(`.${this.options.classes.popupContent}`) && this.isOpen ? (e.preventDefault(), void this.close()) : void 0 }.bind(this)), document.addEventListener("keydown", function (e) { if (this.options.closeEsc && 27 == e.which && "Escape" === e.code && this.isOpen) return e.preventDefault(), void this.close(); this.options.focusCatch && 9 == e.which && this.isOpen && this._focusCatch(e) }.bind(this)), this.options.hashSettings.goHash && (window.addEventListener("hashchange", function () { window.location.hash ? this._openToHash() : this.close(this.targetOpen.selector) }.bind(this)), window.addEventListener("load", function () { window.location.hash && this._openToHash() }.bind(this))) } open(e) { if (e && "string" == typeof e && "" !== e.trim() && (this.targetOpen.selector = e, this._selectorOpen = !0), this.isOpen && (this._reopen = !0, this.close()), this._selectorOpen || (this.targetOpen.selector = this.lastClosed.selector), this._reopen || (this.previousActiveElement = document.activeElement), this.targetOpen.element = document.querySelector(this.targetOpen.selector), this.targetOpen.element) { if (this.targetOpen.element.hasAttribute(this.options.youtubeAttribute)) { const e = `https://www.youtube.com/embed/${this.targetOpen.element.getAttribute(this.options.youtubeAttribute)}?rel=0&showinfo=0&autoplay=1`, t = document.createElement("iframe"); t.setAttribute("allowfullscreen", ""); const i = this.options.setAutoplayYoutube ? "autoplay;" : ""; t.setAttribute("allow", `${i}; encrypted-media`), t.setAttribute("src", e), this.targetOpen.element.querySelector(`.${this.options.classes.popupVideo}`) && this.targetOpen.element.querySelector(`.${this.options.classes.popupVideo}`).appendChild(t) } this.options.hashSettings.location && (this._getHash(), this._setHash()), this.options.on.beforeOpen(this), this.targetOpen.element.classList.add(this.options.classes.popupActive), document.body.classList.add(this.options.classes.bodyActive), this._reopen ? this._reopen = !1 : l(), this.targetOpen.element.setAttribute("aria-hidden", "false"), this.previousOpen.selector = this.targetOpen.selector, this.previousOpen.element = this.targetOpen.element, this._selectorOpen = !1, this.isOpen = !0, setTimeout((() => { this._focusTrap() }), 50), document.dispatchEvent(new CustomEvent("afterPopupOpen", { detail: { popup: this } })), this.popupLogging("Открыл попап") } else this.popupLogging("Ой ой, такого попапа нет. Проверьте корректность ввода. ") } close(e) { e && "string" == typeof e && "" !== e.trim() && (this.previousOpen.selector = e), this.isOpen && a && (this.options.on.beforeClose(this), this.targetOpen.element.hasAttribute(this.options.youtubeAttribute) && this.targetOpen.element.querySelector(`.${this.options.classes.popupVideo}`) && (this.targetOpen.element.querySelector(`.${this.options.classes.popupVideo}`).innerHTML = ""), this.previousOpen.element.classList.remove(this.options.classes.popupActive), this.previousOpen.element.setAttribute("aria-hidden", "true"), this._reopen || (document.body.classList.remove(this.options.classes.bodyActive), l(), this.isOpen = !1), this._removeHash(), this._selectorOpen && (this.lastClosed.selector = this.previousOpen.selector, this.lastClosed.element = this.previousOpen.element), this.options.on.afterClose(this), setTimeout((() => { this._focusTrap() }), 50), this.popupLogging("Закрыл попап")) } _getHash() { this.options.hashSettings.location && (this.hash = this.targetOpen.selector.includes("#") ? this.targetOpen.selector : this.targetOpen.selector.replace(".", "#")) } _openToHash() { let e = document.querySelector(`.${window.location.hash.replace("#", "")}`) ? `.${window.location.hash.replace("#", "")}` : document.querySelector(`${window.location.hash}`) ? `${window.location.hash}` : null; document.querySelector(`[${this.options.attributeOpenButton}="${e}"]`) && e && this.open(e) } _setHash() { history.pushState("", "", this.hash) } _removeHash() { history.pushState("", "", window.location.href.split("#")[0]) } _focusCatch(e) { const t = this.targetOpen.element.querySelectorAll(this._focusEl), i = Array.prototype.slice.call(t), s = i.indexOf(document.activeElement); e.shiftKey && 0 === s && (i[i.length - 1].focus(), e.preventDefault()), e.shiftKey || s !== i.length - 1 || (i[0].focus(), e.preventDefault()) } _focusTrap() { const e = this.previousOpen.element.querySelectorAll(this._focusEl); !this.isOpen && this.lastFocusEl ? this.lastFocusEl.focus() : e[0].focus() } popupLogging(e) { this.options.logging && console.log(`[Попапос]: ${e}`) } } let t = function (e) { let t = document.cookie.match(new RegExp("(?:^|; )" + e.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, "\\$1") + "=([^;]*)")); return t ? decodeURIComponent(t[1]) : void 0 }("cookiecook"), s = document.getElementsByClassName("cookie_notice")[0]; "no" != t && (s.style.display = "block", document.getElementById("cookie_close").addEventListener("click", (function () { s.style.display = "none"; let e = new Date; e.setDate(e.getDate() + 1), document.cookie = "cookiecook=no; path=/; expires=" + e.toUTCString() }))); let n = { Android: function () { return navigator.userAgent.match(/Android/i) }, BlackBerry: function () { return navigator.userAgent.match(/BlackBerry/i) }, iOS: function () { return navigator.userAgent.match(/iPhone|iPad|iPod/i) }, Opera: function () { return navigator.userAgent.match(/Opera Mini/i) }, Windows: function () { return navigator.userAgent.match(/IEMobile/i) }, any: function () { return n.Android() || n.BlackBerry() || n.iOS() || n.Opera() || n.Windows() } }; let r = (e, t = 500, i = 0) => { e.classList.contains("_slide") || (e.classList.add("_slide"), e.style.transitionProperty = "height, margin, padding", e.style.transitionDuration = t + "ms", e.style.height = `${e.offsetHeight}px`, e.offsetHeight, e.style.overflow = "hidden", e.style.height = i ? `${i}px` : "0px", e.style.paddingTop = 0, e.style.paddingBottom = 0, e.style.marginTop = 0, e.style.marginBottom = 0, window.setTimeout((() => { e.hidden = !i, !i && e.style.removeProperty("height"), e.style.removeProperty("padding-top"), e.style.removeProperty("padding-bottom"), e.style.removeProperty("margin-top"), e.style.removeProperty("margin-bottom"), !i && e.style.removeProperty("overflow"), e.style.removeProperty("transition-duration"), e.style.removeProperty("transition-property"), e.classList.remove("_slide") }), t)) }, o = (e, t = 500, i = 0) => { if (!e.classList.contains("_slide")) { e.classList.add("_slide"), e.hidden = !e.hidden && null, i && e.style.removeProperty("height"); let s = e.offsetHeight; e.style.overflow = "hidden", e.style.height = i ? `${i}px` : "0px", e.style.paddingTop = 0, e.style.paddingBottom = 0, e.style.marginTop = 0, e.style.marginBottom = 0, e.offsetHeight, e.style.transitionProperty = "height, margin, padding", e.style.transitionDuration = t + "ms", e.style.height = s + "px", e.style.removeProperty("padding-top"), e.style.removeProperty("padding-bottom"), e.style.removeProperty("margin-top"), e.style.removeProperty("margin-bottom"), window.setTimeout((() => { e.style.removeProperty("height"), e.style.removeProperty("overflow"), e.style.removeProperty("transition-duration"), e.style.removeProperty("transition-property"), e.classList.remove("_slide") }), t) } }, a = !0, l = (e = 500) => { document.documentElement.classList.contains("lock") ? d(e) : c(e) }, d = (e = 500) => { let t = document.querySelector("body"); if (a) { let i = document.querySelectorAll("[data-lp]"); setTimeout((() => { for (let e = 0; e < i.length; e++) { i[e].style.paddingRight = "0px" } t.style.paddingRight = "0px", document.documentElement.classList.remove("lock") }), e), a = !1, setTimeout((function () { a = !0 }), e) } }, c = (e = 500) => { let t = document.querySelector("body"); if (a) { let i = document.querySelectorAll("[data-lp]"); for (let e = 0; e < i.length; e++) { i[e].style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px" } t.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px", document.documentElement.classList.add("lock"), a = !1, setTimeout((function () { a = !0 }), e) } }; const u = document.querySelector(".filter-mob-block__btn_fl"), h = document.querySelector(".filter-mob-block__btn_sl"), p = document.querySelector(".filters-mob-menu__header-close"), f = document.querySelector(".filters-mob-menu"), m = document.querySelector(".select-mob-menu"), g = document.querySelector(".filter-controll-mob-fixed"), v = document.querySelector(".select-mob-menu__list"); u && u.addEventListener("click", (function () { f.classList.add("_active"), g.classList.add("_active"), l() })), p && p.addEventListener("click", (function () { f.classList.remove("_active"), g.classList.remove("_active"), l() })), h && h.addEventListener("click", (function () { m.classList.add("_active"), C(), l() })), v && v.addEventListener("click", (function () { m.classList.remove("_active"), l(), C() })); const y = document.getElementById("prodPrew"), b = document.getElementById("prodPrewCl"), w = document.querySelector(".catalog-entity-mob__card"); w && w.addEventListener("click", (function () { y.classList.add("_active"), l() })), b && b.addEventListener("click", (function () { y.classList.remove("_active"), l() })); const S = document.getElementById("multicorzineMobFxed"), x = document.getElementById("MobfixedMenuFt"); function C() { document.querySelector("body").classList.toggle("_before") } x && x.addEventListener("click", (function () { S.classList.toggle("_active"), l(), C() })); const E = (t = !1, i = !0) => new e({ logging: t, init: i }); let T = (e, t = !1, i = 500, s = 0) => { const n = document.querySelector(e); if (n) { let e = "", r = 0; t && (e = "header.header", r = document.querySelector(e).offsetHeight); let o = { speedAsDuration: !0, speed: i, header: e, offset: s, easing: "easeOutQuad" }; document.documentElement.classList.contains("menu-open") && (d(), document.documentElement.classList.remove("menu-open")), "undefined" != typeof SmoothScroll ? (new SmoothScroll).animateScroll(n, "", o) : window.scrollTo({ top: r ? n.getBoundingClientRect().top - r : n.getBoundingClientRect().top, behavior: "smooth" }) } else console.log(`[gotoBlock]: Такого блока нет на странице: ${e}`) }; class D { constructor(e, t = null) { if (this.config = Object.assign({ init: !0, logging: !1 }, e), this.masks = { phone: { ua: "+38(999)999-99-99" } }, this.config.init) { const e = t ? document.querySelectorAll(t) : document.querySelectorAll("[data-mask]"); e.length ? (this.initMasks(e), this.setLogging(`Проснулся, построил масок: (${e.length})`), document.querySelector("._mask-init") && this.setActions()) : this.setLogging("Нет ни одной маски. Сплю...zzZZZzZZz...") } } setActions() { document.addEventListener("input", this.maskActions.bind(this)), document.addEventListener("focusin", this.maskActions.bind(this)), document.addEventListener("focusout", this.maskActions.bind(this)), document.addEventListener("keydown", this.maskActions.bind(this)) } initMasks(e) { e.forEach((e => { this.initMask(e) })) } initMask(e) { const t = this.getMask(e); t && this.setMask(e, t) } getMask(e) { const t = e.dataset.mask ? e.dataset.mask.split(",") : "", i = t[0] ? t[0] : null; if (!i) return void this.setLogging(`Маска для ${e} не заполнена!`); let s = t[1] ? t[1] : null; return "phone" === i && (!s && (s = "ua"), this.masks[i][s] && (s = this.masks[i][s])), s } setMask(e, t) { t = t.replace(/9/g, "_"), e.classList.add("_mask-init"), e.value = t } maskActions(e) { const t = e.target; if (t.closest("._mask-init")) { const i = t, s = (i.value, this.getMask(i)); console.log(i.selectionStart), i.selectionStart > s.length && e.preventDefault() } } setLogging(e) { this.config.logging && console.log(`[Elton Mask]: ${e}`) } } [].forEach.call(document.querySelectorAll(".tel"), (function (e) { var t; function i(e) { e.keyCode && (t = e.keyCode), this.selectionStart < 3 && e.preventDefault(); var i = "+7 (___) ___ ____", s = 0, n = i.replace(/\D/g, ""), r = this.value.replace(/\D/g, ""), o = i.replace(/[_\d]/g, (function (e) { return s < r.length ? r.charAt(s++) || n.charAt(s) : e })); -1 != (s = o.indexOf("_")) && (s < 5 && (s = 3), o = o.slice(0, s)); var a = i.substr(0, this.value.length).replace(/_+/g, (function (e) { return "\\d{1," + e.length + "}" })).replace(/[+()]/g, "\\$&"); (!(a = new RegExp("^" + a + "$")).test(this.value) || this.value.length < 5 || t > 47 && t < 58) && (this.value = o), "blur" == e.type && this.value.length < 5 && (this.value = "") } e.addEventListener("input", i, !1), e.addEventListener("focus", i, !1), e.addEventListener("blur", i, !1), e.addEventListener("keydown", i, !1) })); var k = i(545); const L = i.n(k)(), _ = E(), O = { inputMaskModule: null, selectModule: null }; let M = { getErrors(e) { let t = 0, i = e.querySelectorAll("*[data-required]"); return i.length && i.forEach((e => { null === e.offsetParent && "SELECT" !== e.tagName || e.disabled || (t += this.validateInput(e)) })), t }, validateInput(e) { let t = 0; return "email" === e.dataset.required ? (e.value = e.value.replace(" ", ""), this.emailTest(e) ? (this.addError(e), t++) : this.removeError(e)) : ("checkbox" !== e.type || e.checked) && e.value ? this.removeError(e) : (this.addError(e), t++), t }, addError(e) { e.classList.add("_form-error"), e.parentElement.classList.add("_form-error"); let t = e.parentElement.querySelector(".form__error"); t && e.parentElement.removeChild(t), e.dataset.error && e.parentElement.insertAdjacentHTML("beforeend", `<div class="form__error">${e.dataset.error}</div>`) }, removeError(e) { e.classList.remove("_form-error"), e.parentElement.classList.remove("_form-error"), e.parentElement.querySelector(".form__error") && e.parentElement.removeChild(e.parentElement.querySelector(".form__error")) }, formClean(e) { e.reset(), setTimeout((() => { let t = e.querySelectorAll("input,textarea"); for (let e = 0; e < t.length; e++) { const i = t[e]; i.parentElement.classList.remove("_form-focus"), i.classList.remove("_form-focus"), M.removeError(i), i.value = i.dataset.placeholder } let i = e.querySelectorAll(".checkbox__input"); if (i.length > 0) for (let e = 0; e < i.length; e++) { i[e].checked = !1 } if (O.selectModule) { let t = e.querySelectorAll(".select"); if (t.length) for (let e = 0; e < t.length; e++) { const i = t[e].querySelector("select"); O.selectModule.selectBuild(i) } } }), 0) }, emailTest: e => !/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,8})+$/.test(e.value) }; new L(".calendar", { inline: !0, range: !0, multipleDatesSeparator: " - " }), new L(".calendar-two", { inline: !0, range: !0, multipleDatesSeparator: " - " }), new L(".calendar-three", { inline: !0, range: !0, multipleDatesSeparator: " - " }); var A = i(211); function P(e) { if (null == e) return window; if ("[object Window]" !== e.toString()) { var t = e.ownerDocument; return t && t.defaultView || window } return e } function I(e) { return e instanceof P(e).Element || e instanceof Element } function $(e) { return e instanceof P(e).HTMLElement || e instanceof HTMLElement } function V(e) { return "undefined" != typeof ShadowRoot && (e instanceof P(e).ShadowRoot || e instanceof ShadowRoot) } !function () { const e = document.querySelector("#range"); if (e) { e.getAttribute("data-from"), e.getAttribute("data-to"); A.create(e, { start: 0, connect: [!0, !1], range: { min: [0], max: [2e5] } }) } }(); var N = Math.max, H = Math.min, B = Math.round; function F(e, t) { void 0 === t && (t = !1); var i = e.getBoundingClientRect(), s = 1, n = 1; if ($(e) && t) { var r = e.offsetHeight, o = e.offsetWidth; o > 0 && (s = B(i.width) / o || 1), r > 0 && (n = B(i.height) / r || 1) } return { width: i.width / s, height: i.height / n, top: i.top / n, right: i.right / s, bottom: i.bottom / n, left: i.left / s, x: i.left / s, y: i.top / n } } function z(e) { var t = P(e); return { scrollLeft: t.pageXOffset, scrollTop: t.pageYOffset } } function j(e) { return e ? (e.nodeName || "").toLowerCase() : null } function q(e) { return ((I(e) ? e.ownerDocument : e.document) || window.document).documentElement } function G(e) { return F(q(e)).left + z(e).scrollLeft } function R(e) { return P(e).getComputedStyle(e) } function U(e) { var t = R(e), i = t.overflow, s = t.overflowX, n = t.overflowY; return /auto|scroll|overlay|hidden/.test(i + n + s) } function W(e, t, i) { void 0 === i && (i = !1); var s, n, r = $(t), o = $(t) && function (e) { var t = e.getBoundingClientRect(), i = B(t.width) / e.offsetWidth || 1, s = B(t.height) / e.offsetHeight || 1; return 1 !== i || 1 !== s }(t), a = q(t), l = F(e, o), d = { scrollLeft: 0, scrollTop: 0 }, c = { x: 0, y: 0 }; return (r || !r && !i) && (("body" !== j(t) || U(a)) && (d = (s = t) !== P(s) && $(s) ? { scrollLeft: (n = s).scrollLeft, scrollTop: n.scrollTop } : z(s)), $(t) ? ((c = F(t, !0)).x += t.clientLeft, c.y += t.clientTop) : a && (c.x = G(a))), { x: l.left + d.scrollLeft - c.x, y: l.top + d.scrollTop - c.y, width: l.width, height: l.height } } function Y(e) { var t = F(e), i = e.offsetWidth, s = e.offsetHeight; return Math.abs(t.width - i) <= 1 && (i = t.width), Math.abs(t.height - s) <= 1 && (s = t.height), { x: e.offsetLeft, y: e.offsetTop, width: i, height: s } } function X(e) { return "html" === j(e) ? e : e.assignedSlot || e.parentNode || (V(e) ? e.host : null) || q(e) } function K(e) { return ["html", "body", "#document"].indexOf(j(e)) >= 0 ? e.ownerDocument.body : $(e) && U(e) ? e : K(X(e)) } function Z(e, t) { var i; void 0 === t && (t = []); var s = K(e), n = s === (null == (i = e.ownerDocument) ? void 0 : i.body), r = P(s), o = n ? [r].concat(r.visualViewport || [], U(s) ? s : []) : s, a = t.concat(o); return n ? a : a.concat(Z(X(o))) } function J(e) { return ["table", "td", "th"].indexOf(j(e)) >= 0 } function Q(e) { return $(e) && "fixed" !== R(e).position ? e.offsetParent : null } function ee(e) { for (var t = P(e), i = Q(e); i && J(i) && "static" === R(i).position;)i = Q(i); return i && ("html" === j(i) || "body" === j(i) && "static" === R(i).position) ? t : i || function (e) { var t = -1 !== navigator.userAgent.toLowerCase().indexOf("firefox"); if (-1 !== navigator.userAgent.indexOf("Trident") && $(e) && "fixed" === R(e).position) return null; var i = X(e); for (V(i) && (i = i.host); $(i) && ["html", "body"].indexOf(j(i)) < 0;) { var s = R(i); if ("none" !== s.transform || "none" !== s.perspective || "paint" === s.contain || -1 !== ["transform", "perspective"].indexOf(s.willChange) || t && "filter" === s.willChange || t && s.filter && "none" !== s.filter) return i; i = i.parentNode } return null }(e) || t } var te = "top", ie = "bottom", se = "right", ne = "left", re = "auto", oe = [te, ie, se, ne], ae = "start", le = "end", de = "clippingParents", ce = "viewport", ue = "popper", he = "reference", pe = oe.reduce((function (e, t) { return e.concat([t + "-" + ae, t + "-" + le]) }), []), fe = [].concat(oe, [re]).reduce((function (e, t) { return e.concat([t, t + "-" + ae, t + "-" + le]) }), []), me = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"]; function ge(e) { var t = new Map, i = new Set, s = []; function n(e) { i.add(e.name), [].concat(e.requires || [], e.requiresIfExists || []).forEach((function (e) { if (!i.has(e)) { var s = t.get(e); s && n(s) } })), s.push(e) } return e.forEach((function (e) { t.set(e.name, e) })), e.forEach((function (e) { i.has(e.name) || n(e) })), s } var ve = { placement: "bottom", modifiers: [], strategy: "absolute" }; function ye() { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; return !t.some((function (e) { return !(e && "function" == typeof e.getBoundingClientRect) })) } function be(e) { void 0 === e && (e = {}); var t = e, i = t.defaultModifiers, s = void 0 === i ? [] : i, n = t.defaultOptions, r = void 0 === n ? ve : n; return function (e, t, i) { void 0 === i && (i = r); var n, o, a = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, ve, r), modifiersData: {}, elements: { reference: e, popper: t }, attributes: {}, styles: {} }, l = [], d = !1, c = { state: a, setOptions: function (i) { var n = "function" == typeof i ? i(a.options) : i; u(), a.options = Object.assign({}, r, a.options, n), a.scrollParents = { reference: I(e) ? Z(e) : e.contextElement ? Z(e.contextElement) : [], popper: Z(t) }; var o = function (e) { var t = ge(e); return me.reduce((function (e, i) { return e.concat(t.filter((function (e) { return e.phase === i }))) }), []) }(function (e) { var t = e.reduce((function (e, t) { var i = e[t.name]; return e[t.name] = i ? Object.assign({}, i, t, { options: Object.assign({}, i.options, t.options), data: Object.assign({}, i.data, t.data) }) : t, e }), {}); return Object.keys(t).map((function (e) { return t[e] })) }([].concat(s, a.options.modifiers))); return a.orderedModifiers = o.filter((function (e) { return e.enabled })), a.orderedModifiers.forEach((function (e) { var t = e.name, i = e.options, s = void 0 === i ? {} : i, n = e.effect; if ("function" == typeof n) { var r = n({ state: a, name: t, instance: c, options: s }), o = function () { }; l.push(r || o) } })), c.update() }, forceUpdate: function () { if (!d) { var e = a.elements, t = e.reference, i = e.popper; if (ye(t, i)) { a.rects = { reference: W(t, ee(i), "fixed" === a.options.strategy), popper: Y(i) }, a.reset = !1, a.placement = a.options.placement, a.orderedModifiers.forEach((function (e) { return a.modifiersData[e.name] = Object.assign({}, e.data) })); for (var s = 0; s < a.orderedModifiers.length; s++)if (!0 !== a.reset) { var n = a.orderedModifiers[s], r = n.fn, o = n.options, l = void 0 === o ? {} : o, u = n.name; "function" == typeof r && (a = r({ state: a, options: l, name: u, instance: c }) || a) } else a.reset = !1, s = -1 } } }, update: (n = function () { return new Promise((function (e) { c.forceUpdate(), e(a) })) }, function () { return o || (o = new Promise((function (e) { Promise.resolve().then((function () { o = void 0, e(n()) })) }))), o }), destroy: function () { u(), d = !0 } }; if (!ye(e, t)) return c; function u() { l.forEach((function (e) { return e() })), l = [] } return c.setOptions(i).then((function (e) { !d && i.onFirstUpdate && i.onFirstUpdate(e) })), c } } var we = { passive: !0 }; const Se = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: function (e) { var t = e.state, i = e.instance, s = e.options, n = s.scroll, r = void 0 === n || n, o = s.resize, a = void 0 === o || o, l = P(t.elements.popper), d = [].concat(t.scrollParents.reference, t.scrollParents.popper); return r && d.forEach((function (e) { e.addEventListener("scroll", i.update, we) })), a && l.addEventListener("resize", i.update, we), function () { r && d.forEach((function (e) { e.removeEventListener("scroll", i.update, we) })), a && l.removeEventListener("resize", i.update, we) } }, data: {} }; function xe(e) { return e.split("-")[0] } function Ce(e) { return e.split("-")[1] } function Ee(e) { return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y" } function Te(e) { var t, i = e.reference, s = e.element, n = e.placement, r = n ? xe(n) : null, o = n ? Ce(n) : null, a = i.x + i.width / 2 - s.width / 2, l = i.y + i.height / 2 - s.height / 2; switch (r) { case te: t = { x: a, y: i.y - s.height }; break; case ie: t = { x: a, y: i.y + i.height }; break; case se: t = { x: i.x + i.width, y: l }; break; case ne: t = { x: i.x - s.width, y: l }; break; default: t = { x: i.x, y: i.y } }var d = r ? Ee(r) : null; if (null != d) { var c = "y" === d ? "height" : "width"; switch (o) { case ae: t[d] = t[d] - (i[c] / 2 - s[c] / 2); break; case le: t[d] = t[d] + (i[c] / 2 - s[c] / 2) } } return t } var De = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function ke(e) { var t, i = e.popper, s = e.popperRect, n = e.placement, r = e.variation, o = e.offsets, a = e.position, l = e.gpuAcceleration, d = e.adaptive, c = e.roundOffsets, u = e.isFixed, h = o.x, p = void 0 === h ? 0 : h, f = o.y, m = void 0 === f ? 0 : f, g = "function" == typeof c ? c({ x: p, y: m }) : { x: p, y: m }; p = g.x, m = g.y; var v = o.hasOwnProperty("x"), y = o.hasOwnProperty("y"), b = ne, w = te, S = window; if (d) { var x = ee(i), C = "clientHeight", E = "clientWidth"; if (x === P(i) && "static" !== R(x = q(i)).position && "absolute" === a && (C = "scrollHeight", E = "scrollWidth"), n === te || (n === ne || n === se) && r === le) w = ie, m -= (u && x === S && S.visualViewport ? S.visualViewport.height : x[C]) - s.height, m *= l ? 1 : -1; if (n === ne || (n === te || n === ie) && r === le) b = se, p -= (u && x === S && S.visualViewport ? S.visualViewport.width : x[E]) - s.width, p *= l ? 1 : -1 } var T, D = Object.assign({ position: a }, d && De), k = !0 === c ? function (e) { var t = e.x, i = e.y, s = window.devicePixelRatio || 1; return { x: B(t * s) / s || 0, y: B(i * s) / s || 0 } }({ x: p, y: m }) : { x: p, y: m }; return p = k.x, m = k.y, l ? Object.assign({}, D, ((T = {})[w] = y ? "0" : "", T[b] = v ? "0" : "", T.transform = (S.devicePixelRatio || 1) <= 1 ? "translate(" + p + "px, " + m + "px)" : "translate3d(" + p + "px, " + m + "px, 0)", T)) : Object.assign({}, D, ((t = {})[w] = y ? m + "px" : "", t[b] = v ? p + "px" : "", t.transform = "", t)) } const Le = { name: "applyStyles", enabled: !0, phase: "write", fn: function (e) { var t = e.state; Object.keys(t.elements).forEach((function (e) { var i = t.styles[e] || {}, s = t.attributes[e] || {}, n = t.elements[e]; $(n) && j(n) && (Object.assign(n.style, i), Object.keys(s).forEach((function (e) { var t = s[e]; !1 === t ? n.removeAttribute(e) : n.setAttribute(e, !0 === t ? "" : t) }))) })) }, effect: function (e) { var t = e.state, i = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(t.elements.popper.style, i.popper), t.styles = i, t.elements.arrow && Object.assign(t.elements.arrow.style, i.arrow), function () { Object.keys(t.elements).forEach((function (e) { var s = t.elements[e], n = t.attributes[e] || {}, r = Object.keys(t.styles.hasOwnProperty(e) ? t.styles[e] : i[e]).reduce((function (e, t) { return e[t] = "", e }), {}); $(s) && j(s) && (Object.assign(s.style, r), Object.keys(n).forEach((function (e) { s.removeAttribute(e) }))) })) } }, requires: ["computeStyles"] }; const _e = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (e) { var t = e.state, i = e.options, s = e.name, n = i.offset, r = void 0 === n ? [0, 0] : n, o = fe.reduce((function (e, i) { return e[i] = function (e, t, i) { var s = xe(e), n = [ne, te].indexOf(s) >= 0 ? -1 : 1, r = "function" == typeof i ? i(Object.assign({}, t, { placement: e })) : i, o = r[0], a = r[1]; return o = o || 0, a = (a || 0) * n, [ne, se].indexOf(s) >= 0 ? { x: a, y: o } : { x: o, y: a } }(i, t.rects, r), e }), {}), a = o[t.placement], l = a.x, d = a.y; null != t.modifiersData.popperOffsets && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += d), t.modifiersData[s] = o } }; var Oe = { left: "right", right: "left", bottom: "top", top: "bottom" }; function Me(e) { return e.replace(/left|right|bottom|top/g, (function (e) { return Oe[e] })) } var Ae = { start: "end", end: "start" }; function Pe(e) { return e.replace(/start|end/g, (function (e) { return Ae[e] })) } function Ie(e, t) { var i = t.getRootNode && t.getRootNode(); if (e.contains(t)) return !0; if (i && V(i)) { var s = t; do { if (s && e.isSameNode(s)) return !0; s = s.parentNode || s.host } while (s) } return !1 } function $e(e) { return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function Ve(e, t) { return t === ce ? $e(function (e) { var t = P(e), i = q(e), s = t.visualViewport, n = i.clientWidth, r = i.clientHeight, o = 0, a = 0; return s && (n = s.width, r = s.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = s.offsetLeft, a = s.offsetTop)), { width: n, height: r, x: o + G(e), y: a } }(e)) : I(t) ? function (e) { var t = F(e); return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t }(t) : $e(function (e) { var t, i = q(e), s = z(e), n = null == (t = e.ownerDocument) ? void 0 : t.body, r = N(i.scrollWidth, i.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), o = N(i.scrollHeight, i.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -s.scrollLeft + G(e), l = -s.scrollTop; return "rtl" === R(n || i).direction && (a += N(i.clientWidth, n ? n.clientWidth : 0) - r), { width: r, height: o, x: a, y: l } }(q(e))) } function Ne(e, t, i) { var s = "clippingParents" === t ? function (e) { var t = Z(X(e)), i = ["absolute", "fixed"].indexOf(R(e).position) >= 0 && $(e) ? ee(e) : e; return I(i) ? t.filter((function (e) { return I(e) && Ie(e, i) && "body" !== j(e) })) : [] }(e) : [].concat(t), n = [].concat(s, [i]), r = n[0], o = n.reduce((function (t, i) { var s = Ve(e, i); return t.top = N(s.top, t.top), t.right = H(s.right, t.right), t.bottom = H(s.bottom, t.bottom), t.left = N(s.left, t.left), t }), Ve(e, r)); return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o } function He(e) { return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e) } function Be(e, t) { return t.reduce((function (t, i) { return t[i] = e, t }), {}) } function Fe(e, t) { void 0 === t && (t = {}); var i = t, s = i.placement, n = void 0 === s ? e.placement : s, r = i.boundary, o = void 0 === r ? de : r, a = i.rootBoundary, l = void 0 === a ? ce : a, d = i.elementContext, c = void 0 === d ? ue : d, u = i.altBoundary, h = void 0 !== u && u, p = i.padding, f = void 0 === p ? 0 : p, m = He("number" != typeof f ? f : Be(f, oe)), g = c === ue ? he : ue, v = e.rects.popper, y = e.elements[h ? g : c], b = Ne(I(y) ? y : y.contextElement || q(e.elements.popper), o, l), w = F(e.elements.reference), S = Te({ reference: w, element: v, strategy: "absolute", placement: n }), x = $e(Object.assign({}, v, S)), C = c === ue ? x : w, E = { top: b.top - C.top + m.top, bottom: C.bottom - b.bottom + m.bottom, left: b.left - C.left + m.left, right: C.right - b.right + m.right }, T = e.modifiersData.offset; if (c === ue && T) { var D = T[n]; Object.keys(E).forEach((function (e) { var t = [se, ie].indexOf(e) >= 0 ? 1 : -1, i = [te, ie].indexOf(e) >= 0 ? "y" : "x"; E[e] += D[i] * t })) } return E } function ze(e, t, i) { return N(e, H(t, i)) } const je = { name: "preventOverflow", enabled: !0, phase: "main", fn: function (e) { var t = e.state, i = e.options, s = e.name, n = i.mainAxis, r = void 0 === n || n, o = i.altAxis, a = void 0 !== o && o, l = i.boundary, d = i.rootBoundary, c = i.altBoundary, u = i.padding, h = i.tether, p = void 0 === h || h, f = i.tetherOffset, m = void 0 === f ? 0 : f, g = Fe(t, { boundary: l, rootBoundary: d, padding: u, altBoundary: c }), v = xe(t.placement), y = Ce(t.placement), b = !y, w = Ee(v), S = "x" === w ? "y" : "x", x = t.modifiersData.popperOffsets, C = t.rects.reference, E = t.rects.popper, T = "function" == typeof m ? m(Object.assign({}, t.rects, { placement: t.placement })) : m, D = "number" == typeof T ? { mainAxis: T, altAxis: T } : Object.assign({ mainAxis: 0, altAxis: 0 }, T), k = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, L = { x: 0, y: 0 }; if (x) { if (r) { var _, O = "y" === w ? te : ne, M = "y" === w ? ie : se, A = "y" === w ? "height" : "width", P = x[w], I = P + g[O], $ = P - g[M], V = p ? -E[A] / 2 : 0, B = y === ae ? C[A] : E[A], F = y === ae ? -E[A] : -C[A], z = t.elements.arrow, j = p && z ? Y(z) : { width: 0, height: 0 }, q = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, G = q[O], R = q[M], U = ze(0, C[A], j[A]), W = b ? C[A] / 2 - V - U - G - D.mainAxis : B - U - G - D.mainAxis, X = b ? -C[A] / 2 + V + U + R + D.mainAxis : F + U + R + D.mainAxis, K = t.elements.arrow && ee(t.elements.arrow), Z = K ? "y" === w ? K.clientTop || 0 : K.clientLeft || 0 : 0, J = null != (_ = null == k ? void 0 : k[w]) ? _ : 0, Q = P + X - J, re = ze(p ? H(I, P + W - J - Z) : I, P, p ? N($, Q) : $); x[w] = re, L[w] = re - P } if (a) { var oe, le = "x" === w ? te : ne, de = "x" === w ? ie : se, ce = x[S], ue = "y" === S ? "height" : "width", he = ce + g[le], pe = ce - g[de], fe = -1 !== [te, ne].indexOf(v), me = null != (oe = null == k ? void 0 : k[S]) ? oe : 0, ge = fe ? he : ce - C[ue] - E[ue] - me + D.altAxis, ve = fe ? ce + C[ue] + E[ue] - me - D.altAxis : pe, ye = p && fe ? function (e, t, i) { var s = ze(e, t, i); return s > i ? i : s }(ge, ce, ve) : ze(p ? ge : he, ce, p ? ve : pe); x[S] = ye, L[S] = ye - ce } t.modifiersData[s] = L } }, requiresIfExists: ["offset"] }; const qe = { name: "arrow", enabled: !0, phase: "main", fn: function (e) { var t, i = e.state, s = e.name, n = e.options, r = i.elements.arrow, o = i.modifiersData.popperOffsets, a = xe(i.placement), l = Ee(a), d = [ne, se].indexOf(a) >= 0 ? "height" : "width"; if (r && o) { var c = function (e, t) { return He("number" != typeof (e = "function" == typeof e ? e(Object.assign({}, t.rects, { placement: t.placement })) : e) ? e : Be(e, oe)) }(n.padding, i), u = Y(r), h = "y" === l ? te : ne, p = "y" === l ? ie : se, f = i.rects.reference[d] + i.rects.reference[l] - o[l] - i.rects.popper[d], m = o[l] - i.rects.reference[l], g = ee(r), v = g ? "y" === l ? g.clientHeight || 0 : g.clientWidth || 0 : 0, y = f / 2 - m / 2, b = c[h], w = v - u[d] - c[p], S = v / 2 - u[d] / 2 + y, x = ze(b, S, w), C = l; i.modifiersData[s] = ((t = {})[C] = x, t.centerOffset = x - S, t) } }, effect: function (e) { var t = e.state, i = e.options.element, s = void 0 === i ? "[data-popper-arrow]" : i; null != s && ("string" != typeof s || (s = t.elements.popper.querySelector(s))) && Ie(t.elements.popper, s) && (t.elements.arrow = s) }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function Ge(e, t, i) { return void 0 === i && (i = { x: 0, y: 0 }), { top: e.top - t.height - i.y, right: e.right - t.width + i.x, bottom: e.bottom - t.height + i.y, left: e.left - t.width - i.x } } function Re(e) { return [te, se, ie, ne].some((function (t) { return e[t] >= 0 })) } var Ue = be({ defaultModifiers: [Se, { name: "popperOffsets", enabled: !0, phase: "read", fn: function (e) { var t = e.state, i = e.name; t.modifiersData[i] = Te({ reference: t.rects.reference, element: t.rects.popper, strategy: "absolute", placement: t.placement }) }, data: {} }, { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (e) { var t = e.state, i = e.options, s = i.gpuAcceleration, n = void 0 === s || s, r = i.adaptive, o = void 0 === r || r, a = i.roundOffsets, l = void 0 === a || a, d = { placement: xe(t.placement), variation: Ce(t.placement), popper: t.elements.popper, popperRect: t.rects.popper, gpuAcceleration: n, isFixed: "fixed" === t.options.strategy }; null != t.modifiersData.popperOffsets && (t.styles.popper = Object.assign({}, t.styles.popper, ke(Object.assign({}, d, { offsets: t.modifiersData.popperOffsets, position: t.options.strategy, adaptive: o, roundOffsets: l })))), null != t.modifiersData.arrow && (t.styles.arrow = Object.assign({}, t.styles.arrow, ke(Object.assign({}, d, { offsets: t.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))), t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-placement": t.placement }) }, data: {} }, Le, _e, { name: "flip", enabled: !0, phase: "main", fn: function (e) { var t = e.state, i = e.options, s = e.name; if (!t.modifiersData[s]._skip) { for (var n = i.mainAxis, r = void 0 === n || n, o = i.altAxis, a = void 0 === o || o, l = i.fallbackPlacements, d = i.padding, c = i.boundary, u = i.rootBoundary, h = i.altBoundary, p = i.flipVariations, f = void 0 === p || p, m = i.allowedAutoPlacements, g = t.options.placement, v = xe(g), y = l || (v === g || !f ? [Me(g)] : function (e) { if (xe(e) === re) return []; var t = Me(e); return [Pe(e), t, Pe(t)] }(g)), b = [g].concat(y).reduce((function (e, i) { return e.concat(xe(i) === re ? function (e, t) { void 0 === t && (t = {}); var i = t, s = i.placement, n = i.boundary, r = i.rootBoundary, o = i.padding, a = i.flipVariations, l = i.allowedAutoPlacements, d = void 0 === l ? fe : l, c = Ce(s), u = c ? a ? pe : pe.filter((function (e) { return Ce(e) === c })) : oe, h = u.filter((function (e) { return d.indexOf(e) >= 0 })); 0 === h.length && (h = u); var p = h.reduce((function (t, i) { return t[i] = Fe(e, { placement: i, boundary: n, rootBoundary: r, padding: o })[xe(i)], t }), {}); return Object.keys(p).sort((function (e, t) { return p[e] - p[t] })) }(t, { placement: i, boundary: c, rootBoundary: u, padding: d, flipVariations: f, allowedAutoPlacements: m }) : i) }), []), w = t.rects.reference, S = t.rects.popper, x = new Map, C = !0, E = b[0], T = 0; T < b.length; T++) { var D = b[T], k = xe(D), L = Ce(D) === ae, _ = [te, ie].indexOf(k) >= 0, O = _ ? "width" : "height", M = Fe(t, { placement: D, boundary: c, rootBoundary: u, altBoundary: h, padding: d }), A = _ ? L ? se : ne : L ? ie : te; w[O] > S[O] && (A = Me(A)); var P = Me(A), I = []; if (r && I.push(M[k] <= 0), a && I.push(M[A] <= 0, M[P] <= 0), I.every((function (e) { return e }))) { E = D, C = !1; break } x.set(D, I) } if (C) for (var $ = function (e) { var t = b.find((function (t) { var i = x.get(t); if (i) return i.slice(0, e).every((function (e) { return e })) })); if (t) return E = t, "break" }, V = f ? 3 : 1; V > 0; V--) { if ("break" === $(V)) break } t.placement !== E && (t.modifiersData[s]._skip = !0, t.placement = E, t.reset = !0) } }, requiresIfExists: ["offset"], data: { _skip: !1 } }, je, qe, { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (e) { var t = e.state, i = e.name, s = t.rects.reference, n = t.rects.popper, r = t.modifiersData.preventOverflow, o = Fe(t, { elementContext: "reference" }), a = Fe(t, { altBoundary: !0 }), l = Ge(o, s), d = Ge(a, n, r), c = Re(l), u = Re(d); t.modifiersData[i] = { referenceClippingOffsets: l, popperEscapeOffsets: d, isReferenceHidden: c, hasPopperEscaped: u }, t.attributes.popper = Object.assign({}, t.attributes.popper, { "data-popper-reference-hidden": c, "data-popper-escaped": u }) } }] }), We = "tippy-content", Ye = "tippy-backdrop", Xe = "tippy-arrow", Ke = "tippy-svg-arrow", Ze = { passive: !0, capture: !0 }, Je = function () { return document.body }; function Qe(e, t, i) { if (Array.isArray(e)) { var s = e[t]; return null == s ? Array.isArray(i) ? i[t] : i : s } return e } function et(e, t) { var i = {}.toString.call(e); return 0 === i.indexOf("[object") && i.indexOf(t + "]") > -1 } function tt(e, t) { return "function" == typeof e ? e.apply(void 0, t) : e } function it(e, t) { return 0 === t ? e : function (s) { clearTimeout(i), i = setTimeout((function () { e(s) }), t) }; var i } function st(e) { return [].concat(e) } function nt(e, t) { -1 === e.indexOf(t) && e.push(t) } function rt(e) { return e.split("-")[0] } function ot(e) { return [].slice.call(e) } function at(e) { return Object.keys(e).reduce((function (t, i) { return void 0 !== e[i] && (t[i] = e[i]), t }), {}) } function lt() { return document.createElement("div") } function dt(e) { return ["Element", "Fragment"].some((function (t) { return et(e, t) })) } function ct(e) { return et(e, "MouseEvent") } function ut(e) { return !(!e || !e._tippy || e._tippy.reference !== e) } function ht(e) { return dt(e) ? [e] : function (e) { return et(e, "NodeList") }(e) ? ot(e) : Array.isArray(e) ? e : ot(document.querySelectorAll(e)) } function pt(e, t) { e.forEach((function (e) { e && (e.style.transitionDuration = t + "ms") })) } function ft(e, t) { e.forEach((function (e) { e && e.setAttribute("data-state", t) })) } function mt(e) { var t, i = st(e)[0]; return null != i && null != (t = i.ownerDocument) && t.body ? i.ownerDocument : document } function gt(e, t, i) { var s = t + "EventListener";["transitionend", "webkitTransitionEnd"].forEach((function (t) { e[s](t, i) })) } function vt(e, t) { for (var i = t; i;) { var s; if (e.contains(i)) return !0; i = null == i.getRootNode || null == (s = i.getRootNode()) ? void 0 : s.host } return !1 } var yt = { isTouch: !1 }, bt = 0; function wt() { yt.isTouch || (yt.isTouch = !0, window.performance && document.addEventListener("mousemove", St)) } function St() { var e = performance.now(); e - bt < 20 && (yt.isTouch = !1, document.removeEventListener("mousemove", St)), bt = e } function xt() { var e = document.activeElement; if (ut(e)) { var t = e._tippy; e.blur && !t.state.isVisible && e.blur() } } var Ct = !!("undefined" != typeof window && "undefined" != typeof document) && !!window.msCrypto; var Et = { animateFill: !1, followCursor: !1, inlinePositioning: !1, sticky: !1 }, Tt = Object.assign({ appendTo: Je, aria: { content: "auto", expanded: "auto" }, delay: 0, duration: [300, 250], getReferenceClientRect: null, hideOnClick: !0, ignoreAttributes: !1, interactive: !1, interactiveBorder: 2, interactiveDebounce: 0, moveTransition: "", offset: [0, 10], onAfterUpdate: function () { }, onBeforeUpdate: function () { }, onCreate: function () { }, onDestroy: function () { }, onHidden: function () { }, onHide: function () { }, onMount: function () { }, onShow: function () { }, onShown: function () { }, onTrigger: function () { }, onUntrigger: function () { }, onClickOutside: function () { }, placement: "top", plugins: [], popperOptions: {}, render: null, showOnCreate: !1, touch: !0, trigger: "mouseenter focus", triggerTarget: null }, Et, { allowHTML: !1, animation: "fade", arrow: !0, content: "", inertia: !1, maxWidth: 350, role: "tooltip", theme: "", zIndex: 9999 }), Dt = Object.keys(Tt); function kt(e) { var t = (e.plugins || []).reduce((function (t, i) { var s, n = i.name, r = i.defaultValue; n && (t[n] = void 0 !== e[n] ? e[n] : null != (s = Tt[n]) ? s : r); return t }), {}); return Object.assign({}, e, t) } function Lt(e, t) { var i = Object.assign({}, t, { content: tt(t.content, [e]) }, t.ignoreAttributes ? {} : function (e, t) { return (t ? Object.keys(kt(Object.assign({}, Tt, { plugins: t }))) : Dt).reduce((function (t, i) { var s = (e.getAttribute("data-tippy-" + i) || "").trim(); if (!s) return t; if ("content" === i) t[i] = s; else try { t[i] = JSON.parse(s) } catch (e) { t[i] = s } return t }), {}) }(e, t.plugins)); return i.aria = Object.assign({}, Tt.aria, i.aria), i.aria = { expanded: "auto" === i.aria.expanded ? t.interactive : i.aria.expanded, content: "auto" === i.aria.content ? t.interactive ? null : "describedby" : i.aria.content }, i } var _t = function () { return "innerHTML" }; function Ot(e, t) { e[_t()] = t } function Mt(e) { var t = lt(); return !0 === e ? t.className = Xe : (t.className = Ke, dt(e) ? t.appendChild(e) : Ot(t, e)), t } function At(e, t) { dt(t.content) ? (Ot(e, ""), e.appendChild(t.content)) : "function" != typeof t.content && (t.allowHTML ? Ot(e, t.content) : e.textContent = t.content) } function Pt(e) { var t = e.firstElementChild, i = ot(t.children); return { box: t, content: i.find((function (e) { return e.classList.contains(We) })), arrow: i.find((function (e) { return e.classList.contains(Xe) || e.classList.contains(Ke) })), backdrop: i.find((function (e) { return e.classList.contains(Ye) })) } } function It(e) { var t = lt(), i = lt(); i.className = "tippy-box", i.setAttribute("data-state", "hidden"), i.setAttribute("tabindex", "-1"); var s = lt(); function n(i, s) { var n = Pt(t), r = n.box, o = n.content, a = n.arrow; s.theme ? r.setAttribute("data-theme", s.theme) : r.removeAttribute("data-theme"), "string" == typeof s.animation ? r.setAttribute("data-animation", s.animation) : r.removeAttribute("data-animation"), s.inertia ? r.setAttribute("data-inertia", "") : r.removeAttribute("data-inertia"), r.style.maxWidth = "number" == typeof s.maxWidth ? s.maxWidth + "px" : s.maxWidth, s.role ? r.setAttribute("role", s.role) : r.removeAttribute("role"), i.content === s.content && i.allowHTML === s.allowHTML || At(o, e.props), s.arrow ? a ? i.arrow !== s.arrow && (r.removeChild(a), r.appendChild(Mt(s.arrow))) : r.appendChild(Mt(s.arrow)) : a && r.removeChild(a) } return s.className = We, s.setAttribute("data-state", "hidden"), At(s, e.props), t.appendChild(i), i.appendChild(s), n(e.props, e.props), { popper: t, onUpdate: n } } It.$$tippy = !0; var $t = 1, Vt = [], Nt = []; function Ht(e, t) { var i, s, n, r, o, a, l, d, c = Lt(e, Object.assign({}, Tt, kt(at(t)))), u = !1, h = !1, p = !1, f = !1, m = [], g = it(W, c.interactiveDebounce), v = $t++, y = (d = c.plugins).filter((function (e, t) { return d.indexOf(e) === t })), b = { id: v, reference: e, popper: lt(), popperInstance: null, props: c, state: { isEnabled: !0, isVisible: !1, isDestroyed: !1, isMounted: !1, isShown: !1 }, plugins: y, clearDelayTimeouts: function () { clearTimeout(i), clearTimeout(s), cancelAnimationFrame(n) }, setProps: function (t) { 0; if (b.state.isDestroyed) return; P("onBeforeUpdate", [b, t]), R(); var i = b.props, s = Lt(e, Object.assign({}, i, at(t), { ignoreAttributes: !0 })); b.props = s, G(), i.interactiveDebounce !== s.interactiveDebounce && (V(), g = it(W, s.interactiveDebounce)); i.triggerTarget && !s.triggerTarget ? st(i.triggerTarget).forEach((function (e) { e.removeAttribute("aria-expanded") })) : s.triggerTarget && e.removeAttribute("aria-expanded"); $(), A(), x && x(i, s); b.popperInstance && (Z(), Q().forEach((function (e) { requestAnimationFrame(e._tippy.popperInstance.forceUpdate) }))); P("onAfterUpdate", [b, t]) }, setContent: function (e) { b.setProps({ content: e }) }, show: function () { 0; var e = b.state.isVisible, t = b.state.isDestroyed, i = !b.state.isEnabled, s = yt.isTouch && !b.props.touch, n = Qe(b.props.duration, 0, Tt.duration); if (e || t || i || s) return; if (L().hasAttribute("disabled")) return; if (P("onShow", [b], !1), !1 === b.props.onShow(b)) return; b.state.isVisible = !0, k() && (S.style.visibility = "visible"); A(), F(), b.state.isMounted || (S.style.transition = "none"); if (k()) { var r = O(); pt([r.box, r.content], 0) } a = function () { var e; if (b.state.isVisible && !f) { if (f = !0, S.offsetHeight, S.style.transition = b.props.moveTransition, k() && b.props.animation) { var t = O(), i = t.box, s = t.content; pt([i, s], n), ft([i, s], "visible") } I(), $(), nt(Nt, b), null == (e = b.popperInstance) || e.forceUpdate(), P("onMount", [b]), b.props.animation && k() && function (e, t) { j(e, t) }(n, (function () { b.state.isShown = !0, P("onShown", [b]) })) } }, function () { var e, t = b.props.appendTo, i = L(); e = b.props.interactive && t === Je || "parent" === t ? i.parentNode : tt(t, [i]); e.contains(S) || e.appendChild(S); b.state.isMounted = !0, Z(), !1 }() }, hide: function () { 0; var e = !b.state.isVisible, t = b.state.isDestroyed, i = !b.state.isEnabled, s = Qe(b.props.duration, 1, Tt.duration); if (e || t || i) return; if (P("onHide", [b], !1), !1 === b.props.onHide(b)) return; b.state.isVisible = !1, b.state.isShown = !1, f = !1, u = !1, k() && (S.style.visibility = "hidden"); if (V(), z(), A(!0), k()) { var n = O(), r = n.box, o = n.content; b.props.animation && (pt([r, o], s), ft([r, o], "hidden")) } I(), $(), b.props.animation ? k() && function (e, t) { j(e, (function () { !b.state.isVisible && S.parentNode && S.parentNode.contains(S) && t() })) }(s, b.unmount) : b.unmount() }, hideWithInteractivity: function (e) { 0; _().addEventListener("mousemove", g), nt(Vt, g), g(e) }, enable: function () { b.state.isEnabled = !0 }, disable: function () { b.hide(), b.state.isEnabled = !1 }, unmount: function () { 0; b.state.isVisible && b.hide(); if (!b.state.isMounted) return; J(), Q().forEach((function (e) { e._tippy.unmount() })), S.parentNode && S.parentNode.removeChild(S); Nt = Nt.filter((function (e) { return e !== b })), b.state.isMounted = !1, P("onHidden", [b]) }, destroy: function () { 0; if (b.state.isDestroyed) return; b.clearDelayTimeouts(), b.unmount(), R(), delete e._tippy, b.state.isDestroyed = !0, P("onDestroy", [b]) } }; if (!c.render) return b; var w = c.render(b), S = w.popper, x = w.onUpdate; S.setAttribute("data-tippy-root", ""), S.id = "tippy-" + b.id, b.popper = S, e._tippy = b, S._tippy = b; var C = y.map((function (e) { return e.fn(b) })), E = e.hasAttribute("aria-expanded"); return G(), $(), A(), P("onCreate", [b]), c.showOnCreate && ee(), S.addEventListener("mouseenter", (function () { b.props.interactive && b.state.isVisible && b.clearDelayTimeouts() })), S.addEventListener("mouseleave", (function () { b.props.interactive && b.props.trigger.indexOf("mouseenter") >= 0 && _().addEventListener("mousemove", g) })), b; function T() { var e = b.props.touch; return Array.isArray(e) ? e : [e, 0] } function D() { return "hold" === T()[0] } function k() { var e; return !(null == (e = b.props.render) || !e.$$tippy) } function L() { return l || e } function _() { var e = L().parentNode; return e ? mt(e) : document } function O() { return Pt(S) } function M(e) { return b.state.isMounted && !b.state.isVisible || yt.isTouch || r && "focus" === r.type ? 0 : Qe(b.props.delay, e ? 0 : 1, Tt.delay) } function A(e) { void 0 === e && (e = !1), S.style.pointerEvents = b.props.interactive && !e ? "" : "none", S.style.zIndex = "" + b.props.zIndex } function P(e, t, i) { var s; (void 0 === i && (i = !0), C.forEach((function (i) { i[e] && i[e].apply(i, t) })), i) && (s = b.props)[e].apply(s, t) } function I() { var t = b.props.aria; if (t.content) { var i = "aria-" + t.content, s = S.id; st(b.props.triggerTarget || e).forEach((function (e) { var t = e.getAttribute(i); if (b.state.isVisible) e.setAttribute(i, t ? t + " " + s : s); else { var n = t && t.replace(s, "").trim(); n ? e.setAttribute(i, n) : e.removeAttribute(i) } })) } } function $() { !E && b.props.aria.expanded && st(b.props.triggerTarget || e).forEach((function (e) { b.props.interactive ? e.setAttribute("aria-expanded", b.state.isVisible && e === L() ? "true" : "false") : e.removeAttribute("aria-expanded") })) } function V() { _().removeEventListener("mousemove", g), Vt = Vt.filter((function (e) { return e !== g })) } function N(t) { if (!yt.isTouch || !p && "mousedown" !== t.type) { var i = t.composedPath && t.composedPath()[0] || t.target; if (!b.props.interactive || !vt(S, i)) { if (st(b.props.triggerTarget || e).some((function (e) { return vt(e, i) }))) { if (yt.isTouch) return; if (b.state.isVisible && b.props.trigger.indexOf("click") >= 0) return } else P("onClickOutside", [b, t]); !0 === b.props.hideOnClick && (b.clearDelayTimeouts(), b.hide(), h = !0, setTimeout((function () { h = !1 })), b.state.isMounted || z()) } } } function H() { p = !0 } function B() { p = !1 } function F() { var e = _(); e.addEventListener("mousedown", N, !0), e.addEventListener("touchend", N, Ze), e.addEventListener("touchstart", B, Ze), e.addEventListener("touchmove", H, Ze) } function z() { var e = _(); e.removeEventListener("mousedown", N, !0), e.removeEventListener("touchend", N, Ze), e.removeEventListener("touchstart", B, Ze), e.removeEventListener("touchmove", H, Ze) } function j(e, t) { var i = O().box; function s(e) { e.target === i && (gt(i, "remove", s), t()) } if (0 === e) return t(); gt(i, "remove", o), gt(i, "add", s), o = s } function q(t, i, s) { void 0 === s && (s = !1), st(b.props.triggerTarget || e).forEach((function (e) { e.addEventListener(t, i, s), m.push({ node: e, eventType: t, handler: i, options: s }) })) } function G() { D() && (q("touchstart", U, { passive: !0 }), q("touchend", Y, { passive: !0 })), function (e) { return e.split(/\s+/).filter(Boolean) }(b.props.trigger).forEach((function (e) { if ("manual" !== e) switch (q(e, U), e) { case "mouseenter": q("mouseleave", Y); break; case "focus": q(Ct ? "focusout" : "blur", X); break; case "focusin": q("focusout", X) } })) } function R() { m.forEach((function (e) { var t = e.node, i = e.eventType, s = e.handler, n = e.options; t.removeEventListener(i, s, n) })), m = [] } function U(e) { var t, i = !1; if (b.state.isEnabled && !K(e) && !h) { var s = "focus" === (null == (t = r) ? void 0 : t.type); r = e, l = e.currentTarget, $(), !b.state.isVisible && ct(e) && Vt.forEach((function (t) { return t(e) })), "click" === e.type && (b.props.trigger.indexOf("mouseenter") < 0 || u) && !1 !== b.props.hideOnClick && b.state.isVisible ? i = !0 : ee(e), "click" === e.type && (u = !i), i && !s && te(e) } } function W(e) { var t = e.target, i = L().contains(t) || S.contains(t); if ("mousemove" !== e.type || !i) { var s = Q().concat(S).map((function (e) { var t, i = null == (t = e._tippy.popperInstance) ? void 0 : t.state; return i ? { popperRect: e.getBoundingClientRect(), popperState: i, props: c } : null })).filter(Boolean); (function (e, t) { var i = t.clientX, s = t.clientY; return e.every((function (e) { var t = e.popperRect, n = e.popperState, r = e.props.interactiveBorder, o = rt(n.placement), a = n.modifiersData.offset; if (!a) return !0; var l = "bottom" === o ? a.top.y : 0, d = "top" === o ? a.bottom.y : 0, c = "right" === o ? a.left.x : 0, u = "left" === o ? a.right.x : 0, h = t.top - s + l > r, p = s - t.bottom - d > r, f = t.left - i + c > r, m = i - t.right - u > r; return h || p || f || m })) })(s, e) && (V(), te(e)) } } function Y(e) { K(e) || b.props.trigger.indexOf("click") >= 0 && u || (b.props.interactive ? b.hideWithInteractivity(e) : te(e)) } function X(e) { b.props.trigger.indexOf("focusin") < 0 && e.target !== L() || b.props.interactive && e.relatedTarget && S.contains(e.relatedTarget) || te(e) } function K(e) { return !!yt.isTouch && D() !== e.type.indexOf("touch") >= 0 } function Z() { J(); var t = b.props, i = t.popperOptions, s = t.placement, n = t.offset, r = t.getReferenceClientRect, o = t.moveTransition, l = k() ? Pt(S).arrow : null, d = r ? { getBoundingClientRect: r, contextElement: r.contextElement || L() } : e, c = { name: "$$tippy", enabled: !0, phase: "beforeWrite", requires: ["computeStyles"], fn: function (e) { var t = e.state; if (k()) { var i = O().box;["placement", "reference-hidden", "escaped"].forEach((function (e) { "placement" === e ? i.setAttribute("data-placement", t.placement) : t.attributes.popper["data-popper-" + e] ? i.setAttribute("data-" + e, "") : i.removeAttribute("data-" + e) })), t.attributes.popper = {} } } }, u = [{ name: "offset", options: { offset: n } }, { name: "preventOverflow", options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } } }, { name: "flip", options: { padding: 5 } }, { name: "computeStyles", options: { adaptive: !o } }, c]; k() && l && u.push({ name: "arrow", options: { element: l, padding: 3 } }), u.push.apply(u, (null == i ? void 0 : i.modifiers) || []), b.popperInstance = Ue(d, S, Object.assign({}, i, { placement: s, onFirstUpdate: a, modifiers: u })) } function J() { b.popperInstance && (b.popperInstance.destroy(), b.popperInstance = null) } function Q() { return ot(S.querySelectorAll("[data-tippy-root]")) } function ee(e) { b.clearDelayTimeouts(), e && P("onTrigger", [b, e]), F(); var t = M(!0), s = T(), n = s[0], r = s[1]; yt.isTouch && "hold" === n && r && (t = r), t ? i = setTimeout((function () { b.show() }), t) : b.show() } function te(e) { if (b.clearDelayTimeouts(), P("onUntrigger", [b, e]), b.state.isVisible) { if (!(b.props.trigger.indexOf("mouseenter") >= 0 && b.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(e.type) >= 0 && u)) { var t = M(!1); t ? s = setTimeout((function () { b.state.isVisible && b.hide() }), t) : n = requestAnimationFrame((function () { b.hide() })) } } else z() } } function Bt(e, t) { void 0 === t && (t = {}); var i = Tt.plugins.concat(t.plugins || []); document.addEventListener("touchstart", wt, Ze), window.addEventListener("blur", xt); var s = Object.assign({}, t, { plugins: i }), n = ht(e).reduce((function (e, t) { var i = t && Ht(t, s); return i && e.push(i), e }), []); return dt(e) ? n[0] : n } Bt.defaultProps = Tt, Bt.setDefaultProps = function (e) { Object.keys(e).forEach((function (t) { Tt[t] = e[t] })) }, Bt.currentInput = yt; Object.assign({}, Le, { effect: function (e) { var t = e.state, i = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; Object.assign(t.elements.popper.style, i.popper), t.styles = i, t.elements.arrow && Object.assign(t.elements.arrow.style, i.arrow) } }); Bt.setDefaultProps({ render: It }); function Ft(e) { return null !== e && "object" == typeof e && "constructor" in e && e.constructor === Object } function zt(e = {}, t = {}) { Object.keys(t).forEach((i => { void 0 === e[i] ? e[i] = t[i] : Ft(t[i]) && Ft(e[i]) && Object.keys(t[i]).length > 0 && zt(e[i], t[i]) })) } Bt("[data-tippy-content]", {}); const jt = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector: () => null, querySelectorAll: () => [], getElementById: () => null, createEvent: () => ({ initEvent() { } }), createElement: () => ({ children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName: () => [] }), createElementNS: () => ({}), importNode: () => null, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function qt() { const e = "undefined" != typeof document ? document : {}; return zt(e, jt), e } const Gt = { document: jt, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle: () => ({ getPropertyValue: () => "" }), Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia: () => ({}), requestAnimationFrame: e => "undefined" == typeof setTimeout ? (e(), null) : setTimeout(e, 0), cancelAnimationFrame(e) { "undefined" != typeof setTimeout && clearTimeout(e) } }; function Rt() { const e = "undefined" != typeof window ? window : {}; return zt(e, Gt), e } class Ut extends Array { constructor(e) { "number" == typeof e ? super(e) : (super(...e || []), function (e) { const t = e.__proto__; Object.defineProperty(e, "__proto__", { get: () => t, set(e) { t.__proto__ = e } }) }(this)) } } function Wt(e = []) { const t = []; return e.forEach((e => { Array.isArray(e) ? t.push(...Wt(e)) : t.push(e) })), t } function Yt(e, t) { return Array.prototype.filter.call(e, t) } function Xt(e, t) { const i = Rt(), s = qt(); let n = []; if (!t && e instanceof Ut) return e; if (!e) return new Ut(n); if ("string" == typeof e) { const i = e.trim(); if (i.indexOf("<") >= 0 && i.indexOf(">") >= 0) { let e = "div"; 0 === i.indexOf("<li") && (e = "ul"), 0 === i.indexOf("<tr") && (e = "tbody"), 0 !== i.indexOf("<td") && 0 !== i.indexOf("<th") || (e = "tr"), 0 === i.indexOf("<tbody") && (e = "table"), 0 === i.indexOf("<option") && (e = "select"); const t = s.createElement(e); t.innerHTML = i; for (let e = 0; e < t.childNodes.length; e += 1)n.push(t.childNodes[e]) } else n = function (e, t) { if ("string" != typeof e) return [e]; const i = [], s = t.querySelectorAll(e); for (let e = 0; e < s.length; e += 1)i.push(s[e]); return i }(e.trim(), t || s) } else if (e.nodeType || e === i || e === s) n.push(e); else if (Array.isArray(e)) { if (e instanceof Ut) return e; n = e } return new Ut(function (e) { const t = []; for (let i = 0; i < e.length; i += 1)-1 === t.indexOf(e[i]) && t.push(e[i]); return t }(n)) } Xt.fn = Ut.prototype; const Kt = "resize scroll".split(" "); function Zt(e) { return function (...t) { if (void 0 === t[0]) { for (let t = 0; t < this.length; t += 1)Kt.indexOf(e) < 0 && (e in this[t] ? this[t][e]() : Xt(this[t]).trigger(e)); return this } return this.on(e, ...t) } } Zt("click"), Zt("blur"), Zt("focus"), Zt("focusin"), Zt("focusout"), Zt("keyup"), Zt("keydown"), Zt("keypress"), Zt("submit"), Zt("change"), Zt("mousedown"), Zt("mousemove"), Zt("mouseup"), Zt("mouseenter"), Zt("mouseleave"), Zt("mouseout"), Zt("mouseover"), Zt("touchstart"), Zt("touchend"), Zt("touchmove"), Zt("resize"), Zt("scroll"); const Jt = { addClass: function (...e) { const t = Wt(e.map((e => e.split(" ")))); return this.forEach((e => { e.classList.add(...t) })), this }, removeClass: function (...e) { const t = Wt(e.map((e => e.split(" ")))); return this.forEach((e => { e.classList.remove(...t) })), this }, hasClass: function (...e) { const t = Wt(e.map((e => e.split(" ")))); return Yt(this, (e => t.filter((t => e.classList.contains(t))).length > 0)).length > 0 }, toggleClass: function (...e) { const t = Wt(e.map((e => e.split(" ")))); this.forEach((e => { t.forEach((t => { e.classList.toggle(t) })) })) }, attr: function (e, t) { if (1 === arguments.length && "string" == typeof e) return this[0] ? this[0].getAttribute(e) : void 0; for (let i = 0; i < this.length; i += 1)if (2 === arguments.length) this[i].setAttribute(e, t); else for (const t in e) this[i][t] = e[t], this[i].setAttribute(t, e[t]); return this }, removeAttr: function (e) { for (let t = 0; t < this.length; t += 1)this[t].removeAttribute(e); return this }, transform: function (e) { for (let t = 0; t < this.length; t += 1)this[t].style.transform = e; return this }, transition: function (e) { for (let t = 0; t < this.length; t += 1)this[t].style.transitionDuration = "string" != typeof e ? `${e}ms` : e; return this }, on: function (...e) { let [t, i, s, n] = e; function r(e) { const t = e.target; if (!t) return; const n = e.target.dom7EventData || []; if (n.indexOf(e) < 0 && n.unshift(e), Xt(t).is(i)) s.apply(t, n); else { const e = Xt(t).parents(); for (let t = 0; t < e.length; t += 1)Xt(e[t]).is(i) && s.apply(e[t], n) } } function o(e) { const t = e && e.target && e.target.dom7EventData || []; t.indexOf(e) < 0 && t.unshift(e), s.apply(this, t) } "function" == typeof e[1] && ([t, s, n] = e, i = void 0), n || (n = !1); const a = t.split(" "); let l; for (let e = 0; e < this.length; e += 1) { const t = this[e]; if (i) for (l = 0; l < a.length; l += 1) { const e = a[l]; t.dom7LiveListeners || (t.dom7LiveListeners = {}), t.dom7LiveListeners[e] || (t.dom7LiveListeners[e] = []), t.dom7LiveListeners[e].push({ listener: s, proxyListener: r }), t.addEventListener(e, r, n) } else for (l = 0; l < a.length; l += 1) { const e = a[l]; t.dom7Listeners || (t.dom7Listeners = {}), t.dom7Listeners[e] || (t.dom7Listeners[e] = []), t.dom7Listeners[e].push({ listener: s, proxyListener: o }), t.addEventListener(e, o, n) } } return this }, off: function (...e) { let [t, i, s, n] = e; "function" == typeof e[1] && ([t, s, n] = e, i = void 0), n || (n = !1); const r = t.split(" "); for (let e = 0; e < r.length; e += 1) { const t = r[e]; for (let e = 0; e < this.length; e += 1) { const r = this[e]; let o; if (!i && r.dom7Listeners ? o = r.dom7Listeners[t] : i && r.dom7LiveListeners && (o = r.dom7LiveListeners[t]), o && o.length) for (let e = o.length - 1; e >= 0; e -= 1) { const i = o[e]; s && i.listener === s || s && i.listener && i.listener.dom7proxy && i.listener.dom7proxy === s ? (r.removeEventListener(t, i.proxyListener, n), o.splice(e, 1)) : s || (r.removeEventListener(t, i.proxyListener, n), o.splice(e, 1)) } } } return this }, trigger: function (...e) { const t = Rt(), i = e[0].split(" "), s = e[1]; for (let n = 0; n < i.length; n += 1) { const r = i[n]; for (let i = 0; i < this.length; i += 1) { const n = this[i]; if (t.CustomEvent) { const i = new t.CustomEvent(r, { detail: s, bubbles: !0, cancelable: !0 }); n.dom7EventData = e.filter(((e, t) => t > 0)), n.dispatchEvent(i), n.dom7EventData = [], delete n.dom7EventData } } } return this }, transitionEnd: function (e) { const t = this; return e && t.on("transitionend", (function i(s) { s.target === this && (e.call(this, s), t.off("transitionend", i)) })), this }, outerWidth: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetWidth + parseFloat(e.getPropertyValue("margin-right")) + parseFloat(e.getPropertyValue("margin-left")) } return this[0].offsetWidth } return null }, outerHeight: function (e) { if (this.length > 0) { if (e) { const e = this.styles(); return this[0].offsetHeight + parseFloat(e.getPropertyValue("margin-top")) + parseFloat(e.getPropertyValue("margin-bottom")) } return this[0].offsetHeight } return null }, styles: function () { const e = Rt(); return this[0] ? e.getComputedStyle(this[0], null) : {} }, offset: function () { if (this.length > 0) { const e = Rt(), t = qt(), i = this[0], s = i.getBoundingClientRect(), n = t.body, r = i.clientTop || n.clientTop || 0, o = i.clientLeft || n.clientLeft || 0, a = i === e ? e.scrollY : i.scrollTop, l = i === e ? e.scrollX : i.scrollLeft; return { top: s.top + a - r, left: s.left + l - o } } return null }, css: function (e, t) { const i = Rt(); let s; if (1 === arguments.length) { if ("string" != typeof e) { for (s = 0; s < this.length; s += 1)for (const t in e) this[s].style[t] = e[t]; return this } if (this[0]) return i.getComputedStyle(this[0], null).getPropertyValue(e) } if (2 === arguments.length && "string" == typeof e) { for (s = 0; s < this.length; s += 1)this[s].style[e] = t; return this } return this }, each: function (e) { return e ? (this.forEach(((t, i) => { e.apply(t, [t, i]) })), this) : this }, html: function (e) { if (void 0 === e) return this[0] ? this[0].innerHTML : null; for (let t = 0; t < this.length; t += 1)this[t].innerHTML = e; return this }, text: function (e) { if (void 0 === e) return this[0] ? this[0].textContent.trim() : null; for (let t = 0; t < this.length; t += 1)this[t].textContent = e; return this }, is: function (e) { const t = Rt(), i = qt(), s = this[0]; let n, r; if (!s || void 0 === e) return !1; if ("string" == typeof e) { if (s.matches) return s.matches(e); if (s.webkitMatchesSelector) return s.webkitMatchesSelector(e); if (s.msMatchesSelector) return s.msMatchesSelector(e); for (n = Xt(e), r = 0; r < n.length; r += 1)if (n[r] === s) return !0; return !1 } if (e === i) return s === i; if (e === t) return s === t; if (e.nodeType || e instanceof Ut) { for (n = e.nodeType ? [e] : e, r = 0; r < n.length; r += 1)if (n[r] === s) return !0; return !1 } return !1 }, index: function () { let e, t = this[0]; if (t) { for (e = 0; null !== (t = t.previousSibling);)1 === t.nodeType && (e += 1); return e } }, eq: function (e) { if (void 0 === e) return this; const t = this.length; if (e > t - 1) return Xt([]); if (e < 0) { const i = t + e; return Xt(i < 0 ? [] : [this[i]]) } return Xt([this[e]]) }, append: function (...e) { let t; const i = qt(); for (let s = 0; s < e.length; s += 1) { t = e[s]; for (let e = 0; e < this.length; e += 1)if ("string" == typeof t) { const s = i.createElement("div"); for (s.innerHTML = t; s.firstChild;)this[e].appendChild(s.firstChild) } else if (t instanceof Ut) for (let i = 0; i < t.length; i += 1)this[e].appendChild(t[i]); else this[e].appendChild(t) } return this }, prepend: function (e) { const t = qt(); let i, s; for (i = 0; i < this.length; i += 1)if ("string" == typeof e) { const n = t.createElement("div"); for (n.innerHTML = e, s = n.childNodes.length - 1; s >= 0; s -= 1)this[i].insertBefore(n.childNodes[s], this[i].childNodes[0]) } else if (e instanceof Ut) for (s = 0; s < e.length; s += 1)this[i].insertBefore(e[s], this[i].childNodes[0]); else this[i].insertBefore(e, this[i].childNodes[0]); return this }, next: function (e) { return this.length > 0 ? e ? this[0].nextElementSibling && Xt(this[0].nextElementSibling).is(e) ? Xt([this[0].nextElementSibling]) : Xt([]) : this[0].nextElementSibling ? Xt([this[0].nextElementSibling]) : Xt([]) : Xt([]) }, nextAll: function (e) { const t = []; let i = this[0]; if (!i) return Xt([]); for (; i.nextElementSibling;) { const s = i.nextElementSibling; e ? Xt(s).is(e) && t.push(s) : t.push(s), i = s } return Xt(t) }, prev: function (e) { if (this.length > 0) { const t = this[0]; return e ? t.previousElementSibling && Xt(t.previousElementSibling).is(e) ? Xt([t.previousElementSibling]) : Xt([]) : t.previousElementSibling ? Xt([t.previousElementSibling]) : Xt([]) } return Xt([]) }, prevAll: function (e) { const t = []; let i = this[0]; if (!i) return Xt([]); for (; i.previousElementSibling;) { const s = i.previousElementSibling; e ? Xt(s).is(e) && t.push(s) : t.push(s), i = s } return Xt(t) }, parent: function (e) { const t = []; for (let i = 0; i < this.length; i += 1)null !== this[i].parentNode && (e ? Xt(this[i].parentNode).is(e) && t.push(this[i].parentNode) : t.push(this[i].parentNode)); return Xt(t) }, parents: function (e) { const t = []; for (let i = 0; i < this.length; i += 1) { let s = this[i].parentNode; for (; s;)e ? Xt(s).is(e) && t.push(s) : t.push(s), s = s.parentNode } return Xt(t) }, closest: function (e) { let t = this; return void 0 === e ? Xt([]) : (t.is(e) || (t = t.parents(e).eq(0)), t) }, find: function (e) { const t = []; for (let i = 0; i < this.length; i += 1) { const s = this[i].querySelectorAll(e); for (let e = 0; e < s.length; e += 1)t.push(s[e]) } return Xt(t) }, children: function (e) { const t = []; for (let i = 0; i < this.length; i += 1) { const s = this[i].children; for (let i = 0; i < s.length; i += 1)e && !Xt(s[i]).is(e) || t.push(s[i]) } return Xt(t) }, filter: function (e) { return Xt(Yt(this, e)) }, remove: function () { for (let e = 0; e < this.length; e += 1)this[e].parentNode && this[e].parentNode.removeChild(this[e]); return this } }; Object.keys(Jt).forEach((e => { Object.defineProperty(Xt.fn, e, { value: Jt[e], writable: !0 }) })); const Qt = Xt; function ei(e, t) { return void 0 === t && (t = 0), setTimeout(e, t) } function ti() { return Date.now() } function ii(e, t) { void 0 === t && (t = "x"); const i = Rt(); let s, n, r; const o = function (e) { const t = Rt(); let i; return t.getComputedStyle && (i = t.getComputedStyle(e, null)), !i && e.currentStyle && (i = e.currentStyle), i || (i = e.style), i }(e); return i.WebKitCSSMatrix ? (n = o.transform || o.webkitTransform, n.split(",").length > 6 && (n = n.split(", ").map((e => e.replace(",", "."))).join(", ")), r = new i.WebKitCSSMatrix("none" === n ? "" : n)) : (r = o.MozTransform || o.OTransform || o.MsTransform || o.msTransform || o.transform || o.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), s = r.toString().split(",")), "x" === t && (n = i.WebKitCSSMatrix ? r.m41 : 16 === s.length ? parseFloat(s[12]) : parseFloat(s[4])), "y" === t && (n = i.WebKitCSSMatrix ? r.m42 : 16 === s.length ? parseFloat(s[13]) : parseFloat(s[5])), n || 0 } function si(e) { return "object" == typeof e && null !== e && e.constructor && "Object" === Object.prototype.toString.call(e).slice(8, -1) } function ni() { const e = Object(arguments.length <= 0 ? void 0 : arguments[0]), t = ["__proto__", "constructor", "prototype"]; for (let s = 1; s < arguments.length; s += 1) { const n = s < 0 || arguments.length <= s ? void 0 : arguments[s]; if (null != n && (i = n, !("undefined" != typeof window && void 0 !== window.HTMLElement ? i instanceof HTMLElement : i && (1 === i.nodeType || 11 === i.nodeType)))) { const i = Object.keys(Object(n)).filter((e => t.indexOf(e) < 0)); for (let t = 0, s = i.length; t < s; t += 1) { const s = i[t], r = Object.getOwnPropertyDescriptor(n, s); void 0 !== r && r.enumerable && (si(e[s]) && si(n[s]) ? n[s].__swiper__ ? e[s] = n[s] : ni(e[s], n[s]) : !si(e[s]) && si(n[s]) ? (e[s] = {}, n[s].__swiper__ ? e[s] = n[s] : ni(e[s], n[s])) : e[s] = n[s]) } } } var i; return e } function ri(e, t, i) { e.style.setProperty(t, i) } function oi(e) { let { swiper: t, targetPosition: i, side: s } = e; const n = Rt(), r = -t.translate; let o, a = null; const l = t.params.speed; t.wrapperEl.style.scrollSnapType = "none", n.cancelAnimationFrame(t.cssModeFrameID); const d = i > r ? "next" : "prev", c = (e, t) => "next" === d && e >= t || "prev" === d && e <= t, u = () => { o = (new Date).getTime(), null === a && (a = o); const e = Math.max(Math.min((o - a) / l, 1), 0), d = .5 - Math.cos(e * Math.PI) / 2; let h = r + d * (i - r); if (c(h, i) && (h = i), t.wrapperEl.scrollTo({ [s]: h }), c(h, i)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout((() => { t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({ [s]: h }) })), void n.cancelAnimationFrame(t.cssModeFrameID); t.cssModeFrameID = n.requestAnimationFrame(u) }; u() } let ai, li, di; function ci() { return ai || (ai = function () { const e = Rt(), t = qt(); return { smoothScroll: t.documentElement && "scrollBehavior" in t.documentElement.style, touch: !!("ontouchstart" in e || e.DocumentTouch && t instanceof e.DocumentTouch), passiveListener: function () { let t = !1; try { const i = Object.defineProperty({}, "passive", { get() { t = !0 } }); e.addEventListener("testPassiveListener", null, i) } catch (e) { } return t }(), gestures: "ongesturestart" in e } }()), ai } function ui(e) { return void 0 === e && (e = {}), li || (li = function (e) { let { userAgent: t } = void 0 === e ? {} : e; const i = ci(), s = Rt(), n = s.navigator.platform, r = t || s.navigator.userAgent, o = { ios: !1, android: !1 }, a = s.screen.width, l = s.screen.height, d = r.match(/(Android);?[\s\/]+([\d.]+)?/); let c = r.match(/(iPad).*OS\s([\d_]+)/); const u = r.match(/(iPod)(.*OS\s([\d_]+))?/), h = !c && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/), p = "Win32" === n; let f = "MacIntel" === n; return !c && f && i.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${a}x${l}`) >= 0 && (c = r.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), f = !1), d && !p && (o.os = "android", o.android = !0), (c || h || u) && (o.os = "ios", o.ios = !0), o }(e)), li } function hi() { return di || (di = function () { const e = Rt(); return { isSafari: function () { const t = e.navigator.userAgent.toLowerCase(); return t.indexOf("safari") >= 0 && t.indexOf("chrome") < 0 && t.indexOf("android") < 0 }(), isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(e.navigator.userAgent) } }()), di } const pi = { on(e, t, i) { const s = this; if (!s.eventsListeners || s.destroyed) return s; if ("function" != typeof t) return s; const n = i ? "unshift" : "push"; return e.split(" ").forEach((e => { s.eventsListeners[e] || (s.eventsListeners[e] = []), s.eventsListeners[e][n](t) })), s }, once(e, t, i) { const s = this; if (!s.eventsListeners || s.destroyed) return s; if ("function" != typeof t) return s; function n() { s.off(e, n), n.__emitterProxy && delete n.__emitterProxy; for (var i = arguments.length, r = new Array(i), o = 0; o < i; o++)r[o] = arguments[o]; t.apply(s, r) } return n.__emitterProxy = t, s.on(e, n, i) }, onAny(e, t) { const i = this; if (!i.eventsListeners || i.destroyed) return i; if ("function" != typeof e) return i; const s = t ? "unshift" : "push"; return i.eventsAnyListeners.indexOf(e) < 0 && i.eventsAnyListeners[s](e), i }, offAny(e) { const t = this; if (!t.eventsListeners || t.destroyed) return t; if (!t.eventsAnyListeners) return t; const i = t.eventsAnyListeners.indexOf(e); return i >= 0 && t.eventsAnyListeners.splice(i, 1), t }, off(e, t) { const i = this; return !i.eventsListeners || i.destroyed ? i : i.eventsListeners ? (e.split(" ").forEach((e => { void 0 === t ? i.eventsListeners[e] = [] : i.eventsListeners[e] && i.eventsListeners[e].forEach(((s, n) => { (s === t || s.__emitterProxy && s.__emitterProxy === t) && i.eventsListeners[e].splice(n, 1) })) })), i) : i }, emit() { const e = this; if (!e.eventsListeners || e.destroyed) return e; if (!e.eventsListeners) return e; let t, i, s; for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)r[o] = arguments[o]; "string" == typeof r[0] || Array.isArray(r[0]) ? (t = r[0], i = r.slice(1, r.length), s = e) : (t = r[0].events, i = r[0].data, s = r[0].context || e), i.unshift(s); return (Array.isArray(t) ? t : t.split(" ")).forEach((t => { e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => { e.apply(s, [t, ...i]) })), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((e => { e.apply(s, i) })) })), e } }; const fi = { updateSize: function () { const e = this; let t, i; const s = e.$el; t = void 0 !== e.params.width && null !== e.params.width ? e.params.width : s[0].clientWidth, i = void 0 !== e.params.height && null !== e.params.height ? e.params.height : s[0].clientHeight, 0 === t && e.isHorizontal() || 0 === i && e.isVertical() || (t = t - parseInt(s.css("padding-left") || 0, 10) - parseInt(s.css("padding-right") || 0, 10), i = i - parseInt(s.css("padding-top") || 0, 10) - parseInt(s.css("padding-bottom") || 0, 10), Number.isNaN(t) && (t = 0), Number.isNaN(i) && (i = 0), Object.assign(e, { width: t, height: i, size: e.isHorizontal() ? t : i })) }, updateSlides: function () { const e = this; function t(t) { return e.isHorizontal() ? t : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[t] } function i(e, i) { return parseFloat(e.getPropertyValue(t(i)) || 0) } const s = e.params, { $wrapperEl: n, size: r, rtlTranslate: o, wrongRTL: a } = e, l = e.virtual && s.virtual.enabled, d = l ? e.virtual.slides.length : e.slides.length, c = n.children(`.${e.params.slideClass}`), u = l ? e.virtual.slides.length : c.length; let h = []; const p = [], f = []; let m = s.slidesOffsetBefore; "function" == typeof m && (m = s.slidesOffsetBefore.call(e)); let g = s.slidesOffsetAfter; "function" == typeof g && (g = s.slidesOffsetAfter.call(e)); const v = e.snapGrid.length, y = e.slidesGrid.length; let b = s.spaceBetween, w = -m, S = 0, x = 0; if (void 0 === r) return; "string" == typeof b && b.indexOf("%") >= 0 && (b = parseFloat(b.replace("%", "")) / 100 * r), e.virtualSize = -b, o ? c.css({ marginLeft: "", marginBottom: "", marginTop: "" }) : c.css({ marginRight: "", marginBottom: "", marginTop: "" }), s.centeredSlides && s.cssMode && (ri(e.wrapperEl, "--swiper-centered-offset-before", ""), ri(e.wrapperEl, "--swiper-centered-offset-after", "")); const C = s.grid && s.grid.rows > 1 && e.grid; let E; C && e.grid.initSlides(u); const T = "auto" === s.slidesPerView && s.breakpoints && Object.keys(s.breakpoints).filter((e => void 0 !== s.breakpoints[e].slidesPerView)).length > 0; for (let n = 0; n < u; n += 1) { E = 0; const o = c.eq(n); if (C && e.grid.updateSlide(n, o, u, t), "none" !== o.css("display")) { if ("auto" === s.slidesPerView) { T && (c[n].style[t("width")] = ""); const r = getComputedStyle(o[0]), a = o[0].style.transform, l = o[0].style.webkitTransform; if (a && (o[0].style.transform = "none"), l && (o[0].style.webkitTransform = "none"), s.roundLengths) E = e.isHorizontal() ? o.outerWidth(!0) : o.outerHeight(!0); else { const e = i(r, "width"), t = i(r, "padding-left"), s = i(r, "padding-right"), n = i(r, "margin-left"), a = i(r, "margin-right"), l = r.getPropertyValue("box-sizing"); if (l && "border-box" === l) E = e + n + a; else { const { clientWidth: i, offsetWidth: r } = o[0]; E = e + t + s + n + a + (r - i) } } a && (o[0].style.transform = a), l && (o[0].style.webkitTransform = l), s.roundLengths && (E = Math.floor(E)) } else E = (r - (s.slidesPerView - 1) * b) / s.slidesPerView, s.roundLengths && (E = Math.floor(E)), c[n] && (c[n].style[t("width")] = `${E}px`); c[n] && (c[n].swiperSlideSize = E), f.push(E), s.centeredSlides ? (w = w + E / 2 + S / 2 + b, 0 === S && 0 !== n && (w = w - r / 2 - b), 0 === n && (w = w - r / 2 - b), Math.abs(w) < .001 && (w = 0), s.roundLengths && (w = Math.floor(w)), x % s.slidesPerGroup == 0 && h.push(w), p.push(w)) : (s.roundLengths && (w = Math.floor(w)), (x - Math.min(e.params.slidesPerGroupSkip, x)) % e.params.slidesPerGroup == 0 && h.push(w), p.push(w), w = w + E + b), e.virtualSize += E + b, S = E, x += 1 } } if (e.virtualSize = Math.max(e.virtualSize, r) + g, o && a && ("slide" === s.effect || "coverflow" === s.effect) && n.css({ width: `${e.virtualSize + s.spaceBetween}px` }), s.setWrapperSize && n.css({ [t("width")]: `${e.virtualSize + s.spaceBetween}px` }), C && e.grid.updateWrapperSize(E, h, t), !s.centeredSlides) { const t = []; for (let i = 0; i < h.length; i += 1) { let n = h[i]; s.roundLengths && (n = Math.floor(n)), h[i] <= e.virtualSize - r && t.push(n) } h = t, Math.floor(e.virtualSize - r) - Math.floor(h[h.length - 1]) > 1 && h.push(e.virtualSize - r) } if (0 === h.length && (h = [0]), 0 !== s.spaceBetween) { const i = e.isHorizontal() && o ? "marginLeft" : t("marginRight"); c.filter(((e, t) => !s.cssMode || t !== c.length - 1)).css({ [i]: `${b}px` }) } if (s.centeredSlides && s.centeredSlidesBounds) { let e = 0; f.forEach((t => { e += t + (s.spaceBetween ? s.spaceBetween : 0) })), e -= s.spaceBetween; const t = e - r; h = h.map((e => e < 0 ? -m : e > t ? t + g : e)) } if (s.centerInsufficientSlides) { let e = 0; if (f.forEach((t => { e += t + (s.spaceBetween ? s.spaceBetween : 0) })), e -= s.spaceBetween, e < r) { const t = (r - e) / 2; h.forEach(((e, i) => { h[i] = e - t })), p.forEach(((e, i) => { p[i] = e + t })) } } if (Object.assign(e, { slides: c, snapGrid: h, slidesGrid: p, slidesSizesGrid: f }), s.centeredSlides && s.cssMode && !s.centeredSlidesBounds) { ri(e.wrapperEl, "--swiper-centered-offset-before", -h[0] + "px"), ri(e.wrapperEl, "--swiper-centered-offset-after", e.size / 2 - f[f.length - 1] / 2 + "px"); const t = -e.snapGrid[0], i = -e.slidesGrid[0]; e.snapGrid = e.snapGrid.map((e => e + t)), e.slidesGrid = e.slidesGrid.map((e => e + i)) } if (u !== d && e.emit("slidesLengthChange"), h.length !== v && (e.params.watchOverflow && e.checkOverflow(), e.emit("snapGridLengthChange")), p.length !== y && e.emit("slidesGridLengthChange"), s.watchSlidesProgress && e.updateSlidesOffset(), !(l || s.cssMode || "slide" !== s.effect && "fade" !== s.effect)) { const t = `${s.containerModifierClass}backface-hidden`, i = e.$el.hasClass(t); u <= s.maxBackfaceHiddenSlides ? i || e.$el.addClass(t) : i && e.$el.removeClass(t) } }, updateAutoHeight: function (e) { const t = this, i = [], s = t.virtual && t.params.virtual.enabled; let n, r = 0; "number" == typeof e ? t.setTransition(e) : !0 === e && t.setTransition(t.params.speed); const o = e => s ? t.slides.filter((t => parseInt(t.getAttribute("data-swiper-slide-index"), 10) === e))[0] : t.slides.eq(e)[0]; if ("auto" !== t.params.slidesPerView && t.params.slidesPerView > 1) if (t.params.centeredSlides) t.visibleSlides.each((e => { i.push(e) })); else for (n = 0; n < Math.ceil(t.params.slidesPerView); n += 1) { const e = t.activeIndex + n; if (e > t.slides.length && !s) break; i.push(o(e)) } else i.push(o(t.activeIndex)); for (n = 0; n < i.length; n += 1)if (void 0 !== i[n]) { const e = i[n].offsetHeight; r = e > r ? e : r } (r || 0 === r) && t.$wrapperEl.css("height", `${r}px`) }, updateSlidesOffset: function () { const e = this, t = e.slides; for (let i = 0; i < t.length; i += 1)t[i].swiperSlideOffset = e.isHorizontal() ? t[i].offsetLeft : t[i].offsetTop }, updateSlidesProgress: function (e) { void 0 === e && (e = this && this.translate || 0); const t = this, i = t.params, { slides: s, rtlTranslate: n, snapGrid: r } = t; if (0 === s.length) return; void 0 === s[0].swiperSlideOffset && t.updateSlidesOffset(); let o = -e; n && (o = e), s.removeClass(i.slideVisibleClass), t.visibleSlidesIndexes = [], t.visibleSlides = []; for (let e = 0; e < s.length; e += 1) { const a = s[e]; let l = a.swiperSlideOffset; i.cssMode && i.centeredSlides && (l -= s[0].swiperSlideOffset); const d = (o + (i.centeredSlides ? t.minTranslate() : 0) - l) / (a.swiperSlideSize + i.spaceBetween), c = (o - r[0] + (i.centeredSlides ? t.minTranslate() : 0) - l) / (a.swiperSlideSize + i.spaceBetween), u = -(o - l), h = u + t.slidesSizesGrid[e]; (u >= 0 && u < t.size - 1 || h > 1 && h <= t.size || u <= 0 && h >= t.size) && (t.visibleSlides.push(a), t.visibleSlidesIndexes.push(e), s.eq(e).addClass(i.slideVisibleClass)), a.progress = n ? -d : d, a.originalProgress = n ? -c : c } t.visibleSlides = Qt(t.visibleSlides) }, updateProgress: function (e) { const t = this; if (void 0 === e) { const i = t.rtlTranslate ? -1 : 1; e = t && t.translate && t.translate * i || 0 } const i = t.params, s = t.maxTranslate() - t.minTranslate(); let { progress: n, isBeginning: r, isEnd: o } = t; const a = r, l = o; 0 === s ? (n = 0, r = !0, o = !0) : (n = (e - t.minTranslate()) / s, r = n <= 0, o = n >= 1), Object.assign(t, { progress: n, isBeginning: r, isEnd: o }), (i.watchSlidesProgress || i.centeredSlides && i.autoHeight) && t.updateSlidesProgress(e), r && !a && t.emit("reachBeginning toEdge"), o && !l && t.emit("reachEnd toEdge"), (a && !r || l && !o) && t.emit("fromEdge"), t.emit("progress", n) }, updateSlidesClasses: function () { const e = this, { slides: t, params: i, $wrapperEl: s, activeIndex: n, realIndex: r } = e, o = e.virtual && i.virtual.enabled; let a; t.removeClass(`${i.slideActiveClass} ${i.slideNextClass} ${i.slidePrevClass} ${i.slideDuplicateActiveClass} ${i.slideDuplicateNextClass} ${i.slideDuplicatePrevClass}`), a = o ? e.$wrapperEl.find(`.${i.slideClass}[data-swiper-slide-index="${n}"]`) : t.eq(n), a.addClass(i.slideActiveClass), i.loop && (a.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${r}"]`).addClass(i.slideDuplicateActiveClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${r}"]`).addClass(i.slideDuplicateActiveClass)); let l = a.nextAll(`.${i.slideClass}`).eq(0).addClass(i.slideNextClass); i.loop && 0 === l.length && (l = t.eq(0), l.addClass(i.slideNextClass)); let d = a.prevAll(`.${i.slideClass}`).eq(0).addClass(i.slidePrevClass); i.loop && 0 === d.length && (d = t.eq(-1), d.addClass(i.slidePrevClass)), i.loop && (l.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass), d.hasClass(i.slideDuplicateClass) ? s.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass) : s.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${d.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass)), e.emitSlidesClasses() }, updateActiveIndex: function (e) { const t = this, i = t.rtlTranslate ? t.translate : -t.translate, { slidesGrid: s, snapGrid: n, params: r, activeIndex: o, realIndex: a, snapIndex: l } = t; let d, c = e; if (void 0 === c) { for (let e = 0; e < s.length; e += 1)void 0 !== s[e + 1] ? i >= s[e] && i < s[e + 1] - (s[e + 1] - s[e]) / 2 ? c = e : i >= s[e] && i < s[e + 1] && (c = e + 1) : i >= s[e] && (c = e); r.normalizeSlideIndex && (c < 0 || void 0 === c) && (c = 0) } if (n.indexOf(i) >= 0) d = n.indexOf(i); else { const e = Math.min(r.slidesPerGroupSkip, c); d = e + Math.floor((c - e) / r.slidesPerGroup) } if (d >= n.length && (d = n.length - 1), c === o) return void (d !== l && (t.snapIndex = d, t.emit("snapIndexChange"))); const u = parseInt(t.slides.eq(c).attr("data-swiper-slide-index") || c, 10); Object.assign(t, { snapIndex: d, realIndex: u, previousIndex: o, activeIndex: c }), t.emit("activeIndexChange"), t.emit("snapIndexChange"), a !== u && t.emit("realIndexChange"), (t.initialized || t.params.runCallbacksOnInit) && t.emit("slideChange") }, updateClickedSlide: function (e) { const t = this, i = t.params, s = Qt(e).closest(`.${i.slideClass}`)[0]; let n, r = !1; if (s) for (let e = 0; e < t.slides.length; e += 1)if (t.slides[e] === s) { r = !0, n = e; break } if (!s || !r) return t.clickedSlide = void 0, void (t.clickedIndex = void 0); t.clickedSlide = s, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(Qt(s).attr("data-swiper-slide-index"), 10) : t.clickedIndex = n, i.slideToClickedSlide && void 0 !== t.clickedIndex && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } }; const mi = { getTranslate: function (e) { void 0 === e && (e = this.isHorizontal() ? "x" : "y"); const { params: t, rtlTranslate: i, translate: s, $wrapperEl: n } = this; if (t.virtualTranslate) return i ? -s : s; if (t.cssMode) return s; let r = ii(n[0], e); return i && (r = -r), r || 0 }, setTranslate: function (e, t) { const i = this, { rtlTranslate: s, params: n, $wrapperEl: r, wrapperEl: o, progress: a } = i; let l, d = 0, c = 0; i.isHorizontal() ? d = s ? -e : e : c = e, n.roundLengths && (d = Math.floor(d), c = Math.floor(c)), n.cssMode ? o[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -d : -c : n.virtualTranslate || r.transform(`translate3d(${d}px, ${c}px, 0px)`), i.previousTranslate = i.translate, i.translate = i.isHorizontal() ? d : c; const u = i.maxTranslate() - i.minTranslate(); l = 0 === u ? 0 : (e - i.minTranslate()) / u, l !== a && i.updateProgress(e), i.emit("setTranslate", i.translate, t) }, minTranslate: function () { return -this.snapGrid[0] }, maxTranslate: function () { return -this.snapGrid[this.snapGrid.length - 1] }, translateTo: function (e, t, i, s, n) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === i && (i = !0), void 0 === s && (s = !0); const r = this, { params: o, wrapperEl: a } = r; if (r.animating && o.preventInteractionOnTransition) return !1; const l = r.minTranslate(), d = r.maxTranslate(); let c; if (c = s && e > l ? l : s && e < d ? d : e, r.updateProgress(c), o.cssMode) { const e = r.isHorizontal(); if (0 === t) a[e ? "scrollLeft" : "scrollTop"] = -c; else { if (!r.support.smoothScroll) return oi({ swiper: r, targetPosition: -c, side: e ? "left" : "top" }), !0; a.scrollTo({ [e ? "left" : "top"]: -c, behavior: "smooth" }) } return !0 } return 0 === t ? (r.setTransition(0), r.setTranslate(c), i && (r.emit("beforeTransitionStart", t, n), r.emit("transitionEnd"))) : (r.setTransition(t), r.setTranslate(c), i && (r.emit("beforeTransitionStart", t, n), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, i && r.emit("transitionEnd")) }), r.$wrapperEl[0].addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onTranslateToWrapperTransitionEnd))), !0 } }; function gi(e) { let { swiper: t, runCallbacks: i, direction: s, step: n } = e; const { activeIndex: r, previousIndex: o } = t; let a = s; if (a || (a = r > o ? "next" : r < o ? "prev" : "reset"), t.emit(`transition${n}`), i && r !== o) { if ("reset" === a) return void t.emit(`slideResetTransition${n}`); t.emit(`slideChangeTransition${n}`), "next" === a ? t.emit(`slideNextTransition${n}`) : t.emit(`slidePrevTransition${n}`) } } const vi = { slideTo: function (e, t, i, s, n) { if (void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === i && (i = !0), "number" != typeof e && "string" != typeof e) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof e}] given.`); if ("string" == typeof e) { const t = parseInt(e, 10); if (!isFinite(t)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${e}] given.`); e = t } const r = this; let o = e; o < 0 && (o = 0); const { params: a, snapGrid: l, slidesGrid: d, previousIndex: c, activeIndex: u, rtlTranslate: h, wrapperEl: p, enabled: f } = r; if (r.animating && a.preventInteractionOnTransition || !f && !s && !n) return !1; const m = Math.min(r.params.slidesPerGroupSkip, o); let g = m + Math.floor((o - m) / r.params.slidesPerGroup); g >= l.length && (g = l.length - 1), (u || a.initialSlide || 0) === (c || 0) && i && r.emit("beforeSlideChangeStart"); const v = -l[g]; if (r.updateProgress(v), a.normalizeSlideIndex) for (let e = 0; e < d.length; e += 1) { const t = -Math.floor(100 * v), i = Math.floor(100 * d[e]), s = Math.floor(100 * d[e + 1]); void 0 !== d[e + 1] ? t >= i && t < s - (s - i) / 2 ? o = e : t >= i && t < s && (o = e + 1) : t >= i && (o = e) } if (r.initialized && o !== u) { if (!r.allowSlideNext && v < r.translate && v < r.minTranslate()) return !1; if (!r.allowSlidePrev && v > r.translate && v > r.maxTranslate() && (u || 0) !== o) return !1 } let y; if (y = o > u ? "next" : o < u ? "prev" : "reset", h && -v === r.translate || !h && v === r.translate) return r.updateActiveIndex(o), a.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), "slide" !== a.effect && r.setTranslate(v), "reset" !== y && (r.transitionStart(i, y), r.transitionEnd(i, y)), !1; if (a.cssMode) { const e = r.isHorizontal(), i = h ? v : -v; if (0 === t) { const t = r.virtual && r.params.virtual.enabled; t && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), p[e ? "scrollLeft" : "scrollTop"] = i, t && requestAnimationFrame((() => { r.wrapperEl.style.scrollSnapType = "", r._swiperImmediateVirtual = !1 })) } else { if (!r.support.smoothScroll) return oi({ swiper: r, targetPosition: i, side: e ? "left" : "top" }), !0; p.scrollTo({ [e ? "left" : "top"]: i, behavior: "smooth" }) } return !0 } return r.setTransition(t), r.setTranslate(v), r.updateActiveIndex(o), r.updateSlidesClasses(), r.emit("beforeTransitionStart", t, s), r.transitionStart(i, y), 0 === t ? r.transitionEnd(i, y) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function (e) { r && !r.destroyed && e.target === this && (r.$wrapperEl[0].removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].removeEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(i, y)) }), r.$wrapperEl[0].addEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.$wrapperEl[0].addEventListener("webkitTransitionEnd", r.onSlideToWrapperTransitionEnd)), !0 }, slideToLoop: function (e, t, i, s) { void 0 === e && (e = 0), void 0 === t && (t = this.params.speed), void 0 === i && (i = !0); const n = this; let r = e; return n.params.loop && (r += n.loopedSlides), n.slideTo(r, t, i, s) }, slideNext: function (e, t, i) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const s = this, { animating: n, enabled: r, params: o } = s; if (!r) return s; let a = o.slidesPerGroup; "auto" === o.slidesPerView && 1 === o.slidesPerGroup && o.slidesPerGroupAuto && (a = Math.max(s.slidesPerViewDynamic("current", !0), 1)); const l = s.activeIndex < o.slidesPerGroupSkip ? 1 : a; if (o.loop) { if (n && o.loopPreventsSlide) return !1; s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft } return o.rewind && s.isEnd ? s.slideTo(0, e, t, i) : s.slideTo(s.activeIndex + l, e, t, i) }, slidePrev: function (e, t, i) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0); const s = this, { params: n, animating: r, snapGrid: o, slidesGrid: a, rtlTranslate: l, enabled: d } = s; if (!d) return s; if (n.loop) { if (r && n.loopPreventsSlide) return !1; s.loopFix(), s._clientLeft = s.$wrapperEl[0].clientLeft } function c(e) { return e < 0 ? -Math.floor(Math.abs(e)) : Math.floor(e) } const u = c(l ? s.translate : -s.translate), h = o.map((e => c(e))); let p = o[h.indexOf(u) - 1]; if (void 0 === p && n.cssMode) { let e; o.forEach(((t, i) => { u >= t && (e = i) })), void 0 !== e && (p = o[e > 0 ? e - 1 : e]) } let f = 0; if (void 0 !== p && (f = a.indexOf(p), f < 0 && (f = s.activeIndex - 1), "auto" === n.slidesPerView && 1 === n.slidesPerGroup && n.slidesPerGroupAuto && (f = f - s.slidesPerViewDynamic("previous", !0) + 1, f = Math.max(f, 0))), n.rewind && s.isBeginning) { const n = s.params.virtual && s.params.virtual.enabled && s.virtual ? s.virtual.slides.length - 1 : s.slides.length - 1; return s.slideTo(n, e, t, i) } return s.slideTo(f, e, t, i) }, slideReset: function (e, t, i) { return void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), this.slideTo(this.activeIndex, e, t, i) }, slideToClosest: function (e, t, i, s) { void 0 === e && (e = this.params.speed), void 0 === t && (t = !0), void 0 === s && (s = .5); const n = this; let r = n.activeIndex; const o = Math.min(n.params.slidesPerGroupSkip, r), a = o + Math.floor((r - o) / n.params.slidesPerGroup), l = n.rtlTranslate ? n.translate : -n.translate; if (l >= n.snapGrid[a]) { const e = n.snapGrid[a]; l - e > (n.snapGrid[a + 1] - e) * s && (r += n.params.slidesPerGroup) } else { const e = n.snapGrid[a - 1]; l - e <= (n.snapGrid[a] - e) * s && (r -= n.params.slidesPerGroup) } return r = Math.max(r, 0), r = Math.min(r, n.slidesGrid.length - 1), n.slideTo(r, e, t, i) }, slideToClickedSlide: function () { const e = this, { params: t, $wrapperEl: i } = e, s = "auto" === t.slidesPerView ? e.slidesPerViewDynamic() : t.slidesPerView; let n, r = e.clickedIndex; if (t.loop) { if (e.animating) return; n = parseInt(Qt(e.clickedSlide).attr("data-swiper-slide-index"), 10), t.centeredSlides ? r < e.loopedSlides - s / 2 || r > e.slides.length - e.loopedSlides + s / 2 ? (e.loopFix(), r = i.children(`.${t.slideClass}[data-swiper-slide-index="${n}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), ei((() => { e.slideTo(r) }))) : e.slideTo(r) : r > e.slides.length - s ? (e.loopFix(), r = i.children(`.${t.slideClass}[data-swiper-slide-index="${n}"]:not(.${t.slideDuplicateClass})`).eq(0).index(), ei((() => { e.slideTo(r) }))) : e.slideTo(r) } else e.slideTo(r) } }; const yi = { loopCreate: function () { const e = this, t = qt(), { params: i, $wrapperEl: s } = e, n = s.children().length > 0 ? Qt(s.children()[0].parentNode) : s; n.children(`.${i.slideClass}.${i.slideDuplicateClass}`).remove(); let r = n.children(`.${i.slideClass}`); if (i.loopFillGroupWithBlank) { const e = i.slidesPerGroup - r.length % i.slidesPerGroup; if (e !== i.slidesPerGroup) { for (let s = 0; s < e; s += 1) { const e = Qt(t.createElement("div")).addClass(`${i.slideClass} ${i.slideBlankClass}`); n.append(e) } r = n.children(`.${i.slideClass}`) } } "auto" !== i.slidesPerView || i.loopedSlides || (i.loopedSlides = r.length), e.loopedSlides = Math.ceil(parseFloat(i.loopedSlides || i.slidesPerView, 10)), e.loopedSlides += i.loopAdditionalSlides, e.loopedSlides > r.length && (e.loopedSlides = r.length); const o = [], a = []; r.each(((t, i) => { const s = Qt(t); i < e.loopedSlides && a.push(t), i < r.length && i >= r.length - e.loopedSlides && o.push(t), s.attr("data-swiper-slide-index", i) })); for (let e = 0; e < a.length; e += 1)n.append(Qt(a[e].cloneNode(!0)).addClass(i.slideDuplicateClass)); for (let e = o.length - 1; e >= 0; e -= 1)n.prepend(Qt(o[e].cloneNode(!0)).addClass(i.slideDuplicateClass)) }, loopFix: function () { const e = this; e.emit("beforeLoopFix"); const { activeIndex: t, slides: i, loopedSlides: s, allowSlidePrev: n, allowSlideNext: r, snapGrid: o, rtlTranslate: a } = e; let l; e.allowSlidePrev = !0, e.allowSlideNext = !0; const d = -o[t] - e.getTranslate(); if (t < s) { l = i.length - 3 * s + t, l += s; e.slideTo(l, 0, !1, !0) && 0 !== d && e.setTranslate((a ? -e.translate : e.translate) - d) } else if (t >= i.length - s) { l = -i.length + t + s, l += s; e.slideTo(l, 0, !1, !0) && 0 !== d && e.setTranslate((a ? -e.translate : e.translate) - d) } e.allowSlidePrev = n, e.allowSlideNext = r, e.emit("loopFix") }, loopDestroy: function () { const { $wrapperEl: e, params: t, slides: i } = this; e.children(`.${t.slideClass}.${t.slideDuplicateClass},.${t.slideClass}.${t.slideBlankClass}`).remove(), i.removeAttr("data-swiper-slide-index") } }; function bi(e) { const t = this, i = qt(), s = Rt(), n = t.touchEventsData, { params: r, touches: o, enabled: a } = t; if (!a) return; if (t.animating && r.preventInteractionOnTransition) return; !t.animating && r.cssMode && r.loop && t.loopFix(); let l = e; l.originalEvent && (l = l.originalEvent); let d = Qt(l.target); if ("wrapper" === r.touchEventsTarget && !d.closest(t.wrapperEl).length) return; if (n.isTouchEvent = "touchstart" === l.type, !n.isTouchEvent && "which" in l && 3 === l.which) return; if (!n.isTouchEvent && "button" in l && l.button > 0) return; if (n.isTouched && n.isMoved) return; !!r.noSwipingClass && "" !== r.noSwipingClass && l.target && l.target.shadowRoot && e.path && e.path[0] && (d = Qt(e.path[0])); const c = r.noSwipingSelector ? r.noSwipingSelector : `.${r.noSwipingClass}`, u = !(!l.target || !l.target.shadowRoot); if (r.noSwiping && (u ? function (e, t) { return void 0 === t && (t = this), function t(i) { return i && i !== qt() && i !== Rt() ? (i.assignedSlot && (i = i.assignedSlot), i.closest(e) || t(i.getRootNode().host)) : null }(t) }(c, l.target) : d.closest(c)[0])) return void (t.allowClick = !0); if (r.swipeHandler && !d.closest(r.swipeHandler)[0]) return; o.currentX = "touchstart" === l.type ? l.targetTouches[0].pageX : l.pageX, o.currentY = "touchstart" === l.type ? l.targetTouches[0].pageY : l.pageY; const h = o.currentX, p = o.currentY, f = r.edgeSwipeDetection || r.iOSEdgeSwipeDetection, m = r.edgeSwipeThreshold || r.iOSEdgeSwipeThreshold; if (f && (h <= m || h >= s.innerWidth - m)) { if ("prevent" !== f) return; e.preventDefault() } if (Object.assign(n, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), o.startX = h, o.startY = p, n.touchStartTime = ti(), t.allowClick = !0, t.updateSize(), t.swipeDirection = void 0, r.threshold > 0 && (n.allowThresholdMove = !1), "touchstart" !== l.type) { let e = !0; d.is(n.focusableElements) && (e = !1, "SELECT" === d[0].nodeName && (n.isTouched = !1)), i.activeElement && Qt(i.activeElement).is(n.focusableElements) && i.activeElement !== d[0] && i.activeElement.blur(); const s = e && t.allowTouchMove && r.touchStartPreventDefault; !r.touchStartForcePreventDefault && !s || d[0].isContentEditable || l.preventDefault() } t.params.freeMode && t.params.freeMode.enabled && t.freeMode && t.animating && !r.cssMode && t.freeMode.onTouchStart(), t.emit("touchStart", l) } function wi(e) { const t = qt(), i = this, s = i.touchEventsData, { params: n, touches: r, rtlTranslate: o, enabled: a } = i; if (!a) return; let l = e; if (l.originalEvent && (l = l.originalEvent), !s.isTouched) return void (s.startMoving && s.isScrolling && i.emit("touchMoveOpposite", l)); if (s.isTouchEvent && "touchmove" !== l.type) return; const d = "touchmove" === l.type && l.targetTouches && (l.targetTouches[0] || l.changedTouches[0]), c = "touchmove" === l.type ? d.pageX : l.pageX, u = "touchmove" === l.type ? d.pageY : l.pageY; if (l.preventedByNestedSwiper) return r.startX = c, void (r.startY = u); if (!i.allowTouchMove) return Qt(l.target).is(s.focusableElements) || (i.allowClick = !1), void (s.isTouched && (Object.assign(r, { startX: c, startY: u, currentX: c, currentY: u }), s.touchStartTime = ti())); if (s.isTouchEvent && n.touchReleaseOnEdges && !n.loop) if (i.isVertical()) { if (u < r.startY && i.translate <= i.maxTranslate() || u > r.startY && i.translate >= i.minTranslate()) return s.isTouched = !1, void (s.isMoved = !1) } else if (c < r.startX && i.translate <= i.maxTranslate() || c > r.startX && i.translate >= i.minTranslate()) return; if (s.isTouchEvent && t.activeElement && l.target === t.activeElement && Qt(l.target).is(s.focusableElements)) return s.isMoved = !0, void (i.allowClick = !1); if (s.allowTouchCallbacks && i.emit("touchMove", l), l.targetTouches && l.targetTouches.length > 1) return; r.currentX = c, r.currentY = u; const h = r.currentX - r.startX, p = r.currentY - r.startY; if (i.params.threshold && Math.sqrt(h ** 2 + p ** 2) < i.params.threshold) return; if (void 0 === s.isScrolling) { let e; i.isHorizontal() && r.currentY === r.startY || i.isVertical() && r.currentX === r.startX ? s.isScrolling = !1 : h * h + p * p >= 25 && (e = 180 * Math.atan2(Math.abs(p), Math.abs(h)) / Math.PI, s.isScrolling = i.isHorizontal() ? e > n.touchAngle : 90 - e > n.touchAngle) } if (s.isScrolling && i.emit("touchMoveOpposite", l), void 0 === s.startMoving && (r.currentX === r.startX && r.currentY === r.startY || (s.startMoving = !0)), s.isScrolling) return void (s.isTouched = !1); if (!s.startMoving) return; i.allowClick = !1, !n.cssMode && l.cancelable && l.preventDefault(), n.touchMoveStopPropagation && !n.nested && l.stopPropagation(), s.isMoved || (n.loop && !n.cssMode && i.loopFix(), s.startTranslate = i.getTranslate(), i.setTransition(0), i.animating && i.$wrapperEl.trigger("webkitTransitionEnd transitionend"), s.allowMomentumBounce = !1, !n.grabCursor || !0 !== i.allowSlideNext && !0 !== i.allowSlidePrev || i.setGrabCursor(!0), i.emit("sliderFirstMove", l)), i.emit("sliderMove", l), s.isMoved = !0; let f = i.isHorizontal() ? h : p; r.diff = f, f *= n.touchRatio, o && (f = -f), i.swipeDirection = f > 0 ? "prev" : "next", s.currentTranslate = f + s.startTranslate; let m = !0, g = n.resistanceRatio; if (n.touchReleaseOnEdges && (g = 0), f > 0 && s.currentTranslate > i.minTranslate() ? (m = !1, n.resistance && (s.currentTranslate = i.minTranslate() - 1 + (-i.minTranslate() + s.startTranslate + f) ** g)) : f < 0 && s.currentTranslate < i.maxTranslate() && (m = !1, n.resistance && (s.currentTranslate = i.maxTranslate() + 1 - (i.maxTranslate() - s.startTranslate - f) ** g)), m && (l.preventedByNestedSwiper = !0), !i.allowSlideNext && "next" === i.swipeDirection && s.currentTranslate < s.startTranslate && (s.currentTranslate = s.startTranslate), !i.allowSlidePrev && "prev" === i.swipeDirection && s.currentTranslate > s.startTranslate && (s.currentTranslate = s.startTranslate), i.allowSlidePrev || i.allowSlideNext || (s.currentTranslate = s.startTranslate), n.threshold > 0) { if (!(Math.abs(f) > n.threshold || s.allowThresholdMove)) return void (s.currentTranslate = s.startTranslate); if (!s.allowThresholdMove) return s.allowThresholdMove = !0, r.startX = r.currentX, r.startY = r.currentY, s.currentTranslate = s.startTranslate, void (r.diff = i.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY) } n.followFinger && !n.cssMode && ((n.freeMode && n.freeMode.enabled && i.freeMode || n.watchSlidesProgress) && (i.updateActiveIndex(), i.updateSlidesClasses()), i.params.freeMode && n.freeMode.enabled && i.freeMode && i.freeMode.onTouchMove(), i.updateProgress(s.currentTranslate), i.setTranslate(s.currentTranslate)) } function Si(e) { const t = this, i = t.touchEventsData, { params: s, touches: n, rtlTranslate: r, slidesGrid: o, enabled: a } = t; if (!a) return; let l = e; if (l.originalEvent && (l = l.originalEvent), i.allowTouchCallbacks && t.emit("touchEnd", l), i.allowTouchCallbacks = !1, !i.isTouched) return i.isMoved && s.grabCursor && t.setGrabCursor(!1), i.isMoved = !1, void (i.startMoving = !1); s.grabCursor && i.isMoved && i.isTouched && (!0 === t.allowSlideNext || !0 === t.allowSlidePrev) && t.setGrabCursor(!1); const d = ti(), c = d - i.touchStartTime; if (t.allowClick) { const e = l.path || l.composedPath && l.composedPath(); t.updateClickedSlide(e && e[0] || l.target), t.emit("tap click", l), c < 300 && d - i.lastClickTime < 300 && t.emit("doubleTap doubleClick", l) } if (i.lastClickTime = ti(), ei((() => { t.destroyed || (t.allowClick = !0) })), !i.isTouched || !i.isMoved || !t.swipeDirection || 0 === n.diff || i.currentTranslate === i.startTranslate) return i.isTouched = !1, i.isMoved = !1, void (i.startMoving = !1); let u; if (i.isTouched = !1, i.isMoved = !1, i.startMoving = !1, u = s.followFinger ? r ? t.translate : -t.translate : -i.currentTranslate, s.cssMode) return; if (t.params.freeMode && s.freeMode.enabled) return void t.freeMode.onTouchEnd({ currentPos: u }); let h = 0, p = t.slidesSizesGrid[0]; for (let e = 0; e < o.length; e += e < s.slidesPerGroupSkip ? 1 : s.slidesPerGroup) { const t = e < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; void 0 !== o[e + t] ? u >= o[e] && u < o[e + t] && (h = e, p = o[e + t] - o[e]) : u >= o[e] && (h = e, p = o[o.length - 1] - o[o.length - 2]) } let f = null, m = null; s.rewind && (t.isBeginning ? m = t.params.virtual && t.params.virtual.enabled && t.virtual ? t.virtual.slides.length - 1 : t.slides.length - 1 : t.isEnd && (f = 0)); const g = (u - o[h]) / p, v = h < s.slidesPerGroupSkip - 1 ? 1 : s.slidesPerGroup; if (c > s.longSwipesMs) { if (!s.longSwipes) return void t.slideTo(t.activeIndex); "next" === t.swipeDirection && (g >= s.longSwipesRatio ? t.slideTo(s.rewind && t.isEnd ? f : h + v) : t.slideTo(h)), "prev" === t.swipeDirection && (g > 1 - s.longSwipesRatio ? t.slideTo(h + v) : null !== m && g < 0 && Math.abs(g) > s.longSwipesRatio ? t.slideTo(m) : t.slideTo(h)) } else { if (!s.shortSwipes) return void t.slideTo(t.activeIndex); t.navigation && (l.target === t.navigation.nextEl || l.target === t.navigation.prevEl) ? l.target === t.navigation.nextEl ? t.slideTo(h + v) : t.slideTo(h) : ("next" === t.swipeDirection && t.slideTo(null !== f ? f : h + v), "prev" === t.swipeDirection && t.slideTo(null !== m ? m : h)) } } function xi() { const e = this, { params: t, el: i } = e; if (i && 0 === i.offsetWidth) return; t.breakpoints && e.setBreakpoint(); const { allowSlideNext: s, allowSlidePrev: n, snapGrid: r } = e; e.allowSlideNext = !0, e.allowSlidePrev = !0, e.updateSize(), e.updateSlides(), e.updateSlidesClasses(), ("auto" === t.slidesPerView || t.slidesPerView > 1) && e.isEnd && !e.isBeginning && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), e.autoplay && e.autoplay.running && e.autoplay.paused && e.autoplay.run(), e.allowSlidePrev = n, e.allowSlideNext = s, e.params.watchOverflow && r !== e.snapGrid && e.checkOverflow() } function Ci(e) { const t = this; t.enabled && (t.allowClick || (t.params.preventClicks && e.preventDefault(), t.params.preventClicksPropagation && t.animating && (e.stopPropagation(), e.stopImmediatePropagation()))) } function Ei() { const e = this, { wrapperEl: t, rtlTranslate: i, enabled: s } = e; if (!s) return; let n; e.previousTranslate = e.translate, e.isHorizontal() ? e.translate = -t.scrollLeft : e.translate = -t.scrollTop, 0 === e.translate && (e.translate = 0), e.updateActiveIndex(), e.updateSlidesClasses(); const r = e.maxTranslate() - e.minTranslate(); n = 0 === r ? 0 : (e.translate - e.minTranslate()) / r, n !== e.progress && e.updateProgress(i ? -e.translate : e.translate), e.emit("setTranslate", e.translate, !1) } let Ti = !1; function Di() { } const ki = (e, t) => { const i = qt(), { params: s, touchEvents: n, el: r, wrapperEl: o, device: a, support: l } = e, d = !!s.nested, c = "on" === t ? "addEventListener" : "removeEventListener", u = t; if (l.touch) { const t = !("touchstart" !== n.start || !l.passiveListener || !s.passiveListeners) && { passive: !0, capture: !1 }; r[c](n.start, e.onTouchStart, t), r[c](n.move, e.onTouchMove, l.passiveListener ? { passive: !1, capture: d } : d), r[c](n.end, e.onTouchEnd, t), n.cancel && r[c](n.cancel, e.onTouchEnd, t) } else r[c](n.start, e.onTouchStart, !1), i[c](n.move, e.onTouchMove, d), i[c](n.end, e.onTouchEnd, !1); (s.preventClicks || s.preventClicksPropagation) && r[c]("click", e.onClick, !0), s.cssMode && o[c]("scroll", e.onScroll), s.updateOnWindowResize ? e[u](a.ios || a.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", xi, !0) : e[u]("observerUpdate", xi, !0) }; const Li = { attachEvents: function () { const e = this, t = qt(), { params: i, support: s } = e; e.onTouchStart = bi.bind(e), e.onTouchMove = wi.bind(e), e.onTouchEnd = Si.bind(e), i.cssMode && (e.onScroll = Ei.bind(e)), e.onClick = Ci.bind(e), s.touch && !Ti && (t.addEventListener("touchstart", Di), Ti = !0), ki(e, "on") }, detachEvents: function () { ki(this, "off") } }, _i = (e, t) => e.grid && t.grid && t.grid.rows > 1; const Oi = { setBreakpoint: function () { const e = this, { activeIndex: t, initialized: i, loopedSlides: s = 0, params: n, $el: r } = e, o = n.breakpoints; if (!o || o && 0 === Object.keys(o).length) return; const a = e.getBreakpoint(o, e.params.breakpointsBase, e.el); if (!a || e.currentBreakpoint === a) return; const l = (a in o ? o[a] : void 0) || e.originalParams, d = _i(e, n), c = _i(e, l), u = n.enabled; d && !c ? (r.removeClass(`${n.containerModifierClass}grid ${n.containerModifierClass}grid-column`), e.emitContainerClasses()) : !d && c && (r.addClass(`${n.containerModifierClass}grid`), (l.grid.fill && "column" === l.grid.fill || !l.grid.fill && "column" === n.grid.fill) && r.addClass(`${n.containerModifierClass}grid-column`), e.emitContainerClasses()); const h = l.direction && l.direction !== n.direction, p = n.loop && (l.slidesPerView !== n.slidesPerView || h); h && i && e.changeDirection(), ni(e.params, l); const f = e.params.enabled; Object.assign(e, { allowTouchMove: e.params.allowTouchMove, allowSlideNext: e.params.allowSlideNext, allowSlidePrev: e.params.allowSlidePrev }), u && !f ? e.disable() : !u && f && e.enable(), e.currentBreakpoint = a, e.emit("_beforeBreakpoint", l), p && i && (e.loopDestroy(), e.loopCreate(), e.updateSlides(), e.slideTo(t - s + e.loopedSlides, 0, !1)), e.emit("breakpoint", l) }, getBreakpoint: function (e, t, i) { if (void 0 === t && (t = "window"), !e || "container" === t && !i) return; let s = !1; const n = Rt(), r = "window" === t ? n.innerHeight : i.clientHeight, o = Object.keys(e).map((e => { if ("string" == typeof e && 0 === e.indexOf("@")) { const t = parseFloat(e.substr(1)); return { value: r * t, point: e } } return { value: e, point: e } })); o.sort(((e, t) => parseInt(e.value, 10) - parseInt(t.value, 10))); for (let e = 0; e < o.length; e += 1) { const { point: r, value: a } = o[e]; "window" === t ? n.matchMedia(`(min-width: ${a}px)`).matches && (s = r) : a <= i.clientWidth && (s = r) } return s || "max" } }; const Mi = { addClasses: function () { const e = this, { classNames: t, params: i, rtl: s, $el: n, device: r, support: o } = e, a = function (e, t) { const i = []; return e.forEach((e => { "object" == typeof e ? Object.keys(e).forEach((s => { e[s] && i.push(t + s) })) : "string" == typeof e && i.push(t + e) })), i }(["initialized", i.direction, { "pointer-events": !o.touch }, { "free-mode": e.params.freeMode && i.freeMode.enabled }, { autoheight: i.autoHeight }, { rtl: s }, { grid: i.grid && i.grid.rows > 1 }, { "grid-column": i.grid && i.grid.rows > 1 && "column" === i.grid.fill }, { android: r.android }, { ios: r.ios }, { "css-mode": i.cssMode }, { centered: i.cssMode && i.centeredSlides }, { "watch-progress": i.watchSlidesProgress }], i.containerModifierClass); t.push(...a), n.addClass([...t].join(" ")), e.emitContainerClasses() }, removeClasses: function () { const { $el: e, classNames: t } = this; e.removeClass(t.join(" ")), this.emitContainerClasses() } }; const Ai = { init: !0, direction: "horizontal", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 0, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, preloadImages: !0, updateOnImagesReady: !0, loop: !1, loopAdditionalSlides: 0, loopedSlides: null, loopFillGroupWithBlank: !1, loopPreventsSlide: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-invisible-blank", slideActiveClass: "swiper-slide-active", slideDuplicateActiveClass: "swiper-slide-duplicate-active", slideVisibleClass: "swiper-slide-visible", slideDuplicateClass: "swiper-slide-duplicate", slideNextClass: "swiper-slide-next", slideDuplicateNextClass: "swiper-slide-duplicate-next", slidePrevClass: "swiper-slide-prev", slideDuplicatePrevClass: "swiper-slide-duplicate-prev", wrapperClass: "swiper-wrapper", runCallbacksOnInit: !0, _emitClasses: !1 }; function Pi(e, t) { return function (i) { void 0 === i && (i = {}); const s = Object.keys(i)[0], n = i[s]; "object" == typeof n && null !== n ? (["navigation", "pagination", "scrollbar"].indexOf(s) >= 0 && !0 === e[s] && (e[s] = { auto: !0 }), s in e && "enabled" in n ? (!0 === e[s] && (e[s] = { enabled: !0 }), "object" != typeof e[s] || "enabled" in e[s] || (e[s].enabled = !0), e[s] || (e[s] = { enabled: !1 }), ni(t, i)) : ni(t, i)) : ni(t, i) } } const Ii = { eventsEmitter: pi, update: fi, translate: mi, transition: { setTransition: function (e, t) { const i = this; i.params.cssMode || i.$wrapperEl.transition(e), i.emit("setTransition", e, t) }, transitionStart: function (e, t) { void 0 === e && (e = !0); const i = this, { params: s } = i; s.cssMode || (s.autoHeight && i.updateAutoHeight(), gi({ swiper: i, runCallbacks: e, direction: t, step: "Start" })) }, transitionEnd: function (e, t) { void 0 === e && (e = !0); const i = this, { params: s } = i; i.animating = !1, s.cssMode || (i.setTransition(0), gi({ swiper: i, runCallbacks: e, direction: t, step: "End" })) } }, slide: vi, loop: yi, grabCursor: { setGrabCursor: function (e) { const t = this; if (t.support.touch || !t.params.simulateTouch || t.params.watchOverflow && t.isLocked || t.params.cssMode) return; const i = "container" === t.params.touchEventsTarget ? t.el : t.wrapperEl; i.style.cursor = "move", i.style.cursor = e ? "grabbing" : "grab" }, unsetGrabCursor: function () { const e = this; e.support.touch || e.params.watchOverflow && e.isLocked || e.params.cssMode || (e["container" === e.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "") } }, events: Li, breakpoints: Oi, checkOverflow: { checkOverflow: function () { const e = this, { isLocked: t, params: i } = e, { slidesOffsetBefore: s } = i; if (s) { const t = e.slides.length - 1, i = e.slidesGrid[t] + e.slidesSizesGrid[t] + 2 * s; e.isLocked = e.size > i } else e.isLocked = 1 === e.snapGrid.length; !0 === i.allowSlideNext && (e.allowSlideNext = !e.isLocked), !0 === i.allowSlidePrev && (e.allowSlidePrev = !e.isLocked), t && t !== e.isLocked && (e.isEnd = !1), t !== e.isLocked && e.emit(e.isLocked ? "lock" : "unlock") } }, classes: Mi, images: { loadImage: function (e, t, i, s, n, r) { const o = Rt(); let a; function l() { r && r() } Qt(e).parent("picture")[0] || e.complete && n ? l() : t ? (a = new o.Image, a.onload = l, a.onerror = l, s && (a.sizes = s), i && (a.srcset = i), t && (a.src = t)) : l() }, preloadImages: function () { const e = this; function t() { null != e && e && !e.destroyed && (void 0 !== e.imagesLoaded && (e.imagesLoaded += 1), e.imagesLoaded === e.imagesToLoad.length && (e.params.updateOnImagesReady && e.update(), e.emit("imagesReady"))) } e.imagesToLoad = e.$el.find("img"); for (let i = 0; i < e.imagesToLoad.length; i += 1) { const s = e.imagesToLoad[i]; e.loadImage(s, s.currentSrc || s.getAttribute("src"), s.srcset || s.getAttribute("srcset"), s.sizes || s.getAttribute("sizes"), !0, t) } } } }, $i = {}; class Vi { constructor() { let e, t; for (var i = arguments.length, s = new Array(i), n = 0; n < i; n++)s[n] = arguments[n]; if (1 === s.length && s[0].constructor && "Object" === Object.prototype.toString.call(s[0]).slice(8, -1) ? t = s[0] : [e, t] = s, t || (t = {}), t = ni({}, t), e && !t.el && (t.el = e), t.el && Qt(t.el).length > 1) { const e = []; return Qt(t.el).each((i => { const s = ni({}, t, { el: i }); e.push(new Vi(s)) })), e } const r = this; r.__swiper__ = !0, r.support = ci(), r.device = ui({ userAgent: t.userAgent }), r.browser = hi(), r.eventsListeners = {}, r.eventsAnyListeners = [], r.modules = [...r.__modules__], t.modules && Array.isArray(t.modules) && r.modules.push(...t.modules); const o = {}; r.modules.forEach((e => { e({ swiper: r, extendParams: Pi(t, o), on: r.on.bind(r), once: r.once.bind(r), off: r.off.bind(r), emit: r.emit.bind(r) }) })); const a = ni({}, Ai, o); return r.params = ni({}, a, $i, t), r.originalParams = ni({}, r.params), r.passedParams = ni({}, t), r.params && r.params.on && Object.keys(r.params.on).forEach((e => { r.on(e, r.params.on[e]) })), r.params && r.params.onAny && r.onAny(r.params.onAny), r.$ = Qt, Object.assign(r, { enabled: r.params.enabled, el: e, classNames: [], slides: Qt(), slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal: () => "horizontal" === r.params.direction, isVertical: () => "vertical" === r.params.direction, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, allowSlideNext: r.params.allowSlideNext, allowSlidePrev: r.params.allowSlidePrev, touchEvents: function () { const e = ["touchstart", "touchmove", "touchend", "touchcancel"], t = ["pointerdown", "pointermove", "pointerup"]; return r.touchEventsTouch = { start: e[0], move: e[1], end: e[2], cancel: e[3] }, r.touchEventsDesktop = { start: t[0], move: t[1], end: t[2] }, r.support.touch || !r.params.simulateTouch ? r.touchEventsTouch : r.touchEventsDesktop }(), touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: r.params.focusableElements, lastClickTime: ti(), clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, isTouchEvent: void 0, startMoving: void 0 }, allowClick: !0, allowTouchMove: r.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), r.emit("_swiper"), r.params.init && r.init(), r } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const i = this; e = Math.min(Math.max(e, 0), 1); const s = i.minTranslate(), n = (i.maxTranslate() - s) * e + s; i.translateTo(n, void 0 === t ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter((t => 0 === t.indexOf("swiper") || 0 === t.indexOf(e.params.containerModifierClass))); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return t.destroyed ? "" : e.className.split(" ").filter((e => 0 === e.indexOf("swiper-slide") || 0 === e.indexOf(t.params.slideClass))).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.each((i => { const s = e.getSlideClasses(i); t.push({ slideEl: i, classNames: s }), e.emit("_slideClass", i, s) })), e.emit("_slideClasses", t) } slidesPerViewDynamic(e, t) { void 0 === e && (e = "current"), void 0 === t && (t = !1); const { params: i, slides: s, slidesGrid: n, slidesSizesGrid: r, size: o, activeIndex: a } = this; let l = 1; if (i.centeredSlides) { let e, t = s[a].swiperSlideSize; for (let i = a + 1; i < s.length; i += 1)s[i] && !e && (t += s[i].swiperSlideSize, l += 1, t > o && (e = !0)); for (let i = a - 1; i >= 0; i -= 1)s[i] && !e && (t += s[i].swiperSlideSize, l += 1, t > o && (e = !0)) } else if ("current" === e) for (let e = a + 1; e < s.length; e += 1) { (t ? n[e] + r[e] - n[a] < o : n[e] - n[a] < o) && (l += 1) } else for (let e = a - 1; e >= 0; e -= 1) { n[a] - n[e] < o && (l += 1) } return l } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: i } = e; function s() { const t = e.rtlTranslate ? -1 * e.translate : e.translate, i = Math.min(Math.max(t, e.maxTranslate()), e.minTranslate()); e.setTranslate(i), e.updateActiveIndex(), e.updateSlidesClasses() } let n; i.breakpoints && e.setBreakpoint(), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), e.params.freeMode && e.params.freeMode.enabled ? (s(), e.params.autoHeight && e.updateAutoHeight()) : (n = ("auto" === e.params.slidesPerView || e.params.slidesPerView > 1) && e.isEnd && !e.params.centeredSlides ? e.slideTo(e.slides.length - 1, 0, !1, !0) : e.slideTo(e.activeIndex, 0, !1, !0), n || s()), i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t) { void 0 === t && (t = !0); const i = this, s = i.params.direction; return e || (e = "horizontal" === s ? "vertical" : "horizontal"), e === s || "horizontal" !== e && "vertical" !== e || (i.$el.removeClass(`${i.params.containerModifierClass}${s}`).addClass(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.each((t => { "vertical" === e ? t.style.width = "" : t.style.height = "" })), i.emit("changeDirection"), t && i.update()), i } mount(e) { const t = this; if (t.mounted) return !0; const i = Qt(e || t.params.el); if (!(e = i[0])) return !1; e.swiper = t; const s = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`; let n = (() => { if (e && e.shadowRoot && e.shadowRoot.querySelector) { const t = Qt(e.shadowRoot.querySelector(s())); return t.children = e => i.children(e), t } return i.children(s()) })(); if (0 === n.length && t.params.createElements) { const e = qt().createElement("div"); n = Qt(e), e.className = t.params.wrapperClass, i.append(e), i.children(`.${t.params.slideClass}`).each((e => { n.append(e) })) } return Object.assign(t, { $el: i, el: e, $wrapperEl: n, wrapperEl: n[0], mounted: !0, rtl: "rtl" === e.dir.toLowerCase() || "rtl" === i.css("direction"), rtlTranslate: "horizontal" === t.params.direction && ("rtl" === e.dir.toLowerCase() || "rtl" === i.css("direction")), wrongRTL: "-webkit-box" === n.css("display") }), !0 } init(e) { const t = this; if (t.initialized) return t; return !1 === t.mount(e) || (t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.params.loop && t.loopCreate(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.preloadImages && t.preloadImages(), t.params.loop ? t.slideTo(t.params.initialSlide + t.loopedSlides, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.attachEvents(), t.initialized = !0, t.emit("init"), t.emit("afterInit")), t } destroy(e, t) { void 0 === e && (e = !0), void 0 === t && (t = !0); const i = this, { params: s, $el: n, $wrapperEl: r, slides: o } = i; return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), s.loop && i.loopDestroy(), t && (i.removeClasses(), n.removeAttr("style"), r.removeAttr("style"), o && o.length && o.removeClass([s.slideVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), i.emit("destroy"), Object.keys(i.eventsListeners).forEach((e => { i.off(e) })), !1 !== e && (i.$el[0].swiper = null, function (e) { const t = e; Object.keys(t).forEach((e => { try { t[e] = null } catch (e) { } try { delete t[e] } catch (e) { } })) }(i)), i.destroyed = !0), null } static extendDefaults(e) { ni($i, e) } static get extendedDefaults() { return $i } static get defaults() { return Ai } static installModule(e) { Vi.prototype.__modules__ || (Vi.prototype.__modules__ = []); const t = Vi.prototype.__modules__; "function" == typeof e && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach((e => Vi.installModule(e))), Vi) : (Vi.installModule(e), Vi) } } Object.keys(Ii).forEach((e => { Object.keys(Ii[e]).forEach((t => { Vi.prototype[t] = Ii[e][t] })) })), Vi.use([function (e) { let { swiper: t, on: i, emit: s } = e; const n = Rt(); let r = null, o = null; const a = () => { t && !t.destroyed && t.initialized && (s("beforeResize"), s("resize")) }, l = () => { t && !t.destroyed && t.initialized && s("orientationchange") }; i("init", (() => { t.params.resizeObserver && void 0 !== n.ResizeObserver ? t && !t.destroyed && t.initialized && (r = new ResizeObserver((e => { o = n.requestAnimationFrame((() => { const { width: i, height: s } = t; let n = i, r = s; e.forEach((e => { let { contentBoxSize: i, contentRect: s, target: o } = e; o && o !== t.el || (n = s ? s.width : (i[0] || i).inlineSize, r = s ? s.height : (i[0] || i).blockSize) })), n === i && r === s || a() })) })), r.observe(t.el)) : (n.addEventListener("resize", a), n.addEventListener("orientationchange", l)) })), i("destroy", (() => { o && n.cancelAnimationFrame(o), r && r.unobserve && t.el && (r.unobserve(t.el), r = null), n.removeEventListener("resize", a), n.removeEventListener("orientationchange", l) })) }, function (e) { let { swiper: t, extendParams: i, on: s, emit: n } = e; const r = [], o = Rt(), a = function (e, t) { void 0 === t && (t = {}); const i = new (o.MutationObserver || o.WebkitMutationObserver)((e => { if (1 === e.length) return void n("observerUpdate", e[0]); const t = function () { n("observerUpdate", e[0]) }; o.requestAnimationFrame ? o.requestAnimationFrame(t) : o.setTimeout(t, 0) })); i.observe(e, { attributes: void 0 === t.attributes || t.attributes, childList: void 0 === t.childList || t.childList, characterData: void 0 === t.characterData || t.characterData }), r.push(i) }; i({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), s("init", (() => { if (t.params.observer) { if (t.params.observeParents) { const e = t.$el.parents(); for (let t = 0; t < e.length; t += 1)a(e[t]) } a(t.$el[0], { childList: t.params.observeSlideChildren }), a(t.$wrapperEl[0], { attributes: !1 }) } })), s("destroy", (() => { r.forEach((e => { e.disconnect() })), r.splice(0, r.length) })) }]); const Ni = Vi; function Hi(e) { let { swiper: t, extendParams: i, on: s, emit: n } = e; function r(e) { let i; return e && (i = Qt(e), t.params.uniqueNavElements && "string" == typeof e && i.length > 1 && 1 === t.$el.find(e).length && (i = t.$el.find(e))), i } function o(e, i) { const s = t.params.navigation; e && e.length > 0 && (e[i ? "addClass" : "removeClass"](s.disabledClass), e[0] && "BUTTON" === e[0].tagName && (e[0].disabled = i), t.params.watchOverflow && t.enabled && e[t.isLocked ? "addClass" : "removeClass"](s.lockClass)) } function a() { if (t.params.loop) return; const { $nextEl: e, $prevEl: i } = t.navigation; o(i, t.isBeginning && !t.params.rewind), o(e, t.isEnd && !t.params.rewind) } function l(e) { e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && t.slidePrev() } function d(e) { e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && t.slideNext() } function c() { const e = t.params.navigation; if (t.params.navigation = function (e, t, i, s) { const n = qt(); return e.params.createElements && Object.keys(s).forEach((r => { if (!i[r] && !0 === i.auto) { let o = e.$el.children(`.${s[r]}`)[0]; o || (o = n.createElement("div"), o.className = s[r], e.$el.append(o)), i[r] = o, t[r] = o } })), i }(t, t.originalParams.navigation, t.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !e.nextEl && !e.prevEl) return; const i = r(e.nextEl), s = r(e.prevEl); i && i.length > 0 && i.on("click", d), s && s.length > 0 && s.on("click", l), Object.assign(t.navigation, { $nextEl: i, nextEl: i && i[0], $prevEl: s, prevEl: s && s[0] }), t.enabled || (i && i.addClass(e.lockClass), s && s.addClass(e.lockClass)) } function u() { const { $nextEl: e, $prevEl: i } = t.navigation; e && e.length && (e.off("click", d), e.removeClass(t.params.navigation.disabledClass)), i && i.length && (i.off("click", l), i.removeClass(t.params.navigation.disabledClass)) } i({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock" } }), t.navigation = { nextEl: null, $nextEl: null, prevEl: null, $prevEl: null }, s("init", (() => { c(), a() })), s("toEdge fromEdge lock unlock", (() => { a() })), s("destroy", (() => { u() })), s("enable disable", (() => { const { $nextEl: e, $prevEl: i } = t.navigation; e && e[t.enabled ? "removeClass" : "addClass"](t.params.navigation.lockClass), i && i[t.enabled ? "removeClass" : "addClass"](t.params.navigation.lockClass) })), s("click", ((e, i) => { const { $nextEl: s, $prevEl: r } = t.navigation, o = i.target; if (t.params.navigation.hideOnClick && !Qt(o).is(r) && !Qt(o).is(s)) { if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === o || t.pagination.el.contains(o))) return; let e; s ? e = s.hasClass(t.params.navigation.hiddenClass) : r && (e = r.hasClass(t.params.navigation.hiddenClass)), n(!0 === e ? "navigationShow" : "navigationHide"), s && s.toggleClass(t.params.navigation.hiddenClass), r && r.toggleClass(t.params.navigation.hiddenClass) } })), Object.assign(t.navigation, { update: a, init: c, destroy: u }) } function Bi(e) { let t, { swiper: i, extendParams: s, on: n, emit: r } = e; function o() { const e = i.slides.eq(i.activeIndex); let s = i.params.autoplay.delay; e.attr("data-swiper-autoplay") && (s = e.attr("data-swiper-autoplay") || i.params.autoplay.delay), clearTimeout(t), t = ei((() => { let e; i.params.autoplay.reverseDirection ? i.params.loop ? (i.loopFix(), e = i.slidePrev(i.params.speed, !0, !0), r("autoplay")) : i.isBeginning ? i.params.autoplay.stopOnLastSlide ? l() : (e = i.slideTo(i.slides.length - 1, i.params.speed, !0, !0), r("autoplay")) : (e = i.slidePrev(i.params.speed, !0, !0), r("autoplay")) : i.params.loop ? (i.loopFix(), e = i.slideNext(i.params.speed, !0, !0), r("autoplay")) : i.isEnd ? i.params.autoplay.stopOnLastSlide ? l() : (e = i.slideTo(0, i.params.speed, !0, !0), r("autoplay")) : (e = i.slideNext(i.params.speed, !0, !0), r("autoplay")), (i.params.cssMode && i.autoplay.running || !1 === e) && o() }), s) } function a() { return void 0 === t && (!i.autoplay.running && (i.autoplay.running = !0, r("autoplayStart"), o(), !0)) } function l() { return !!i.autoplay.running && (void 0 !== t && (t && (clearTimeout(t), t = void 0), i.autoplay.running = !1, r("autoplayStop"), !0)) } function d(e) { i.autoplay.running && (i.autoplay.paused || (t && clearTimeout(t), i.autoplay.paused = !0, 0 !== e && i.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach((e => { i.$wrapperEl[0].addEventListener(e, u) })) : (i.autoplay.paused = !1, o()))) } function c() { const e = qt(); "hidden" === e.visibilityState && i.autoplay.running && d(), "visible" === e.visibilityState && i.autoplay.paused && (o(), i.autoplay.paused = !1) } function u(e) { i && !i.destroyed && i.$wrapperEl && e.target === i.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach((e => { i.$wrapperEl[0].removeEventListener(e, u) })), i.autoplay.paused = !1, i.autoplay.running ? o() : l()) } function h() { i.params.autoplay.disableOnInteraction ? l() : (r("autoplayPause"), d()), ["transitionend", "webkitTransitionEnd"].forEach((e => { i.$wrapperEl[0].removeEventListener(e, u) })) } function p() { i.params.autoplay.disableOnInteraction || (i.autoplay.paused = !1, r("autoplayResume"), o()) } i.autoplay = { running: !1, paused: !1 }, s({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !0, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }), n("init", (() => { if (i.params.autoplay.enabled) { a(); qt().addEventListener("visibilitychange", c), i.params.autoplay.pauseOnMouseEnter && (i.$el.on("mouseenter", h), i.$el.on("mouseleave", p)) } })), n("beforeTransitionStart", ((e, t, s) => { i.autoplay.running && (s || !i.params.autoplay.disableOnInteraction ? i.autoplay.pause(t) : l()) })), n("sliderFirstMove", (() => { i.autoplay.running && (i.params.autoplay.disableOnInteraction ? l() : d()) })), n("touchEnd", (() => { i.params.cssMode && i.autoplay.paused && !i.params.autoplay.disableOnInteraction && o() })), n("destroy", (() => { i.$el.off("mouseenter", h), i.$el.off("mouseleave", p), i.autoplay.running && l(); qt().removeEventListener("visibilitychange", c) })), Object.assign(i.autoplay, { pause: d, run: o, start: a, stop: l }) } function Fi(e) { let { swiper: t, extendParams: i, on: s } = e; i({ thumbs: { swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: "swiper-slide-thumb-active", thumbsContainerClass: "swiper-thumbs" } }); let n = !1, r = !1; function o() { const e = t.thumbs.swiper; if (!e || e.destroyed) return; const i = e.clickedIndex, s = e.clickedSlide; if (s && Qt(s).hasClass(t.params.thumbs.slideThumbActiveClass)) return; if (null == i) return; let n; if (n = e.params.loop ? parseInt(Qt(e.clickedSlide).attr("data-swiper-slide-index"), 10) : i, t.params.loop) { let e = t.activeIndex; t.slides.eq(e).hasClass(t.params.slideDuplicateClass) && (t.loopFix(), t._clientLeft = t.$wrapperEl[0].clientLeft, e = t.activeIndex); const i = t.slides.eq(e).prevAll(`[data-swiper-slide-index="${n}"]`).eq(0).index(), s = t.slides.eq(e).nextAll(`[data-swiper-slide-index="${n}"]`).eq(0).index(); n = void 0 === i ? s : void 0 === s ? i : s - e < e - i ? s : i } t.slideTo(n) } function a() { const { thumbs: e } = t.params; if (n) return !1; n = !0; const i = t.constructor; if (e.swiper instanceof i) t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(t.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }); else if (si(e.swiper)) { const s = Object.assign({}, e.swiper); Object.assign(s, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), t.thumbs.swiper = new i(s), r = !0 } return t.thumbs.swiper.$el.addClass(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on("tap", o), !0 } function l(e) { const i = t.thumbs.swiper; if (!i || i.destroyed) return; const s = "auto" === i.params.slidesPerView ? i.slidesPerViewDynamic() : i.params.slidesPerView, n = t.params.thumbs.autoScrollOffset, r = n && !i.params.loop; if (t.realIndex !== i.realIndex || r) { let o, a, l = i.activeIndex; if (i.params.loop) { i.slides.eq(l).hasClass(i.params.slideDuplicateClass) && (i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft, l = i.activeIndex); const e = i.slides.eq(l).prevAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(), s = i.slides.eq(l).nextAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(); o = void 0 === e ? s : void 0 === s ? e : s - l == l - e ? i.params.slidesPerGroup > 1 ? s : l : s - l < l - e ? s : e, a = t.activeIndex > t.previousIndex ? "next" : "prev" } else o = t.realIndex, a = o > t.previousIndex ? "next" : "prev"; r && (o += "next" === a ? n : -1 * n), i.visibleSlidesIndexes && i.visibleSlidesIndexes.indexOf(o) < 0 && (i.params.centeredSlides ? o = o > l ? o - Math.floor(s / 2) + 1 : o + Math.floor(s / 2) - 1 : o > l && i.params.slidesPerGroup, i.slideTo(o, e ? 0 : void 0)) } let o = 1; const a = t.params.thumbs.slideThumbActiveClass; if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (o = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (o = 1), o = Math.floor(o), i.slides.removeClass(a), i.params.loop || i.params.virtual && i.params.virtual.enabled) for (let e = 0; e < o; e += 1)i.$wrapperEl.children(`[data-swiper-slide-index="${t.realIndex + e}"]`).addClass(a); else for (let e = 0; e < o; e += 1)i.slides.eq(t.realIndex + e).addClass(a) } t.thumbs = { swiper: null }, s("beforeInit", (() => { const { thumbs: e } = t.params; e && e.swiper && (a(), l(!0)) })), s("slideChange update resize observerUpdate", (() => { l() })), s("setTransition", ((e, i) => { const s = t.thumbs.swiper; s && !s.destroyed && s.setTransition(i) })), s("beforeDestroy", (() => { const e = t.thumbs.swiper; e && !e.destroyed && r && e.destroy() })), Object.assign(t.thumbs, { init: a, update: l }) } function zi() { let e = document.querySelectorAll('[class*="__swiper"]:not(.swiper-wrapper)'); e && e.forEach((e => { e.parentElement.classList.add("swiper"), e.classList.add("swiper-wrapper"); for (const t of e.children) t.classList.add("swiper-slide") })) } window.addEventListener("load", (function (e) { !function () { if (zi(), document.querySelector(".swiper")) { new Ni(".sliderInfo", { modules: [Hi, Bi], effect: "fade", autoplay: { delay: 3e3, disableOnInteraction: !1 }, observer: !0, observeParents: !0, slidesPerView: 1.5, spaceBetween: 10, autoHeight: !0, speed: 800, loop: !0, navigation: { nextEl: ".slider-info__button-next", prevEl: ".slider-info__button-prev" }, breakpoints: { 415: { slidesPerView: 1.8, spaceBetween: 10 }, 516: { slidesPerView: 2.6, spaceBetween: 10 }, 1025: { slidesPerView: 3, spaceBetween: 20 } }, on: { init() { this.el.addEventListener("mouseenter", (() => { this.autoplay.stop() })), this.el.addEventListener("mouseleave", (() => { this.autoplay.start() })) } } }), new Ni(".sliderBrends", { observer: !0, observeParents: !0, slidesPerView: 2.8, spaceBetween: 10, autoHeight: !0, speed: 800, loop: !0, breakpoints: { 415: { slidesPerView: 4.8, spaceBetween: 10 }, 515: { slidesPerView: 5.3, spaceBetween: 10 }, 767: { slidesPerView: 5.5, spaceBetween: 10 }, 1025: { slidesPerView: 6.5, spaceBetween: 10 }, 1281: { slidesPerView: 8, spaceBetween: 30 } }, on: {} }), new Ni(".salesLeaders", { modules: [Hi], observer: !0, observeParents: !0, slidesPerView: 1.2, spaceBetween: 10, autoHeight: !0, speed: 800, loop: !0, initialSlide: 1, navigation: { nextEl: ".slider-info__button-next", prevEl: ".slider-info__button-prev" }, breakpoints: { 345: { slidesPerView: 1.6 }, 376: { slidesPerView: 2.2 }, 415: { slidesPerView: 2.4 }, 540: { slidesPerView: 2.6 }, 630: { slidesPerView: 2.8 }, 769: { slidesPerView: 3.3 }, 1025: { slidesPerView: 4.8, spaceBetween: 10 }, 1150: { slidesPerView: 5.3 }, 1360: { slidesPerView: 6, spaceBetween: 20 } }, on: {} }), new Ni(".recentlyWatched", { modules: [Hi], observer: !0, observeParents: !0, slidesPerView: 1.6, spaceBetween: 10, autoHeight: !0, speed: 800, loop: !0, navigation: { nextEl: ".slider-info__button-next", prevEl: ".slider-info__button-prev" }, breakpoints: { 346: { slidesPerView: 1.8 }, 375: { slidesPerView: 2.1 }, 415: { slidesPerView: 2.3 }, 516: { slidesPerView: 2.8 }, 613: { slidesPerView: 3.2 }, 630: { slidesPerView: 3.6 }, 769: { slidesPerView: 4.2 }, 813: { slidesPerView: 4.6 }, 1025: { slidesPerView: 5.6 }, 1200: { slidesPerView: 6.2 }, 1331: { slidesPerView: 7, spaceBetween: 20 } }, on: {} }), new Ni(".sliderCert", { modules: [Hi], observer: !0, observeParents: !0, slidesPerView: 1.5, spaceBetween: 10, autoHeight: !0, speed: 800, loop: !0, navigation: { nextEl: ".slider-info__button-next", prevEl: ".slider-info__button-prev" }, breakpoints: { 376: { slidesPerView: 1.8 }, 415: { slidesPerView: 2.1 }, 541: { slidesPerView: 2.8 }, 613: { slidesPerView: 3.2 }, 769: { slidesPerView: 3.8 }, 813: { slidesPerView: 4.2 }, 1025: { slidesPerView: 4.8 }, 1201: { slidesPerView: 5.3 }, 1281: { slidesPerView: 6, spaceBetween: 20 } }, on: {} }), new Ni(".sliderReviews", { modules: [Hi], observer: !0, observeParents: !0, slidesPerView: 1.1, spaceBetween: 10, autoHeight: !0, speed: 800, loop: !0, navigation: { nextEl: ".slider-info__button-next", prevEl: ".slider-info__button-prev" }, breakpoints: { 345: { slidesPerView: 1.2 }, 414: { slidesPerView: 1.4 }, 540: { slidesPerView: 1.8 }, 630: { slidesPerView: 2.1 }, 812: { slidesPerView: 2.4 }, 1024: { slidesPerView: 2.6, spaceBetween: 20 }, 1200: { slidesPerView: 2.8 }, 1330: { slidesPerView: 3 } }, on: {} }); let e = new Ni(".cardProductSmallSl", { modules: [Hi], autoplay: { delay: 3e3, disableOnInteraction: !1 }, observer: !0, observeParents: !0, slidesPerView: 5, spaceBetween: 12, autoHeight: !0, speed: 800, slideToClickedSlide: !0, loop: !0, slideToClickedSlide: !0, navigation: { nextEl: ".slider-info__button-next", prevEl: ".slider-info__button-prev" }, on: {} }); new Ni(".cardProductSl", { modules: [Hi, Fi], autoplay: { delay: 3e3, disableOnInteraction: !1 }, observer: !0, observeParents: !0, slidesPerView: 1, spaceBetween: 0, autoHeight: !0, speed: 800, loop: !0, navigation: { nextEl: ".slider-info__button-next", prevEl: ".slider-info__button-prev" }, thumbs: { swiper: e }, on: {} }), new Ni(".boxOrdersL", { autoplay: { delay: 3e3, disableOnInteraction: !1 }, observer: !0, observeParents: !0, slidesPerView: 1.2, spaceBetween: 10, autoHeight: !0, speed: 800, breakpoints: { 345: { slidesPerView: 1.8 }, 768: { slidesPerView: 2.2 }, 1280: { slidesPerView: 3 } }, on: {} }), new Ni(".recommendSl", { autoplay: { delay: 3e3, disableOnInteraction: !1 }, observer: !0, observeParents: !0, slidesPerView: 1.5, spaceBetween: 10, autoHeight: !0, speed: 800, loop: !0, breakpoints: { 376: { slidesPerView: 1.8 }, 415: { slidesPerView: 2.1 }, 541: { slidesPerView: 2.5 }, 613: { slidesPerView: 2.8 }, 769: { slidesPerView: 3.2 }, 813: { slidesPerView: 3.5 }, 1025: { slidesPerView: 3.8 }, 1201: { slidesPerView: 4, spaceBetween: 20 } }, on: {} }), new Ni(".productPreviewSl", { observer: !0, observeParents: !0, slidesPerView: 3.2, spaceBetween: 5, speed: 800, slideToClickedSlide: !0, loop: !0, breakpoints: { 516: { slidesPerView: 5, spaceBetween: 5 } }, on: {} }) } }() })); let ji = !1; setTimeout((() => { if (ji) { let e = new Event("windowScroll"); window.addEventListener("scroll", (function (t) { document.dispatchEvent(e) })) } }), 0); var qi = function () { return qi = Object.assign || function (e) { for (var t, i = 1, s = arguments.length; i < s; i++)for (var n in t = arguments[i]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); return e }, qi.apply(this, arguments) }; var Gi = "lgAfterAppendSlide", Ri = "lgInit", Ui = "lgHasVideo", Wi = "lgContainerResize", Yi = "lgUpdateSlides", Xi = "lgAfterAppendSubHtml", Ki = "lgBeforeOpen", Zi = "lgAfterOpen", Ji = "lgSlideItemLoad", Qi = "lgBeforeSlide", es = "lgAfterSlide", ts = "lgPosterClick", is = "lgDragStart", ss = "lgDragMove", ns = "lgDragEnd", rs = "lgBeforeNextSlide", os = "lgBeforePrevSlide", as = "lgBeforeClose", ls = "lgAfterClose", ds = { mode: "lg-slide", easing: "ease", speed: 400, licenseKey: "0000-0000-000-0000", height: "100%", width: "100%", addClass: "", startClass: "lg-start-zoom", backdropDuration: 300, container: "", startAnimationDuration: 400, zoomFromOrigin: !0, hideBarsDelay: 0, showBarsAfter: 1e4, slideDelay: 0, supportLegacyBrowser: !0, allowMediaOverlap: !1, videoMaxSize: "1280-720", loadYouTubePoster: !0, defaultCaptionHeight: 0, ariaLabelledby: "", ariaDescribedby: "", closable: !0, swipeToClose: !0, closeOnTap: !0, showCloseIcon: !0, showMaximizeIcon: !1, loop: !0, escKey: !0, keyPress: !0, controls: !0, slideEndAnimation: !0, hideControlOnEnd: !1, mousewheel: !1, getCaptionFromTitleOrAlt: !0, appendSubHtmlTo: ".lg-sub-html", subHtmlSelectorRelative: !1, preload: 2, numberOfSlideItemsInDom: 10, selector: "", selectWithin: "", nextHtml: "", prevHtml: "", index: 0, iframeWidth: "100%", iframeHeight: "100%", iframeMaxWidth: "100%", iframeMaxHeight: "100%", download: !0, counter: !0, appendCounterTo: ".lg-toolbar", swipeThreshold: 50, enableSwipe: !0, enableDrag: !0, dynamic: !1, dynamicEl: [], extraProps: [], exThumbImage: "", isMobile: void 0, mobileSettings: { controls: !1, showCloseIcon: !1, download: !1 }, plugins: [], strings: { closeGallery: "Close gallery", toggleMaximize: "Toggle maximize", previousSlide: "Previous slide", nextSlide: "Next slide", download: "Download", playVideo: "Play video" } }; var cs = function () { function e(e) { return this.cssVenderPrefixes = ["TransitionDuration", "TransitionTimingFunction", "Transform", "Transition"], this.selector = this._getSelector(e), this.firstElement = this._getFirstEl(), this } return e.generateUUID = function () { return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function (e) { var t = 16 * Math.random() | 0; return ("x" == e ? t : 3 & t | 8).toString(16) })) }, e.prototype._getSelector = function (e, t) { return void 0 === t && (t = document), "string" != typeof e ? e : (t = t || document, "#" === e.substring(0, 1) ? t.querySelector(e) : t.querySelectorAll(e)) }, e.prototype._each = function (e) { return this.selector ? (void 0 !== this.selector.length ? [].forEach.call(this.selector, e) : e(this.selector, 0), this) : this }, e.prototype._setCssVendorPrefix = function (e, t, i) { var s = t.replace(/-([a-z])/gi, (function (e, t) { return t.toUpperCase() })); -1 !== this.cssVenderPrefixes.indexOf(s) ? (e.style[s.charAt(0).toLowerCase() + s.slice(1)] = i, e.style["webkit" + s] = i, e.style["moz" + s] = i, e.style["ms" + s] = i, e.style["o" + s] = i) : e.style[s] = i }, e.prototype._getFirstEl = function () { return this.selector && void 0 !== this.selector.length ? this.selector[0] : this.selector }, e.prototype.isEventMatched = function (e, t) { var i = t.split("."); return e.split(".").filter((function (e) { return e })).every((function (e) { return -1 !== i.indexOf(e) })) }, e.prototype.attr = function (e, t) { return void 0 === t ? this.firstElement ? this.firstElement.getAttribute(e) : "" : (this._each((function (i) { i.setAttribute(e, t) })), this) }, e.prototype.find = function (e) { return us(this._getSelector(e, this.selector)) }, e.prototype.first = function () { return this.selector && void 0 !== this.selector.length ? us(this.selector[0]) : us(this.selector) }, e.prototype.eq = function (e) { return us(this.selector[e]) }, e.prototype.parent = function () { return us(this.selector.parentElement) }, e.prototype.get = function () { return this._getFirstEl() }, e.prototype.removeAttr = function (e) { var t = e.split(" "); return this._each((function (e) { t.forEach((function (t) { return e.removeAttribute(t) })) })), this }, e.prototype.wrap = function (e) { if (!this.firstElement) return this; var t = document.createElement("div"); return t.className = e, this.firstElement.parentNode.insertBefore(t, this.firstElement), this.firstElement.parentNode.removeChild(this.firstElement), t.appendChild(this.firstElement), this }, e.prototype.addClass = function (e) { return void 0 === e && (e = ""), this._each((function (t) { e.split(" ").forEach((function (e) { e && t.classList.add(e) })) })), this }, e.prototype.removeClass = function (e) { return this._each((function (t) { e.split(" ").forEach((function (e) { e && t.classList.remove(e) })) })), this }, e.prototype.hasClass = function (e) { return !!this.firstElement && this.firstElement.classList.contains(e) }, e.prototype.hasAttribute = function (e) { return !!this.firstElement && this.firstElement.hasAttribute(e) }, e.prototype.toggleClass = function (e) { return this.firstElement ? (this.hasClass(e) ? this.removeClass(e) : this.addClass(e), this) : this }, e.prototype.css = function (e, t) { var i = this; return this._each((function (s) { i._setCssVendorPrefix(s, e, t) })), this }, e.prototype.on = function (t, i) { var s = this; return this.selector ? (t.split(" ").forEach((function (t) { Array.isArray(e.eventListeners[t]) || (e.eventListeners[t] = []), e.eventListeners[t].push(i), s.selector.addEventListener(t.split(".")[0], i) })), this) : this }, e.prototype.once = function (e, t) { var i = this; return this.on(e, (function () { i.off(e), t(e) })), this }, e.prototype.off = function (t) { var i = this; return this.selector ? (Object.keys(e.eventListeners).forEach((function (s) { i.isEventMatched(t, s) && (e.eventListeners[s].forEach((function (e) { i.selector.removeEventListener(s.split(".")[0], e) })), e.eventListeners[s] = []) })), this) : this }, e.prototype.trigger = function (e, t) { if (!this.firstElement) return this; var i = new CustomEvent(e.split(".")[0], { detail: t || null }); return this.firstElement.dispatchEvent(i), this }, e.prototype.load = function (e) { var t = this; return fetch(e).then((function (e) { return e.text() })).then((function (e) { t.selector.innerHTML = e })), this }, e.prototype.html = function (e) { return void 0 === e ? this.firstElement ? this.firstElement.innerHTML : "" : (this._each((function (t) { t.innerHTML = e })), this) }, e.prototype.append = function (e) { return this._each((function (t) { "string" == typeof e ? t.insertAdjacentHTML("beforeend", e) : t.appendChild(e) })), this }, e.prototype.prepend = function (e) { return this._each((function (t) { t.insertAdjacentHTML("afterbegin", e) })), this }, e.prototype.remove = function () { return this._each((function (e) { e.parentNode.removeChild(e) })), this }, e.prototype.empty = function () { return this._each((function (e) { e.innerHTML = "" })), this }, e.prototype.scrollTop = function (e) { return void 0 !== e ? (document.body.scrollTop = e, document.documentElement.scrollTop = e, this) : window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0 }, e.prototype.scrollLeft = function (e) { return void 0 !== e ? (document.body.scrollLeft = e, document.documentElement.scrollLeft = e, this) : window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0 }, e.prototype.offset = function () { if (!this.firstElement) return { left: 0, top: 0 }; var e = this.firstElement.getBoundingClientRect(), t = us("body").style().marginLeft; return { left: e.left - parseFloat(t) + this.scrollLeft(), top: e.top + this.scrollTop() } }, e.prototype.style = function () { return this.firstElement ? this.firstElement.currentStyle || window.getComputedStyle(this.firstElement) : {} }, e.prototype.width = function () { var e = this.style(); return this.firstElement.clientWidth - parseFloat(e.paddingLeft) - parseFloat(e.paddingRight) }, e.prototype.height = function () { var e = this.style(); return this.firstElement.clientHeight - parseFloat(e.paddingTop) - parseFloat(e.paddingBottom) }, e.eventListeners = {}, e }(); function us(e) { return function () { if ("function" == typeof window.CustomEvent) return !1; window.CustomEvent = function (e, t) { t = t || { bubbles: !1, cancelable: !1, detail: null }; var i = document.createEvent("CustomEvent"); return i.initCustomEvent(e, t.bubbles, t.cancelable, t.detail), i } }(), Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector), new cs(e) } var hs = ["src", "sources", "subHtml", "subHtmlUrl", "html", "video", "poster", "slideName", "responsive", "srcset", "sizes", "iframe", "downloadUrl", "download", "width", "facebookShareUrl", "tweetText", "iframeTitle", "twitterShareUrl", "pinterestShareUrl", "pinterestText", "fbHtml", "disqusIdentifier", "disqusUrl"]; function ps(e) { return "href" === e ? "src" : e = (e = (e = e.replace("data-", "")).charAt(0).toLowerCase() + e.slice(1)).replace(/-([a-z])/g, (function (e) { return e[1].toUpperCase() })) } var fs = function (e, t, i, s) { void 0 === i && (i = 0); var n = us(e).attr("data-lg-size") || s; if (n) { var r = n.split(","); if (r[1]) for (var o = window.innerWidth, a = 0; a < r.length; a++) { var l = r[a]; if (parseInt(l.split("-")[2], 10) > o) { n = l; break } a === r.length - 1 && (n = l) } var d = n.split("-"), c = parseInt(d[0], 10), u = parseInt(d[1], 10), h = t.width(), p = t.height() - i, f = Math.min(h, c), m = Math.min(p, u), g = Math.min(f / c, m / u); return { width: c * g, height: u * g } } }, ms = function (e, t, i, s, n) { if (n) { var r = us(e).find("img").first(); if (r.get()) { var o = t.get().getBoundingClientRect(), a = o.width, l = t.height() - (i + s), d = r.width(), c = r.height(), u = r.style(), h = (a - d) / 2 - r.offset().left + (parseFloat(u.paddingLeft) || 0) + (parseFloat(u.borderLeft) || 0) + us(window).scrollLeft() + o.left, p = (l - c) / 2 - r.offset().top + (parseFloat(u.paddingTop) || 0) + (parseFloat(u.borderTop) || 0) + us(window).scrollTop() + i; return "translate3d(" + (h *= -1) + "px, " + (p *= -1) + "px, 0) scale3d(" + d / n.width + ", " + c / n.height + ", 1)" } } }, gs = function (e, t, i, s, n, r) { return '<div class="lg-video-cont lg-has-iframe" style="width:' + e + "; max-width:" + i + "; height: " + t + "; max-height:" + s + '">\n                    <iframe class="lg-object" frameborder="0" ' + (r ? 'title="' + r + '"' : "") + ' src="' + n + '"  allowfullscreen="true"></iframe>\n                </div>' }, vs = function (e, t, i, s, n, r) { var o = "<img " + i + " " + (s ? 'srcset="' + s + '"' : "") + "  " + (n ? 'sizes="' + n + '"' : "") + ' class="lg-object lg-image" data-index="' + e + '" src="' + t + '" />', a = ""; r && (a = ("string" == typeof r ? JSON.parse(r) : r).map((function (e) { var t = ""; return Object.keys(e).forEach((function (i) { t += " " + i + '="' + e[i] + '"' })), "<source " + t + "></source>" }))); return "" + a + o }, ys = function (e) { for (var t = [], i = [], s = "", n = 0; n < e.length; n++) { var r = e[n].split(" "); "" === r[0] && r.splice(0, 1), i.push(r[0]), t.push(r[1]) } for (var o = window.innerWidth, a = 0; a < t.length; a++)if (parseInt(t[a], 10) > o) { s = i[a]; break } return s }, bs = function (e) { return !!e && (!!e.complete && 0 !== e.naturalWidth) }, ws = function (e, t, i, s, n) { return '<div class="lg-video-cont ' + (n && n.youtube ? "lg-has-youtube" : n && n.vimeo ? "lg-has-vimeo" : "lg-has-html5") + '" style="' + i + '">\n                <div class="lg-video-play-button">\n                <svg\n                    viewBox="0 0 20 20"\n                    preserveAspectRatio="xMidYMid"\n                    focusable="false"\n                    aria-labelledby="' + s + '"\n                    role="img"\n                    class="lg-video-play-icon"\n                >\n                    <title>' + s + '</title>\n                    <polygon class="lg-video-play-icon-inner" points="1,0 20,10 1,20"></polygon>\n                </svg>\n                <svg class="lg-video-play-icon-bg" viewBox="0 0 50 50" focusable="false">\n                    <circle cx="50%" cy="50%" r="20"></circle></svg>\n                <svg class="lg-video-play-icon-circle" viewBox="0 0 50 50" focusable="false">\n                    <circle cx="50%" cy="50%" r="20"></circle>\n                </svg>\n            </div>\n            ' + (t || "") + '\n            <img class="lg-object lg-video-poster" src="' + e + '" />\n        </div>' }, Ss = function (e, t, i, s) { var n = [], r = function () { for (var e = 0, t = 0, i = arguments.length; t < i; t++)e += arguments[t].length; var s = Array(e), n = 0; for (t = 0; t < i; t++)for (var r = arguments[t], o = 0, a = r.length; o < a; o++, n++)s[n] = r[o]; return s }(hs, t); return [].forEach.call(e, (function (e) { for (var t = {}, o = 0; o < e.attributes.length; o++) { var a = e.attributes[o]; if (a.specified) { var l = ps(a.name), d = ""; r.indexOf(l) > -1 && (d = l), d && (t[d] = a.value) } } var c = us(e), u = c.find("img").first().attr("alt"), h = c.attr("title"), p = s ? c.attr(s) : c.find("img").first().attr("src"); t.thumb = p, i && !t.subHtml && (t.subHtml = h || u || ""), t.alt = u || h || "", n.push(t) })), n }, xs = function () { return /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) }, Cs = function (e, t, i) { if (!e) return t ? { html5: !0 } : void console.error("lightGallery :- data-src is not provided on slide item " + (i + 1) + ". Please make sure the selector property is properly configured. More info - https://www.lightgalleryjs.com/demos/html-markup/"); var s = e.match(/\/\/(?:www\.)?youtu(?:\.be|be\.com|be-nocookie\.com)\/(?:watch\?v=|embed\/)?([a-z0-9\-\_\%]+)([\&|?][\S]*)*/i), n = e.match(/\/\/(?:www\.)?(?:player\.)?vimeo.com\/(?:video\/)?([0-9a-z\-_]+)(.*)?/i), r = e.match(/https?:\/\/(.+)?(wistia\.com|wi\.st)\/(medias|embed)\/([0-9a-z\-_]+)(.*)/); return s ? { youtube: s } : n ? { vimeo: n } : r ? { wistia: r } : void 0 }, Es = 0, Ts = function () { function e(e, t) { if (this.lgOpened = !1, this.index = 0, this.plugins = [], this.lGalleryOn = !1, this.lgBusy = !1, this.currentItemsInDom = [], this.prevScrollTop = 0, this.isDummyImageRemoved = !1, this.dragOrSwipeEnabled = !1, this.mediaContainerPosition = { top: 0, bottom: 0 }, !e) return this; if (Es++, this.lgId = Es, this.el = e, this.LGel = us(e), this.generateSettings(t), this.buildModules(), this.settings.dynamic && void 0 !== this.settings.dynamicEl && !Array.isArray(this.settings.dynamicEl)) throw "When using dynamic mode, you must also define dynamicEl as an Array."; return this.galleryItems = this.getItems(), this.normalizeSettings(), this.init(), this.validateLicense(), this } return e.prototype.generateSettings = function (e) { if (this.settings = qi(qi({}, ds), e), this.settings.isMobile && "function" == typeof this.settings.isMobile ? this.settings.isMobile() : xs()) { var t = qi(qi({}, this.settings.mobileSettings), this.settings.mobileSettings); this.settings = qi(qi({}, this.settings), t) } }, e.prototype.normalizeSettings = function () { this.settings.slideEndAnimation && (this.settings.hideControlOnEnd = !1), this.settings.closable || (this.settings.swipeToClose = !1), this.zoomFromOrigin = this.settings.zoomFromOrigin, this.settings.dynamic && (this.zoomFromOrigin = !1), this.settings.container || (this.settings.container = document.body), this.settings.preload = Math.min(this.settings.preload, this.galleryItems.length) }, e.prototype.init = function () { var e = this; this.addSlideVideoInfo(this.galleryItems), this.buildStructure(), this.LGel.trigger(Ri, { instance: this }), this.settings.keyPress && this.keyPress(), setTimeout((function () { e.enableDrag(), e.enableSwipe(), e.triggerPosterClick() }), 50), this.arrow(), this.settings.mousewheel && this.mousewheel(), this.settings.dynamic || this.openGalleryOnItemClick() }, e.prototype.openGalleryOnItemClick = function () { for (var e = this, t = function (t) { var s = i.items[t], n = us(s), r = cs.generateUUID(); n.attr("data-lg-id", r).on("click.lgcustom-item-" + r, (function (i) { i.preventDefault(); var n = e.settings.index || t; e.openGallery(n, s) })) }, i = this, s = 0; s < this.items.length; s++)t(s) }, e.prototype.buildModules = function () { var e = this; this.settings.plugins.forEach((function (t) { e.plugins.push(new t(e, us)) })) }, e.prototype.validateLicense = function () { this.settings.licenseKey ? "0000-0000-000-0000" === this.settings.licenseKey && console.warn("lightGallery: " + this.settings.licenseKey + " license key is not valid for production use") : console.error("Please provide a valid license key") }, e.prototype.getSlideItem = function (e) { return us(this.getSlideItemId(e)) }, e.prototype.getSlideItemId = function (e) { return "#lg-item-" + this.lgId + "-" + e }, e.prototype.getIdName = function (e) { return e + "-" + this.lgId }, e.prototype.getElementById = function (e) { return us("#" + this.getIdName(e)) }, e.prototype.manageSingleSlideClassName = function () { this.galleryItems.length < 2 ? this.outer.addClass("lg-single-item") : this.outer.removeClass("lg-single-item") }, e.prototype.buildStructure = function () { var e = this; if (!(this.$container && this.$container.get())) { var t = "", i = ""; this.settings.controls && (t = '<button type="button" id="' + this.getIdName("lg-prev") + '" aria-label="' + this.settings.strings.previousSlide + '" class="lg-prev lg-icon"> ' + this.settings.prevHtml + ' </button>\n                <button type="button" id="' + this.getIdName("lg-next") + '" aria-label="' + this.settings.strings.nextSlide + '" class="lg-next lg-icon"> ' + this.settings.nextHtml + " </button>"), ".lg-item" !== this.settings.appendSubHtmlTo && (i = '<div class="lg-sub-html" role="status" aria-live="polite"></div>'); var s = ""; this.settings.allowMediaOverlap && (s += "lg-media-overlap "); var n = this.settings.ariaLabelledby ? 'aria-labelledby="' + this.settings.ariaLabelledby + '"' : "", r = this.settings.ariaDescribedby ? 'aria-describedby="' + this.settings.ariaDescribedby + '"' : "", o = "lg-container " + this.settings.addClass + " " + (document.body !== this.settings.container ? "lg-inline" : ""), a = this.settings.closable && this.settings.showCloseIcon ? '<button type="button" aria-label="' + this.settings.strings.closeGallery + '" id="' + this.getIdName("lg-close") + '" class="lg-close lg-icon"></button>' : "", l = this.settings.showMaximizeIcon ? '<button type="button" aria-label="' + this.settings.strings.toggleMaximize + '" id="' + this.getIdName("lg-maximize") + '" class="lg-maximize lg-icon"></button>' : "", d = '\n        <div class="' + o + '" id="' + this.getIdName("lg-container") + '" tabindex="-1" aria-modal="true" ' + n + " " + r + ' role="dialog"\n        >\n            <div id="' + this.getIdName("lg-backdrop") + '" class="lg-backdrop"></div>\n\n            <div id="' + this.getIdName("lg-outer") + '" class="lg-outer lg-use-css3 lg-css3 lg-hide-items ' + s + ' ">\n\n              <div id="' + this.getIdName("lg-content") + '" class="lg-content">\n                <div id="' + this.getIdName("lg-inner") + '" class="lg-inner">\n                </div>\n                ' + t + '\n              </div>\n                <div id="' + this.getIdName("lg-toolbar") + '" class="lg-toolbar lg-group">\n                    ' + l + "\n                    " + a + "\n                    </div>\n                    " + (".lg-outer" === this.settings.appendSubHtmlTo ? i : "") + '\n                <div id="' + this.getIdName("lg-components") + '" class="lg-components">\n                    ' + (".lg-sub-html" === this.settings.appendSubHtmlTo ? i : "") + "\n                </div>\n            </div>\n        </div>\n        "; us(this.settings.container).append(d), document.body !== this.settings.container && us(this.settings.container).css("position", "relative"), this.outer = this.getElementById("lg-outer"), this.$lgComponents = this.getElementById("lg-components"), this.$backdrop = this.getElementById("lg-backdrop"), this.$container = this.getElementById("lg-container"), this.$inner = this.getElementById("lg-inner"), this.$content = this.getElementById("lg-content"), this.$toolbar = this.getElementById("lg-toolbar"), this.$backdrop.css("transition-duration", this.settings.backdropDuration + "ms"); var c = this.settings.mode + " "; this.manageSingleSlideClassName(), this.settings.enableDrag && (c += "lg-grab "), this.outer.addClass(c), this.$inner.css("transition-timing-function", this.settings.easing), this.$inner.css("transition-duration", this.settings.speed + "ms"), this.settings.download && this.$toolbar.append('<a id="' + this.getIdName("lg-download") + '" target="_blank" rel="noopener" aria-label="' + this.settings.strings.download + '" download class="lg-download lg-icon"></a>'), this.counter(), us(window).on("resize.lg.global" + this.lgId + " orientationchange.lg.global" + this.lgId, (function () { e.refreshOnResize() })), this.hideBars(), this.manageCloseGallery(), this.toggleMaximize(), this.initModules() } }, e.prototype.refreshOnResize = function () { if (this.lgOpened) { var e = this.galleryItems[this.index].__slideVideoInfo; this.mediaContainerPosition = this.getMediaContainerPosition(); var t = this.mediaContainerPosition, i = t.top, s = t.bottom; if (this.currentImageSize = fs(this.items[this.index], this.outer, i + s, e && this.settings.videoMaxSize), e && this.resizeVideoSlide(this.index, this.currentImageSize), this.zoomFromOrigin && !this.isDummyImageRemoved) { var n = this.getDummyImgStyles(this.currentImageSize); this.outer.find(".lg-current .lg-dummy-img").first().attr("style", n) } this.LGel.trigger(Wi) } }, e.prototype.resizeVideoSlide = function (e, t) { var i = this.getVideoContStyle(t); this.getSlideItem(e).find(".lg-video-cont").attr("style", i) }, e.prototype.updateSlides = function (e, t) { if (this.index > e.length - 1 && (this.index = e.length - 1), 1 === e.length && (this.index = 0), e.length) { var i = this.galleryItems[t].src; this.galleryItems = e, this.updateControls(), this.$inner.empty(), this.currentItemsInDom = []; var s = 0; this.galleryItems.some((function (e, t) { return e.src === i && (s = t, !0) })), this.currentItemsInDom = this.organizeSlideItems(s, -1), this.loadContent(s, !0), this.getSlideItem(s).addClass("lg-current"), this.index = s, this.updateCurrentCounter(s), this.LGel.trigger(Yi) } else this.closeGallery() }, e.prototype.getItems = function () { if (this.items = [], this.settings.dynamic) return this.settings.dynamicEl || []; if ("this" === this.settings.selector) this.items.push(this.el); else if (this.settings.selector) if ("string" == typeof this.settings.selector) if (this.settings.selectWithin) { var e = us(this.settings.selectWithin); this.items = e.find(this.settings.selector).get() } else this.items = this.el.querySelectorAll(this.settings.selector); else this.items = this.settings.selector; else this.items = this.el.children; return Ss(this.items, this.settings.extraProps, this.settings.getCaptionFromTitleOrAlt, this.settings.exThumbImage) }, e.prototype.openGallery = function (e, t) { var i = this; if (void 0 === e && (e = this.settings.index), !this.lgOpened) { this.lgOpened = !0, this.outer.get().focus(), this.outer.removeClass("lg-hide-items"), this.$container.addClass("lg-show"); var s = this.getItemsToBeInsertedToDom(e, e); this.currentItemsInDom = s; var n = ""; s.forEach((function (e) { n = n + '<div id="' + e + '" class="lg-item"></div>' })), this.$inner.append(n), this.addHtml(e); var r = ""; this.mediaContainerPosition = this.getMediaContainerPosition(); var o = this.mediaContainerPosition, a = o.top, l = o.bottom; this.settings.allowMediaOverlap || this.setMediaContainerPosition(a, l); var d = this.galleryItems[e].__slideVideoInfo; this.zoomFromOrigin && t && (this.currentImageSize = fs(t, this.outer, a + l, d && this.settings.videoMaxSize), r = ms(t, this.outer, a, l, this.currentImageSize)), this.zoomFromOrigin && r || (this.outer.addClass(this.settings.startClass), this.getSlideItem(e).removeClass("lg-complete")); var c = this.settings.zoomFromOrigin ? 100 : this.settings.backdropDuration; setTimeout((function () { i.outer.addClass("lg-components-open") }), c), this.index = e, this.LGel.trigger(Ki), this.getSlideItem(e).addClass("lg-current"), this.lGalleryOn = !1, this.prevScrollTop = us(window).scrollTop(), setTimeout((function () { if (i.zoomFromOrigin && r) { var t = i.getSlideItem(e); t.css("transform", r), setTimeout((function () { t.addClass("lg-start-progress lg-start-end-progress").css("transition-duration", i.settings.startAnimationDuration + "ms"), i.outer.addClass("lg-zoom-from-image") })), setTimeout((function () { t.css("transform", "translate3d(0, 0, 0)") }), 100) } setTimeout((function () { i.$backdrop.addClass("in"), i.$container.addClass("lg-show-in") }), 10), i.zoomFromOrigin && r || setTimeout((function () { i.outer.addClass("lg-visible") }), i.settings.backdropDuration), i.slide(e, !1, !1, !1), i.LGel.trigger(Zi) })), document.body === this.settings.container && us("html").addClass("lg-on") } }, e.prototype.getMediaContainerPosition = function () { if (this.settings.allowMediaOverlap) return { top: 0, bottom: 0 }; var e = this.$toolbar.get().clientHeight || 0, t = this.outer.find(".lg-components .lg-sub-html").get(), i = this.settings.defaultCaptionHeight || t && t.clientHeight || 0, s = this.outer.find(".lg-thumb-outer").get(); return { top: e, bottom: (s ? s.clientHeight : 0) + i } }, e.prototype.setMediaContainerPosition = function (e, t) { void 0 === e && (e = 0), void 0 === t && (t = 0), this.$content.css("top", e + "px").css("bottom", t + "px") }, e.prototype.hideBars = function () { var e = this; setTimeout((function () { e.outer.removeClass("lg-hide-items"), e.settings.hideBarsDelay > 0 && (e.outer.on("mousemove.lg click.lg touchstart.lg", (function () { e.outer.removeClass("lg-hide-items"), clearTimeout(e.hideBarTimeout), e.hideBarTimeout = setTimeout((function () { e.outer.addClass("lg-hide-items") }), e.settings.hideBarsDelay) })), e.outer.trigger("mousemove.lg")) }), this.settings.showBarsAfter) }, e.prototype.initPictureFill = function (e) { if (this.settings.supportLegacyBrowser) try { picturefill({ elements: [e.get()] }) } catch (e) { console.warn("lightGallery :- If you want srcset or picture tag to be supported for older browser please include picturefil javascript library in your document.") } }, e.prototype.counter = function () { if (this.settings.counter) { var e = '<div class="lg-counter" role="status" aria-live="polite">\n                <span id="' + this.getIdName("lg-counter-current") + '" class="lg-counter-current">' + (this.index + 1) + ' </span> /\n                <span id="' + this.getIdName("lg-counter-all") + '" class="lg-counter-all">' + this.galleryItems.length + " </span></div>"; this.outer.find(this.settings.appendCounterTo).append(e) } }, e.prototype.addHtml = function (e) { var t, i; if (this.galleryItems[e].subHtmlUrl ? i = this.galleryItems[e].subHtmlUrl : t = this.galleryItems[e].subHtml, !i) if (t) { var s = t.substring(0, 1); "." !== s && "#" !== s || (t = this.settings.subHtmlSelectorRelative && !this.settings.dynamic ? us(this.items).eq(e).find(t).first().html() : us(t).first().html()) } else t = ""; if (".lg-item" !== this.settings.appendSubHtmlTo) i ? this.outer.find(".lg-sub-html").load(i) : this.outer.find(".lg-sub-html").html(t); else { var n = us(this.getSlideItemId(e)); i ? n.load(i) : n.append('<div class="lg-sub-html">' + t + "</div>") } null != t && ("" === t ? this.outer.find(this.settings.appendSubHtmlTo).addClass("lg-empty-html") : this.outer.find(this.settings.appendSubHtmlTo).removeClass("lg-empty-html")), this.LGel.trigger(Xi, { index: e }) }, e.prototype.preload = function (e) { for (var t = 1; t <= this.settings.preload && !(t >= this.galleryItems.length - e); t++)this.loadContent(e + t, !1); for (var i = 1; i <= this.settings.preload && !(e - i < 0); i++)this.loadContent(e - i, !1) }, e.prototype.getDummyImgStyles = function (e) { return e ? "width:" + e.width + "px;\n                margin-left: -" + e.width / 2 + "px;\n                margin-top: -" + e.height / 2 + "px;\n                height:" + e.height + "px" : "" }, e.prototype.getVideoContStyle = function (e) { return e ? "width:" + e.width + "px;\n                height:" + e.height + "px" : "" }, e.prototype.getDummyImageContent = function (e, t, i) { var s; if (this.settings.dynamic || (s = us(this.items).eq(t)), s) { var n = void 0; if (!(n = this.settings.exThumbImage ? s.attr(this.settings.exThumbImage) : s.find("img").first().attr("src"))) return ""; var r = "<img " + i + ' style="' + this.getDummyImgStyles(this.currentImageSize) + '" class="lg-dummy-img" src="' + n + '" />'; return e.addClass("lg-first-slide"), this.outer.addClass("lg-first-slide-loading"), r } return "" }, e.prototype.setImgMarkup = function (e, t, i) { var s = this.galleryItems[i], n = s.alt, r = s.srcset, o = s.sizes, a = s.sources, l = n ? 'alt="' + n + '"' : "", d = '<picture class="lg-img-wrap"> ' + (this.isFirstSlideWithZoomAnimation() ? this.getDummyImageContent(t, i, l) : vs(i, e, l, r, o, a)) + "</picture>"; t.prepend(d) }, e.prototype.onSlideObjectLoad = function (e, t, i, s) { var n = e.find(".lg-object").first(); bs(n.get()) || t ? i() : (n.on("load.lg error.lg", (function () { i && i() })), n.on("error.lg", (function () { s && s() }))) }, e.prototype.onLgObjectLoad = function (e, t, i, s, n, r) { var o = this; this.onSlideObjectLoad(e, r, (function () { o.triggerSlideItemLoad(e, t, i, s, n) }), (function () { e.addClass("lg-complete lg-complete_"), e.html('<span class="lg-error-msg">Oops... Failed to load content...</span>') })) }, e.prototype.triggerSlideItemLoad = function (e, t, i, s, n) { var r = this, o = this.galleryItems[t], a = n && "video" === this.getSlideType(o) && !o.poster ? s : 0; setTimeout((function () { e.addClass("lg-complete lg-complete_"), r.LGel.trigger(Ji, { index: t, delay: i || 0, isFirstSlide: n }) }), a) }, e.prototype.isFirstSlideWithZoomAnimation = function () { return !(this.lGalleryOn || !this.zoomFromOrigin || !this.currentImageSize) }, e.prototype.addSlideVideoInfo = function (e) { var t = this; e.forEach((function (e, i) { e.__slideVideoInfo = Cs(e.src, !!e.video, i), e.__slideVideoInfo && t.settings.loadYouTubePoster && !e.poster && e.__slideVideoInfo.youtube && (e.poster = "//img.youtube.com/vi/" + e.__slideVideoInfo.youtube[1] + "/maxresdefault.jpg") })) }, e.prototype.loadContent = function (e, t) { var i = this, s = this.galleryItems[e], n = us(this.getSlideItemId(e)), r = s.poster, o = s.srcset, a = s.sizes, l = s.sources, d = s.src, c = s.video, u = c && "string" == typeof c ? JSON.parse(c) : c; if (s.responsive) { var h = s.responsive.split(","); d = ys(h) || d } var p = s.__slideVideoInfo, f = "", m = !!s.iframe, g = !this.lGalleryOn, v = 0; if (g && (v = this.zoomFromOrigin && this.currentImageSize ? this.settings.startAnimationDuration + 10 : this.settings.backdropDuration + 10), !n.hasClass("lg-loaded")) { if (p) { var y = this.mediaContainerPosition, b = y.top, w = y.bottom, S = fs(this.items[e], this.outer, b + w, p && this.settings.videoMaxSize); f = this.getVideoContStyle(S) } if (m) { var x = gs(this.settings.iframeWidth, this.settings.iframeHeight, this.settings.iframeMaxWidth, this.settings.iframeMaxHeight, d, s.iframeTitle); n.prepend(x) } else if (r) { var C = ""; g && this.zoomFromOrigin && this.currentImageSize && (C = this.getDummyImageContent(n, e, "")); x = ws(r, C || "", f, this.settings.strings.playVideo, p); n.prepend(x) } else if (p) { x = '<div class="lg-video-cont " style="' + f + '"></div>'; n.prepend(x) } else if (this.setImgMarkup(d, n, e), o || l) { var E = n.find(".lg-object"); this.initPictureFill(E) } (r || p) && this.LGel.trigger(Ui, { index: e, src: d, html5Video: u, hasPoster: !!r }), this.LGel.trigger(Gi, { index: e }), this.lGalleryOn && ".lg-item" === this.settings.appendSubHtmlTo && this.addHtml(e) } var T = 0; v && !us(document.body).hasClass("lg-from-hash") && (T = v), this.isFirstSlideWithZoomAnimation() && (setTimeout((function () { n.removeClass("lg-start-end-progress lg-start-progress").removeAttr("style") }), this.settings.startAnimationDuration + 100), n.hasClass("lg-loaded") || setTimeout((function () { if ("image" === i.getSlideType(s) && (n.find(".lg-img-wrap").append(vs(e, d, "", o, a, s.sources)), o || l)) { var t = n.find(".lg-object"); i.initPictureFill(t) } ("image" === i.getSlideType(s) || "video" === i.getSlideType(s) && r) && (i.onLgObjectLoad(n, e, v, T, !0, !1), i.onSlideObjectLoad(n, !(!p || !p.html5 || r), (function () { i.loadContentOnFirstSlideLoad(e, n, T) }), (function () { i.loadContentOnFirstSlideLoad(e, n, T) }))) }), this.settings.startAnimationDuration + 100)), n.addClass("lg-loaded"), this.isFirstSlideWithZoomAnimation() && ("video" !== this.getSlideType(s) || r) || this.onLgObjectLoad(n, e, v, T, g, !(!p || !p.html5 || r)), this.zoomFromOrigin && this.currentImageSize || !n.hasClass("lg-complete_") || this.lGalleryOn || setTimeout((function () { n.addClass("lg-complete") }), this.settings.backdropDuration), this.lGalleryOn = !0, !0 === t && (n.hasClass("lg-complete_") ? this.preload(e) : n.find(".lg-object").first().on("load.lg error.lg", (function () { i.preload(e) }))) }, e.prototype.loadContentOnFirstSlideLoad = function (e, t, i) { var s = this; setTimeout((function () { t.find(".lg-dummy-img").remove(), t.removeClass("lg-first-slide"), s.outer.removeClass("lg-first-slide-loading"), s.isDummyImageRemoved = !0, s.preload(e) }), i + 300) }, e.prototype.getItemsToBeInsertedToDom = function (e, t, i) { var s = this; void 0 === i && (i = 0); var n = [], r = Math.max(i, 3); r = Math.min(r, this.galleryItems.length); var o = "lg-item-" + this.lgId + "-" + t; if (this.galleryItems.length <= 3) return this.galleryItems.forEach((function (e, t) { n.push("lg-item-" + s.lgId + "-" + t) })), n; if (e < (this.galleryItems.length - 1) / 2) { for (var a = e; a > e - r / 2 && a >= 0; a--)n.push("lg-item-" + this.lgId + "-" + a); var l = n.length; for (a = 0; a < r - l; a++)n.push("lg-item-" + this.lgId + "-" + (e + a + 1)) } else { for (a = e; a <= this.galleryItems.length - 1 && a < e + r / 2; a++)n.push("lg-item-" + this.lgId + "-" + a); for (l = n.length, a = 0; a < r - l; a++)n.push("lg-item-" + this.lgId + "-" + (e - a - 1)) } return this.settings.loop && (e === this.galleryItems.length - 1 ? n.push("lg-item-" + this.lgId + "-0") : 0 === e && n.push("lg-item-" + this.lgId + "-" + (this.galleryItems.length - 1))), -1 === n.indexOf(o) && n.push("lg-item-" + this.lgId + "-" + t), n }, e.prototype.organizeSlideItems = function (e, t) { var i = this, s = this.getItemsToBeInsertedToDom(e, t, this.settings.numberOfSlideItemsInDom); return s.forEach((function (e) { -1 === i.currentItemsInDom.indexOf(e) && i.$inner.append('<div id="' + e + '" class="lg-item"></div>') })), this.currentItemsInDom.forEach((function (e) { -1 === s.indexOf(e) && us("#" + e).remove() })), s }, e.prototype.getPreviousSlideIndex = function () { var e = 0; try { var t = this.outer.find(".lg-current").first().attr("id"); e = parseInt(t.split("-")[3]) || 0 } catch (t) { e = 0 } return e }, e.prototype.setDownloadValue = function (e) { if (this.settings.download) { var t = this.galleryItems[e]; if (!1 === t.downloadUrl || "false" === t.downloadUrl) this.outer.addClass("lg-hide-download"); else { var i = this.getElementById("lg-download"); this.outer.removeClass("lg-hide-download"), i.attr("href", t.downloadUrl || t.src), t.download && i.attr("download", t.download) } } }, e.prototype.makeSlideAnimation = function (e, t, i) { var s = this; this.lGalleryOn && i.addClass("lg-slide-progress"), setTimeout((function () { s.outer.addClass("lg-no-trans"), s.outer.find(".lg-item").removeClass("lg-prev-slide lg-next-slide"), "prev" === e ? (t.addClass("lg-prev-slide"), i.addClass("lg-next-slide")) : (t.addClass("lg-next-slide"), i.addClass("lg-prev-slide")), setTimeout((function () { s.outer.find(".lg-item").removeClass("lg-current"), t.addClass("lg-current"), s.outer.removeClass("lg-no-trans") }), 50) }), this.lGalleryOn ? this.settings.slideDelay : 0) }, e.prototype.slide = function (e, t, i, s) { var n = this, r = this.getPreviousSlideIndex(); if (this.currentItemsInDom = this.organizeSlideItems(e, r), !this.lGalleryOn || r !== e) { var o = this.galleryItems.length; if (!this.lgBusy) { this.settings.counter && this.updateCurrentCounter(e); var a = this.getSlideItem(e), l = this.getSlideItem(r), d = this.galleryItems[e], c = d.__slideVideoInfo; if (this.outer.attr("data-lg-slide-type", this.getSlideType(d)), this.setDownloadValue(e), c) { var u = this.mediaContainerPosition, h = u.top, p = u.bottom, f = fs(this.items[e], this.outer, h + p, c && this.settings.videoMaxSize); this.resizeVideoSlide(e, f) } if (this.LGel.trigger(Qi, { prevIndex: r, index: e, fromTouch: !!t, fromThumb: !!i }), this.lgBusy = !0, clearTimeout(this.hideBarTimeout), this.arrowDisable(e), s || (e < r ? s = "prev" : e > r && (s = "next")), t) { this.outer.find(".lg-item").removeClass("lg-prev-slide lg-current lg-next-slide"); var m = void 0, g = void 0; o > 2 ? (m = e - 1, g = e + 1, (0 === e && r === o - 1 || e === o - 1 && 0 === r) && (g = 0, m = o - 1)) : (m = 0, g = 1), "prev" === s ? this.getSlideItem(g).addClass("lg-next-slide") : this.getSlideItem(m).addClass("lg-prev-slide"), a.addClass("lg-current") } else this.makeSlideAnimation(s, a, l); this.lGalleryOn ? setTimeout((function () { n.loadContent(e, !0), ".lg-item" !== n.settings.appendSubHtmlTo && n.addHtml(e) }), this.settings.speed + 50 + (t ? 0 : this.settings.slideDelay)) : this.loadContent(e, !0), setTimeout((function () { n.lgBusy = !1, l.removeClass("lg-slide-progress"), n.LGel.trigger(es, { prevIndex: r, index: e, fromTouch: t, fromThumb: i }) }), (this.lGalleryOn ? this.settings.speed + 100 : 100) + (t ? 0 : this.settings.slideDelay)) } this.index = e } }, e.prototype.updateCurrentCounter = function (e) { this.getElementById("lg-counter-current").html(e + 1 + "") }, e.prototype.updateCounterTotal = function () { this.getElementById("lg-counter-all").html(this.galleryItems.length + "") }, e.prototype.getSlideType = function (e) { return e.__slideVideoInfo ? "video" : e.iframe ? "iframe" : "image" }, e.prototype.touchMove = function (e, t, i) { var s = t.pageX - e.pageX, n = t.pageY - e.pageY, r = !1; if (this.swipeDirection ? r = !0 : Math.abs(s) > 15 ? (this.swipeDirection = "horizontal", r = !0) : Math.abs(n) > 15 && (this.swipeDirection = "vertical", r = !0), r) { var o = this.getSlideItem(this.index); if ("horizontal" === this.swipeDirection) { null == i || i.preventDefault(), this.outer.addClass("lg-dragging"), this.setTranslate(o, s, 0); var a = o.get().offsetWidth, l = 15 * a / 100 - Math.abs(10 * s / 100); this.setTranslate(this.outer.find(".lg-prev-slide").first(), -a + s - l, 0), this.setTranslate(this.outer.find(".lg-next-slide").first(), a + s + l, 0) } else if ("vertical" === this.swipeDirection && this.settings.swipeToClose) { null == i || i.preventDefault(), this.$container.addClass("lg-dragging-vertical"); var d = 1 - Math.abs(n) / window.innerHeight; this.$backdrop.css("opacity", d); var c = 1 - Math.abs(n) / (2 * window.innerWidth); this.setTranslate(o, 0, n, c, c), Math.abs(n) > 100 && this.outer.addClass("lg-hide-items").removeClass("lg-components-open") } } }, e.prototype.touchEnd = function (e, t, i) { var s, n = this; "lg-slide" !== this.settings.mode && this.outer.addClass("lg-slide"), setTimeout((function () { n.$container.removeClass("lg-dragging-vertical"), n.outer.removeClass("lg-dragging lg-hide-items").addClass("lg-components-open"); var r = !0; if ("horizontal" === n.swipeDirection) { s = e.pageX - t.pageX; var o = Math.abs(e.pageX - t.pageX); s < 0 && o > n.settings.swipeThreshold ? (n.goToNextSlide(!0), r = !1) : s > 0 && o > n.settings.swipeThreshold && (n.goToPrevSlide(!0), r = !1) } else if ("vertical" === n.swipeDirection) { if (s = Math.abs(e.pageY - t.pageY), n.settings.closable && n.settings.swipeToClose && s > 100) return void n.closeGallery(); n.$backdrop.css("opacity", 1) } if (n.outer.find(".lg-item").removeAttr("style"), r && Math.abs(e.pageX - t.pageX) < 5) { var a = us(i.target); n.isPosterElement(a) && n.LGel.trigger(ts) } n.swipeDirection = void 0 })), setTimeout((function () { n.outer.hasClass("lg-dragging") || "lg-slide" === n.settings.mode || n.outer.removeClass("lg-slide") }), this.settings.speed + 100) }, e.prototype.enableSwipe = function () { var e = this, t = {}, i = {}, s = !1, n = !1; this.settings.enableSwipe && (this.$inner.on("touchstart.lg", (function (i) { e.dragOrSwipeEnabled = !0; var s = e.getSlideItem(e.index); !us(i.target).hasClass("lg-item") && !s.get().contains(i.target) || e.outer.hasClass("lg-zoomed") || e.lgBusy || 1 !== i.targetTouches.length || (n = !0, e.touchAction = "swipe", e.manageSwipeClass(), t = { pageX: i.targetTouches[0].pageX, pageY: i.targetTouches[0].pageY }) })), this.$inner.on("touchmove.lg", (function (r) { n && "swipe" === e.touchAction && 1 === r.targetTouches.length && (i = { pageX: r.targetTouches[0].pageX, pageY: r.targetTouches[0].pageY }, e.touchMove(t, i, r), s = !0) })), this.$inner.on("touchend.lg", (function (r) { if ("swipe" === e.touchAction) { if (s) s = !1, e.touchEnd(i, t, r); else if (n) { var o = us(r.target); e.isPosterElement(o) && e.LGel.trigger(ts) } e.touchAction = void 0, n = !1 } }))) }, e.prototype.enableDrag = function () { var e = this, t = {}, i = {}, s = !1, n = !1; this.settings.enableDrag && (this.outer.on("mousedown.lg", (function (i) { e.dragOrSwipeEnabled = !0; var n = e.getSlideItem(e.index); (us(i.target).hasClass("lg-item") || n.get().contains(i.target)) && (e.outer.hasClass("lg-zoomed") || e.lgBusy || (i.preventDefault(), e.lgBusy || (e.manageSwipeClass(), t = { pageX: i.pageX, pageY: i.pageY }, s = !0, e.outer.get().scrollLeft += 1, e.outer.get().scrollLeft -= 1, e.outer.removeClass("lg-grab").addClass("lg-grabbing"), e.LGel.trigger(is)))) })), us(window).on("mousemove.lg.global" + this.lgId, (function (r) { s && e.lgOpened && (n = !0, i = { pageX: r.pageX, pageY: r.pageY }, e.touchMove(t, i), e.LGel.trigger(ss)) })), us(window).on("mouseup.lg.global" + this.lgId, (function (r) { if (e.lgOpened) { var o = us(r.target); n ? (n = !1, e.touchEnd(i, t, r), e.LGel.trigger(ns)) : e.isPosterElement(o) && e.LGel.trigger(ts), s && (s = !1, e.outer.removeClass("lg-grabbing").addClass("lg-grab")) } }))) }, e.prototype.triggerPosterClick = function () { var e = this; this.$inner.on("click.lg", (function (t) { !e.dragOrSwipeEnabled && e.isPosterElement(us(t.target)) && e.LGel.trigger(ts) })) }, e.prototype.manageSwipeClass = function () { var e = this.index + 1, t = this.index - 1; this.settings.loop && this.galleryItems.length > 2 && (0 === this.index ? t = this.galleryItems.length - 1 : this.index === this.galleryItems.length - 1 && (e = 0)), this.outer.find(".lg-item").removeClass("lg-next-slide lg-prev-slide"), t > -1 && this.getSlideItem(t).addClass("lg-prev-slide"), this.getSlideItem(e).addClass("lg-next-slide") }, e.prototype.goToNextSlide = function (e) { var t = this, i = this.settings.loop; e && this.galleryItems.length < 3 && (i = !1), this.lgBusy || (this.index + 1 < this.galleryItems.length ? (this.index++, this.LGel.trigger(rs, { index: this.index }), this.slide(this.index, !!e, !1, "next")) : i ? (this.index = 0, this.LGel.trigger(rs, { index: this.index }), this.slide(this.index, !!e, !1, "next")) : this.settings.slideEndAnimation && !e && (this.outer.addClass("lg-right-end"), setTimeout((function () { t.outer.removeClass("lg-right-end") }), 400))) }, e.prototype.goToPrevSlide = function (e) { var t = this, i = this.settings.loop; e && this.galleryItems.length < 3 && (i = !1), this.lgBusy || (this.index > 0 ? (this.index--, this.LGel.trigger(os, { index: this.index, fromTouch: e }), this.slide(this.index, !!e, !1, "prev")) : i ? (this.index = this.galleryItems.length - 1, this.LGel.trigger(os, { index: this.index, fromTouch: e }), this.slide(this.index, !!e, !1, "prev")) : this.settings.slideEndAnimation && !e && (this.outer.addClass("lg-left-end"), setTimeout((function () { t.outer.removeClass("lg-left-end") }), 400))) }, e.prototype.keyPress = function () { var e = this; us(window).on("keydown.lg.global" + this.lgId, (function (t) { e.lgOpened && !0 === e.settings.escKey && 27 === t.keyCode && (t.preventDefault(), e.settings.allowMediaOverlap && e.outer.hasClass("lg-can-toggle") && e.outer.hasClass("lg-components-open") ? e.outer.removeClass("lg-components-open") : e.closeGallery()), e.lgOpened && e.galleryItems.length > 1 && (37 === t.keyCode && (t.preventDefault(), e.goToPrevSlide()), 39 === t.keyCode && (t.preventDefault(), e.goToNextSlide())) })) }, e.prototype.arrow = function () { var e = this; this.getElementById("lg-prev").on("click.lg", (function () { e.goToPrevSlide() })), this.getElementById("lg-next").on("click.lg", (function () { e.goToNextSlide() })) }, e.prototype.arrowDisable = function (e) { if (!this.settings.loop && this.settings.hideControlOnEnd) { var t = this.getElementById("lg-prev"), i = this.getElementById("lg-next"); e + 1 === this.galleryItems.length ? i.attr("disabled", "disabled").addClass("disabled") : i.removeAttr("disabled").removeClass("disabled"), 0 === e ? t.attr("disabled", "disabled").addClass("disabled") : t.removeAttr("disabled").removeClass("disabled") } }, e.prototype.setTranslate = function (e, t, i, s, n) { void 0 === s && (s = 1), void 0 === n && (n = 1), e.css("transform", "translate3d(" + t + "px, " + i + "px, 0px) scale3d(" + s + ", " + n + ", 1)") }, e.prototype.mousewheel = function () { var e = this, t = 0; this.outer.on("wheel.lg", (function (i) { if (i.deltaY && !(e.galleryItems.length < 2)) { i.preventDefault(); var s = (new Date).getTime(); s - t < 1e3 || (t = s, i.deltaY > 0 ? e.goToNextSlide() : i.deltaY < 0 && e.goToPrevSlide()) } })) }, e.prototype.isSlideElement = function (e) { return e.hasClass("lg-outer") || e.hasClass("lg-item") || e.hasClass("lg-img-wrap") }, e.prototype.isPosterElement = function (e) { var t = this.getSlideItem(this.index).find(".lg-video-play-button").get(); return e.hasClass("lg-video-poster") || e.hasClass("lg-video-play-button") || t && t.contains(e.get()) }, e.prototype.toggleMaximize = function () { var e = this; this.getElementById("lg-maximize").on("click.lg", (function () { e.$container.toggleClass("lg-inline"), e.refreshOnResize() })) }, e.prototype.invalidateItems = function () { for (var e = 0; e < this.items.length; e++) { var t = us(this.items[e]); t.off("click.lgcustom-item-" + t.attr("data-lg-id")) } }, e.prototype.manageCloseGallery = function () { var e = this; if (this.settings.closable) { var t = !1; this.getElementById("lg-close").on("click.lg", (function () { e.closeGallery() })), this.settings.closeOnTap && (this.outer.on("mousedown.lg", (function (i) { var s = us(i.target); t = !!e.isSlideElement(s) })), this.outer.on("mousemove.lg", (function () { t = !1 })), this.outer.on("mouseup.lg", (function (i) { var s = us(i.target); e.isSlideElement(s) && t && (e.outer.hasClass("lg-dragging") || e.closeGallery()) }))) } }, e.prototype.closeGallery = function (e) { var t = this; if (!this.lgOpened || !this.settings.closable && !e) return 0; this.LGel.trigger(as), us(window).scrollTop(this.prevScrollTop); var i, s = this.items[this.index]; if (this.zoomFromOrigin && s) { var n = this.mediaContainerPosition, r = n.top, o = n.bottom, a = this.galleryItems[this.index], l = a.__slideVideoInfo, d = a.poster, c = fs(s, this.outer, r + o, l && d && this.settings.videoMaxSize); i = ms(s, this.outer, r, o, c) } this.zoomFromOrigin && i ? (this.outer.addClass("lg-closing lg-zoom-from-image"), this.getSlideItem(this.index).addClass("lg-start-end-progress").css("transition-duration", this.settings.startAnimationDuration + "ms").css("transform", i)) : (this.outer.addClass("lg-hide-items"), this.outer.removeClass("lg-zoom-from-image")), this.destroyModules(), this.lGalleryOn = !1, this.isDummyImageRemoved = !1, this.zoomFromOrigin = this.settings.zoomFromOrigin, clearTimeout(this.hideBarTimeout), this.hideBarTimeout = !1, us("html").removeClass("lg-on"), this.outer.removeClass("lg-visible lg-components-open"), this.$backdrop.removeClass("in").css("opacity", 0); var u = this.zoomFromOrigin && i ? Math.max(this.settings.startAnimationDuration, this.settings.backdropDuration) : this.settings.backdropDuration; return this.$container.removeClass("lg-show-in"), setTimeout((function () { t.zoomFromOrigin && i && t.outer.removeClass("lg-zoom-from-image"), t.$container.removeClass("lg-show"), t.$backdrop.removeAttr("style").css("transition-duration", t.settings.backdropDuration + "ms"), t.outer.removeClass("lg-closing " + t.settings.startClass), t.getSlideItem(t.index).removeClass("lg-start-end-progress"), t.$inner.empty(), t.lgOpened && t.LGel.trigger(ls, { instance: t }), t.outer.get() && t.outer.get().blur(), t.lgOpened = !1 }), u + 100), u + 100 }, e.prototype.initModules = function () { this.plugins.forEach((function (e) { try { e.init() } catch (e) { console.warn("lightGallery:- make sure lightGallery module is properly initiated") } })) }, e.prototype.destroyModules = function (e) { this.plugins.forEach((function (t) { try { e ? t.destroy() : t.closeGallery && t.closeGallery() } catch (e) { console.warn("lightGallery:- make sure lightGallery module is properly destroyed") } })) }, e.prototype.refresh = function (e) { this.settings.dynamic || this.invalidateItems(), this.galleryItems = e || this.getItems(), this.updateControls(), this.openGalleryOnItemClick(), this.LGel.trigger(Yi) }, e.prototype.updateControls = function () { this.addSlideVideoInfo(this.galleryItems), this.updateCounterTotal(), this.manageSingleSlideClassName() }, e.prototype.destroy = function () { var e = this, t = this.closeGallery(!0); return setTimeout((function () { e.destroyModules(!0), e.settings.dynamic || e.invalidateItems(), us(window).off(".lg.global" + e.lgId), e.LGel.off(".lg"), e.$container.remove() }), t), t }, e }(); const Ds = function (e, t) { return new Ts(e, t) }, ks = document.querySelectorAll("[data-gallery]"); ks.length && ks.forEach((e => { Ds(e, { licenseKey: "7EC452A9-0CFD441C-BD984C7C-17C8456E", speed: 500 }) })); const Ls = document.querySelectorAll(".swith-control__btn"); Ls.length > 0 && Ls.forEach(((e, t) => { e.addEventListener("click", (() => { document.querySelectorAll(".swith-control__btn").forEach((t => { t == e ? t.classList.add("active") : t.classList.remove("active") })); let t = document.querySelectorAll(".catEntity"), i = e.getAttribute("data-view"); t.length > 0 && t.forEach((e => { i == e.getAttribute("data-view") ? e.classList.add("active") : e.classList.remove("active") })) })) })); const _s = document.querySelector(".directory-management__filters-btn"), Os = document.querySelector(".page__sidebar"), Ms = document.querySelector(".page__main"); _s && _s.addEventListener("click", (function () { Os.classList.toggle("hide"), Ms.classList.toggle("width") })); const As = document.querySelectorAll(".range-input input"), Ps = document.querySelectorAll(".price-input input"), Is = document.querySelector(".slider .progress"); let $s = 1e3; Ps.forEach((e => { e.addEventListener("input", (e => { let t = parseInt(Ps[0].value), i = parseInt(Ps[1].value); i - t >= $s && i <= As[1].max && ("input-min" === e.target.className ? (As[0].value = t, Is.style.left = t / As[0].max * 100 + "%") : (As[1].value = i, Is.style.right = 100 - i / As[1].max * 100 + "%")) })) })), As.forEach((e => { e.addEventListener("input", (e => { let t = parseInt(As[0].value), i = parseInt(As[1].value); i - t < $s ? "range-min" === e.target.className ? As[0].value = i - $s : As[1].value = t + $s : (Ps[0].value = t, Ps[1].value = i, Is.style.left = t / As[0].max * 100 + "%", Is.style.right = 100 - i / As[1].max * 100 + "%") })) })); const Vs = Array.from(document.querySelectorAll("._like-icon-btn")), Ns = Array.from(document.querySelectorAll("._like-icon-count")); if (Vs.forEach(((e, t) => { e.addEventListener("click", (() => { e.classList.toggle("is-active"); const i = Number(Ns[t].innerHTML), s = e.classList.contains("is-active") ? 1 : -1; Ns[t].innerHTML = i + s })) })), "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0) try { for (var Hs in document.styleSheets) { var Bs = document.styleSheets[Hs]; if (Bs.rules) for (var Fs = Bs.rules.length - 1; Fs >= 0; Fs--)Bs.rules[Fs].selectorText && Bs.rules[Fs].selectorText.match(":hover") && Bs.deleteRule(Fs) } } catch (e) { } ({ el: document.querySelector(".btn-up"), show() { this.el.classList.remove("btn-up_hide") }, hide() { this.el.classList.add("btn-up_hide") }, addEventListener() { window.addEventListener("scroll", (() => { (window.scrollY || document.documentElement.scrollTop) > 400 ? this.show() : this.hide() })), document.querySelector(".btn-up").onclick = () => { window.scrollTo({ top: 0, left: 0, behavior: "smooth" }) } } }).addEventListener(); const zs = document.querySelectorAll(".menuTabOp"), js = document.querySelectorAll(".menuTable"); zs.forEach(((e, t) => { e.addEventListener("click", (() => { e.classList.contains("sidebar__menu-icon_active") ? js[t].classList.remove("_active") : (js.forEach((e => { e.classList.remove("_active"), window.addEventListener("click", (t => { t.target.closest(".table") || e.classList.remove("_active") })) })), js[t].classList.add("_active")) })) })); function qs() { let e = document.querySelector("body"), t = document.querySelectorAll("[data-lp]"); for (let e = 0; e < t.length; e++) { t[e].style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px" } e.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px", document.documentElement.classList.add("lock"), console.log("bloked") } function Gs() { let e = document.querySelector("body"), t = document.querySelectorAll("[data-lp]"); for (let e = 0; e < t.length; e++) { t[e].style.paddingRight = "0px" } e.style.paddingRight = "0px", document.documentElement.classList.remove("lock"), console.log("UN_bloked") } document.querySelectorAll(".form__viewpass").forEach((e => { e.onclick = t => { t.preventDefault(); let i = e.classList.contains("active") ? "password" : "text"; e.previousSibling.previousSibling.setAttribute("type", i), e.classList.toggle("active") } })); let Rs = ""; const Us = document.querySelector(".header"), Ws = document.getElementById("catBtn"), Ys = document.getElementById("catBtnCl"), Xs = document.getElementById("header-menu-catalog"), Ks = document.getElementById("iconMenu"), Zs = document.querySelector(".shadow"); function Js() { "searchFormInput" == Rs && dn(), Xs.classList.toggle("_active"), Ks.classList.toggle("_active"), Zs.classList.toggle("_active"), Us.classList.toggle("_active"), Rs = Xs.classList.contains("_active") ? "headerMenuCatalog" : "", console.log("Открыто: " + Rs), "headerMenuCatalog" == Rs ? qs() : Gs() } Ws.onclick = e => { e.preventDefault(), Js() }, Ys.onclick = e => { e.preventDefault(), Js() }; const Qs = document.querySelector(".main-mob-menu"), en = document.querySelector(".main-mob-menu__close"), tn = document.querySelector(".header__menu-burger"), sn = document.getElementById("btnCatMob"); tn && tn.addEventListener("click", (function () { Qs.classList.add("_active") })), en && en.addEventListener("click", (function () { Qs.classList.remove("_active"), Zs.classList.remove("_active") })), sn && sn.addEventListener("click", (function () { Qs.classList.remove("_active"), Ks.classList.add("_active"), Xs.classList.add("_active") })); const nn = document.getElementById("searchFormInput"), rn = document.querySelector(".search-form"), on = document.querySelector(".menu-search"), an = document.querySelector(".search-form__btn-closed"), ln = document.querySelectorAll(".interface__link-text"); function dn() { "headerMenuCatalog" == Rs && Js(), nn.classList.toggle("_active"), rn.classList.toggle("_active"), on.classList.toggle("_active"), an.classList.toggle("_active"), Zs.classList.toggle("_active"), Zs.style.zIndex = "150", Us.classList.toggle("_before"), ln.forEach((e => { e.classList.toggle("_none") })), Rs = nn.classList.contains("_active") ? "searchFormInput" : "", console.log("Открыто: " + Rs), "searchFormInput" == Rs ? qs() : Gs() } nn.onclick = e => { e.preventDefault(), dn() }, an.onclick = e => { e.preventDefault(), dn() }, document.documentElement.clientWidth > 1024 && document.addEventListener("DOMContentLoaded", (() => { window.onkeydown = function (e) { console.log(e.keyCode), console.log(Rs), 27 == e.keyCode && ("headerMenuCatalog" == Rs && Js(), "searchFormInput" == Rs && dn(), "physicalListPerson" == Rs && En(), "multicorzineLegalEntity" == Rs && bn()) } })), Zs && Zs.addEventListener("click", (function () { Js(), console.log("shadow") })); const cn = document.getElementById("cat-entity-input"), un = document.getElementById("cat-entity-cl"), hn = document.getElementById("cat-entity-menu-search"), pn = document.querySelector(".catalog-entity-sec"); if (cn && cn.addEventListener("click", (function () { hn.classList.add("_active"), un.classList.add("_active"), pn.classList.toggle("_before"), qs() })), un && un.addEventListener("click", (function () { hn.classList.remove("_active"), un.classList.remove("_active"), pn.classList.toggle("_before"), Gs() })), document.documentElement.clientWidth > 768) { const e = document.querySelectorAll(".menu-catalog__body .menu-lineBlock__item"); e.length > 0 && e.forEach(((e, t) => { e.addEventListener("mouseenter", (() => { let t = document.querySelectorAll(".menu-catalog__sub-menu__wrapper"), i = e.getAttribute("data-id"); t.length > 0 && t.forEach((e => { i == e.getAttribute("data-id") ? e.classList.add("active") : e.classList.remove("active") })) })) })) } else { const e = document.querySelectorAll(".menu-lineBlock__item svg"); if (e.length > 0) { e.forEach(((e, t) => { e.addEventListener("click", (() => { let t = document.querySelectorAll(".menu-catalog__body"), i = e.closest(".menu-lineBlock__item").getAttribute("data-id"); t.length > 0 && t.forEach((e => { i == e.getAttribute("data-id") ? e.classList.remove("drop-menu-catalog") : e.classList.add("drop-menu-catalog") })) })) })); document.querySelectorAll(".drop-menu-catalog__btn-back").forEach(((e, t) => { e.addEventListener("click", (() => { e.closest(".menu-catalog__body").classList.add("drop-menu-catalog"); let t = document.querySelector('.menu-catalog__body[data-id="0"]'); t?.classList.remove("drop-menu-catalog") })), Ys.addEventListener("click", (() => { e.closest(".menu-catalog__body").classList.add("drop-menu-catalog"); let t = document.querySelector('.menu-catalog__body[data-id="0"]'); t?.classList.remove("drop-menu-catalog") })) })) } } const fn = document.querySelectorAll(".menu-lineBlock__item"), mn = document.querySelector(".lineBlock-blk"); if (document.documentElement.clientWidth > 1024) for (let e = 0; e < fn.length; e++)fn[e].addEventListener("mouseenter", (t => { let i = fn[e].getElementsByClassName("sub-list")[0]; i && (i.classList.add("_active"), mn.classList.add("_active")) })), fn[e].addEventListener("mouseleave", (() => { let t = fn[e].getElementsByClassName("sub-list")[0]; t && (t.classList.remove("_active"), mn.classList.remove("_active")) })); const gn = document.querySelector(".header-legal-bascet-icon"), vn = document.querySelector(".physical-list-person"), yn = document.querySelector(".multicorzine-legal-entity__btn-close"); function bn() { vn.classList.toggle("_active"), Zs.classList.toggle("_active"), Rs = vn.classList.contains("_active") ? "multicorzineLegalEntity" : "", console.log("Открыто: " + Rs), "multicorzineLegalEntity" == Rs ? qs() : Gs() } gn && gn.addEventListener("click", (function () { bn() })), yn && yn.addEventListener("click", (function () { bn() })); const wn = document.querySelector(".physical-list-person"), Sn = document.querySelectorAll(".new-lists__card"), xn = document.getElementById("back-btn"), Cn = document.getElementById("physical-close"); function En() { wn.classList.toggle("_active"), Zs.classList.toggle("_active"), Rs = wn.classList.contains("_active") ? "physicalListPerson" : "", console.log("Открыто: " + Rs), "physicalListPerson" == Rs ? qs() : Gs() } var Tn; Sn.forEach((e => { e.addEventListener("click", (function () { En() })) })), xn && xn.addEventListener("click", (function () { En() })), Cn && Cn.addEventListener("click", (function () { En() })), function (e) { let t = new Image; t.onload = t.onerror = function () { e(2 == t.height) }, t.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA" }((function (e) { let t = !0 === e ? "webp" : "no-webp"; document.documentElement.classList.add(t) })), function () { if (document.querySelectorAll("[data-fullscreen]").length && n.any()) { function e() { let e = .01 * window.innerHeight; document.documentElement.style.setProperty("--vh", `${e}px`) } window.addEventListener("resize", e), e() } }(), function () { const e = document.querySelectorAll("[data-spollers]"); if (e.length > 0) { const t = Array.from(e).filter((function (e, t, i) { return !e.dataset.spollers.split(",")[0] })); t.length > 0 && s(t); const i = Array.from(e).filter((function (e, t, i) { return e.dataset.spollers.split(",")[0] })); if (i.length > 0) { const d = []; i.forEach((e => { const t = {}, i = e.dataset.spollers.split(","); t.value = i[0], t.type = i[1] ? i[1].trim() : "max", t.item = e, d.push(t) })); let c = d.map((function (e) { return "(" + e.type + "-width: " + e.value + "px)," + e.value + "," + e.type })); c = c.filter((function (e, t, i) { return i.indexOf(e) === t })), c.forEach((e => { const t = e.split(","), i = t[1], n = t[2], r = window.matchMedia(t[0]), o = d.filter((function (e) { if (e.value === i && e.type === n) return !0 })); r.addEventListener("change", (function () { s(o, r) })), s(o, r) })) } function s(e, t = !1) { e.forEach((e => { e = t ? e.item : e, t.matches || !t ? (e.classList.add("_spoller-init"), n(e), e.addEventListener("click", a)) : (e.classList.remove("_spoller-init"), n(e, !1), e.removeEventListener("click", a)) })) } function n(e, t = !0) { const i = e.querySelectorAll("[data-spoller]"); i.length > 0 && i.forEach((e => { t ? (e.removeAttribute("tabindex"), e.classList.contains("_spoller-active") || (e.nextElementSibling.hidden = !0)) : (e.setAttribute("tabindex", "-1"), e.nextElementSibling.hidden = !1) })) } function a(e) { const t = e.target; if (t.hasAttribute("data-spoller") || t.closest("[data-spoller]")) { const i = t.hasAttribute("data-spoller") ? t : t.closest("[data-spoller]"), s = i.closest("[data-spollers]"), n = !!s.hasAttribute("data-one-spoller"); s.querySelectorAll("._slide").length || (n && !i.classList.contains("_spoller-active") && l(s), i.classList.toggle("_spoller-active"), ((e, t = 500) => { e.hidden ? o(e, t) : r(e, t) })(i.nextElementSibling, 500)), e.preventDefault() } } function l(e) { const t = e.querySelector("[data-spoller]._spoller-active"); t && (t.classList.remove("_spoller-active"), r(t.nextElementSibling, 500)) } } }(), function () { const e = document.querySelectorAll("[data-tabs]"); let t = []; if (e.length > 0) { const n = location.hash.replace("#", ""); n.startsWith("tab-") && (t = n.replace("tab-", "").split("-")), e.forEach(((e, i) => { e.classList.add("_tab-init"), e.setAttribute("data-tabs-index", i), e.addEventListener("click", s), function (e) { const i = e.querySelectorAll("[data-tabs-titles]>*"), s = e.querySelectorAll("[data-tabs-body]>*"), n = e.dataset.tabsIndex, r = t[0] == n; if (r) { e.querySelector("[data-tabs-titles]>._tab-active").classList.remove("_tab-active") } s.length > 0 && s.forEach(((e, s) => { i[s].setAttribute("data-tabs-title", ""), e.setAttribute("data-tabs-item", ""), r && s == t[1] && i[s].classList.add("_tab-active"), e.hidden = !i[s].classList.contains("_tab-active") })) }(e) })); const r = Array.from(e).filter((function (e, t, i) { return e.dataset.tabs })); r.length > 0 && function (e) { const t = []; e.forEach((e => { const i = e.dataset.tabs, s = {}; s.value = i, s.item = e, t.push(s) })); let s = t.map((function (e) { return `(max-width:${e.value}px),${e.value}` })); s = s.filter((function (e, t, i) { return i.indexOf(e) === t })), s.forEach((e => { const s = e.split(","), n = window.matchMedia(s[0]), r = s[1], o = t.filter((function (e) { if (e.value === r) return !0 })); n.addEventListener("change", (function () { i(o, n) })), i(o, n) })) }(r) } function i(e, t) { e.forEach((e => { const i = (e = e.item).querySelector("[data-tabs-titles]"), s = e.querySelectorAll("[data-tabs-title]"), n = e.querySelector("[data-tabs-body]"); e.querySelectorAll("[data-tabs-item]").forEach(((r, o) => { t.matches ? (n.append(s[o]), n.append(r), e.classList.add("_tab-spoller")) : (i.append(s[o]), e.classList.remove("_tab-spoller")) })) })) } function s(e) { const t = e.target; if (t.closest("[data-tabs-title]")) { const i = t.closest("[data-tabs-title]"), s = i.closest("[data-tabs]"); if (!i.classList.contains("_tab-active") && !s.querySelectorAll("._slide").length) { const e = s.querySelector("[data-tabs-title]._tab-active"); e && e.classList.remove("_tab-active"), i.classList.add("_tab-active"), function (e) { const t = e.querySelectorAll("[data-tabs-title]"), i = e.querySelectorAll("[data-tabs-item]"), s = e.dataset.tabsIndex, n = function (e) { if (e.hasAttribute("data-tabs-animate")) return e.dataset.tabsAnimate > 0 ? e.dataset.tabsAnimate : 500 }(e); i.length > 0 && i.forEach(((e, i) => { t[i].classList.contains("_tab-active") ? (n ? o(e, n) : e.hidden = !1, location.hash = `tab-${s}-${i}`) : n ? r(e, n) : e.hidden = !0 })) }(s) } e.preventDefault() } } }(), function () { const e = document.querySelectorAll("[data-showmore]"); function t(e) { e.forEach((e => { !function (e) { const t = e.querySelector("[data-showmore-content]"), s = e.querySelector("[data-showmore-button]"), n = i(e, t); n < function (e) { let t = e.offsetHeight; e.style.removeProperty("height"); let i = e.offsetHeight; return e.style.height = `${t}px`, i }(t) && (r(t, 0, n), s.hidden = !1) }(e) })) } function i(e, t) { let i = 0; if ("items" === (e.dataset.showmore ? e.dataset.showmore : "size")) { const e = t.dataset.showmoreContent ? t.dataset.showmoreContent : 3, s = t.children; for (let t = 1; t < s.length; t++) { if (i += s[t - 1].offsetHeight, t === e) break } } else { i = t.dataset.showmoreContent ? t.dataset.showmoreContent : 150 } return i } function s(s) { const n = s.target, a = s.type; if ("click" === a) { if (n.closest("[data-showmore-button]")) { const e = n.closest("[data-showmore-button]").closest("[data-showmore]"), t = e.querySelector("[data-showmore-content]"), s = e.dataset.showmoreButton ? e.dataset.showmoreButton : "500", a = i(e, t); t.classList.contains("_slide") || (e.classList.contains("_showmore-active") ? r(t, s, a) : o(t, s, a), e.classList.toggle("_showmore-active")) } } else "resize" === a && t(e) } e.length && (t(e), document.addEventListener("click", s), window.addEventListener("resize", s)) }(), E(!0), function () { const e = document.querySelectorAll("input[placeholder],textarea[placeholder]"); e.length && e.forEach((e => { e.dataset.placeholder = e.placeholder })), document.body.addEventListener("focusin", (function (e) { const t = e.target; "INPUT" !== t.tagName && "TEXTAREA" !== t.tagName || (t.dataset.placeholder && (t.placeholder = ""), t.classList.add("_form-focus"), t.parentElement.classList.add("_form-focus"), M.removeError(t)) })), document.body.addEventListener("focusout", (function (e) { const t = e.target; "INPUT" !== t.tagName && "TEXTAREA" !== t.tagName || (t.dataset.placeholder && (t.placeholder = t.dataset.placeholder), t.hasAttribute("data-validate") && M.validateInput(t)) })) }(), function (e) { const t = document.forms; if (t.length) for (const e of t) e.addEventListener("submit", (function (e) { i(e.target, e) })), e.addEventListener("reset", (function (e) { const t = e.target; M.formClean(t) })); async function i(t, i) { if (0 === (e ? M.getErrors(t) : 0)) { const e = t.dataset.popup; if (t.hasAttribute("data-ajax")) { i.preventDefault(); const s = t.getAttribute("action") ? t.getAttribute("action").trim() : "#", n = t.getAttribute("method") ? t.getAttribute("method").trim() : "GET", r = new FormData(t); t.classList.add("_sending"); const o = await fetch(s, { method: n, body: r }); if (o.ok) { await o.json(); t.classList.remove("_sending"), e && (_.open(`#${e}`), console.log(_)), M.formClean(t) } else alert("Ошибка"), t.classList.remove("_sending") } t.hasAttribute("data-dev") && (i.preventDefault(), e && _.open(`#${e}`), M.formClean(t)) } else { i.preventDefault(); const e = t.querySelector("._form-error"); e && t.hasAttribute("data-goto-error") && T(e, !0, 1e3) } } }(!0), Tn = !0, O.inputMaskModule = new D({ logging: Tn }), document.addEventListener("click", (function (e) { })), function () { const e = document.querySelectorAll(".rating"); e.length > 0 && function () { let t, i; for (let t = 0; t < e.length; t++) { s(e[t]) } function s(e) { n(e), r(), e.classList.contains("rating_set") && o(e) } function n(e) { t = e.querySelector(".rating__active"), i = e.querySelector(".rating__value") } function r(e = i.innerHTML) { const s = e / .05; t.style.width = `${s}%` } function o(e) { const t = e.querySelectorAll(".rating__item"); for (let s = 0; s < t.length; s++) { const o = t[s]; o.addEventListener("mouseenter", (function (t) { n(e), r(o.value) })), o.addEventListener("mouseleave", (function (e) { r() })), o.addEventListener("click", (function (t) { n(e), e.dataset.ajax ? a(o.value, e) : (i.innerHTML = s + 1, r()) })) } } async function a(e, t) { if (!t.classList.contains("rating_sending")) { t.classList.add("rating_sending"); let e = await fetch("rating.json", { method: "GET" }); if (e.ok) { const s = (await e.json()).newRating; i.innerHTML = s, r(), t.classList.remove("rating_sending") } else alert("Ошибка"), t.classList.remove("rating_sending") } } }() }(), function () { ji = !0; const e = document.querySelector("header.header"), t = e.hasAttribute("data-scroll-show"), i = e.dataset.scrollShow ? e.dataset.scrollShow : 500, s = e.dataset.scroll ? e.dataset.scroll : 1; let n, r = 0; document.addEventListener("windowScroll", (function (o) { const a = window.scrollY; clearTimeout(n), a >= s ? (!e.classList.contains("_header-scroll") && e.classList.add("_header-scroll"), t && (a > r ? e.classList.contains("_header-show") && e.classList.remove("_header-show") : !e.classList.contains("_header-show") && e.classList.add("_header-show"), n = setTimeout((() => { !e.classList.contains("_header-show") && e.classList.add("_header-show") }), i))) : (e.classList.contains("_header-scroll") && e.classList.remove("_header-scroll"), t && e.classList.contains("_header-show") && e.classList.remove("_header-show")), r = a <= 0 ? 0 : a })) }() })() })();

